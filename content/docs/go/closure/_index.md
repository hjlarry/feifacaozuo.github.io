---
title: 闭包
bookToc: false
---

# 闭包


原理
-------

我们先来看这样一个示例:
{{< highlight go>}}
func test() func() {
	x := 100
	return func() {
		println(x)
	}
}
func main() {
	closure := test()
	closure()
}
{{< /highlight >}}
声明了一个test函数，它会返回一个匿名函数，这个匿名函数引用了它的局部变量x。那么当执行完`closure := test()`时，test的栈帧会被销毁，局部变量x应该失效，按照常理，匿名函数应该找不到x而无法打印，但实际上运行之后是能够正常打印的。那么这个x在哪？只有一种可能，它逃逸到堆上去了。既然是在堆上，x就会有一个地址，问题就变为匿名函数是怎么知道x的地址的？

我们把这种现象叫做闭包，当一个匿名函数离开了它的宿主时，它依然持有它所引用的环境变量。所以闭包是包含两个部分的，其一是一个指针指向匿名函数的地址，其二是所拥有的环境变量，这两个东西打包合起来才称为一个闭包。

可以理解为test函数的返回用伪码来表达应该是:
```
return closure struct{
    f : func(){println(x)}
    v : malloc(x)
}
```
只不过Go的语法上让我们可以简写为示例代码中的样子，调用的时候编译器也是隐式的使用`closure.f(closure.v)`这样的方式来调用。


实现方式
-------

下面我们观察它的编译过程来证明这件事。