# 内存分配

对于Go的内存分配器来讲，它有一些处理会比较麻烦，因为要支持并发，分配的时候就会有一堆人去抢。这时候我们考虑的可能是分配的时候给每个人一个相对大块的内存来减少分配的次数，也就相应的减少了竞争的次数。就像是分一个饼，一块块的分而不是一口口的吃，抢的次数就少了。同时还要考虑不用的内存需要回收以复用的问题，我们可以用钢铁厂做个比方。每个人都需要用钢铁做东西，他们的用途可能不太相同，有人拿来做刀，有人拿来做剑，有人拿来做棍棒，有人拿来既做刀又做剑。面对这种情况，我们直接把钢铁厂的钢铁给用户自己去做就不太合适了，就需要在中间加一层生产商更合理。

![](./images/1.png)

这样做的好处是原本需要都去钢铁厂竞争做这把刀的用户，现在在制刀厂竞争了，而且若是一个用户做剑、另一个用户做棍，现在则没有冲突了。商品生产商这一层分散了竞争效应，原本的一个锁变成了n个锁。同时仍然可以一次买10把刀，来减少和其他人抢的概率，这10把刀可以用来接着分配就没有人会来抢，当然这里会有一定的浪费，属于空间换时间的做法。

垃圾回收的时候，如果10把刀我只用了2把，剩下的8把就可以返还给制刀厂，给其他人用。这实现了一级平衡，即在相同类型之间的平衡。也有可能由于种种原因出现刀冗余非常多的情况，这时候就可以把刀给钢铁厂全部熔了做其他东西，这属于二级平衡，在材料上的平衡。

通过这三层结构，我们实现了二级平衡，达到了一定程度上的复用效果。那么需要多少种商品生产商呢？不可能因为每个人需求不同就给设定相应的商品生产商，我们需要对商品进行分类。对于内存分配器来说，它关心的是商品大小，先以32KB为界，把对象分为大对象和小对象。对于大于32KB的大对象，分配和回收都进行特殊对待，用户代码中大对象往往很少。对于小对象，我们按照8字节对齐，分为66种，例如8字节、16字节、32字节、48字节等等，例如对于1个9字节的对象，就会给它分配16字节，这可能会造成一定的空间浪费，但不至于产生过多的内存碎片。

现在，我们可以把钢铁厂叫堆(Heap)，它向操作系统申请内存