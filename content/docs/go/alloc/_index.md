# 内存分配

对于Go的内存分配器来讲，它有一些处理会比较麻烦，因为要支持并发，分配的时候就会有一堆人去抢。这时候我们考虑的可能是分配的时候给每个人一个相对大块的内存来减少分配的次数，也就相应的减少了竞争的次数。就像是分一个饼，一块块的分而不是一口口的吃，抢的次数就少了。同时还要考虑不用的内存需要回收以复用的问题，我们可以用钢铁厂做个比方。每个人都需要用钢铁做东西，他们的用途可能不太相同，有人拿来做刀，有人拿来做剑，有人拿来做棍棒，有人拿来既做刀又做剑。面对这种情况，我们直接把钢铁厂的钢铁给用户自己去做就不太合适了，就需要在中间加一层生产商更合理。

![](./images/1.png)

这样做的好处是原本需要都去钢铁厂竞争做这把刀的用户，现在在制刀厂竞争了，而且若是一个用户做剑、另一个用户做棍，现在则没有冲突了。商品生产商这一层分散了竞争效应，原本的一个锁变成了n个锁。同时仍然可以一次买10把刀，来减少和其他人抢的概率，这10把刀可以用来接着分配就没有人会来抢，当然这里会有一定的浪费，属于空间换时间的做法。

垃圾回收的时候，如果10把刀我只用了2把，剩下的8把就可以返还给制刀厂，给其他人用。这实现了一级平衡，即在相同类型之间的平衡。也有可能由于种种原因出现刀冗余非常多的情况，这时候就可以把刀给钢铁厂全部熔了做其他东西，这属于二级平衡，在材料上的平衡。

通过这三层结构，我们实现了二级平衡，达到了一定程度上的复用效果。那么需要多少种商品生产商呢？不可能因为每个人需求不同就给设定相应的商品生产商，我们需要对商品进行分类。对于内存分配器来说，它关心的是商品大小，先以32KB为界，把对象分为大对象和小对象。对于大于32KB的大对象，分配和回收都进行特殊对待，用户代码中大对象往往很少。对于小对象，我们按照8字节对齐，分为66种SizeClass，例如8字节、16字节、32字节、48字节等等，例如对于1个9字节的对象，就会给它分配16字节，这可能会造成一定的空间浪费，但不至于产生过多的内存碎片。

现在，我们可以把钢铁厂叫堆(Heap)，它向操作系统申请内存，负责管理原始材料。这66种商品生产商我们称为中间对象(Central)。再下面的人属于具体分配的，我们称为(Cache)，其实它就是缓存了一大批需要的东西接下来用于分配。我们把每块从操作系统拿的内存叫做Span，假设把它按照规格2即16字节来切分，就会形成了若干个小块，每个小块我们称为Object。现在变成了这样:

![](./images/2.png)

每个central分配的时候给的是一个切好了的span，每个cache还的时候也是还整个span，即使其中有部分object被用掉了也只是标记一下。

接着还有一些问题没有解决，第一是操作系统虚拟地址分配的问题。我们希望是在某个固定的段之内紧凑的进行内存分配来避免内存碎片化。这样我们就需要先提前占用一段内存空间，做为保留空间，并不进行实际的分配动作，我们把这段空间叫arena。那么如何在进程中找到这样一段连续的地址空间呢？首先向操作系统申请内存，操作系统必然会给一个可用的虚拟内存地址；然后尝试按这个地址向右扩张，如果右边被堵住了就向左边扩张；如果两边都被堵住了就再次向操作系统申请内存，尝试向右向左扩张的操作。64位地址空间还是比较大的，往往容易找到这样一段空间。

第二是每个span还需要位图(bitmap)来标记哪些是可用的，我们所说的切分object也只是理解上的切分，实际上我们要找到一个可用的object，就是用这个span的起始地址加上位图中可用对象的偏移量乘以SizeClass的大小，即base+offset*size。

第三，我们还需要一个反查表，它记录了每个span的起始地址，为什么需要这样一个表呢？假设某个span里面有100个object，我们只需要其中的10个object，我们就可用通过反查表把这个span一分为二，把剩余的90个object组成的span拿回来。拿回来之后还能通过反查表检查它左右相邻的span是不是闲置的，如果闲置则可把他们合并为一个大的块。所以span块大小可能不是固定的，根据需要可能会切分或合并。