# Mysql的原理


查询执行过程
-------

一条SQL查询语句在Mysql中是如何执行的呢？我们可以通过它的基本结构图看到各个模块在执行过程中起到的作用:

![structure](./images/structure.jpg)

Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖Mysql大多数核心服务功能，以及所有的内置函数、跨存储引擎的功能实现(如存储过程、触发器、视图等)。而存储引擎属于插件式架构，支持InnoDB、MyISAM、Memory等多个存储引擎，不同引擎共用一个Server层。

### 连接器
客户端一般通过TCP与服务端建立连接，用户名密码认证通过后，连接器先到权限列表中查出你拥有的权限，之后这个连接里的权限判断逻辑都依赖于此时读取到的，也就是说对这个权限的修改不会影响到已经正在连接的用户。

正在连接的客户端可以这样查看到:
{{< highlight mysql>}}
mysql> show processlist;
+----+------+-----------------+---------+---------+------+----------+------------------+
| Id | User | Host            | db      | Command | Time | State    | Info             |
+----+------+-----------------+---------+---------+------+----------+------------------+
|  4 | root | localhost       | awesome | Query   |    0 | starting | show processlist |
|  7 | root | localhost:58134 | boss    | Sleep   |    3 |          | NULL             |
|  8 | root | localhost:58135 | NULL    | Sleep   |    2 |          | NULL             |
+----+------+-----------------+---------+---------+------+----------+------------------+
3 rows in set (0.00 sec)
{{< /highlight >}}
Command列中显示为Sleep就表示该连接当前是空闲的，如果连接空闲太长时间就会被连接器自动断开，默认是8小时，可通过`wait_timeout`控制。

### 查询缓存
大多数情况下，我们往往不使用查询缓存，因为它是弊大于利的。它的失效非常的频繁，只要对一个表有更新，这个表上的所有查询缓存都会被清空。对于更新压力大的数据库来讲，查询缓存的命中效率很低。

Mysql8.0以上版本直接将该功能删掉了，所以我们的结构图上也只是把它画成一条支线。

### 分析器
词法分析就是根据一些关键词判断出你要做什么，例如`select`表示这是一个查询语句。那么接下来就会把字符串`T`识别为表名`T`，字符串`ID`识别为列名`ID`。

接着进行语法分析，就是判断输入的语句是否满足语法规则。语法错误的提示就是在这个阶段触发的，例如`You have an error in your SQL syntax`。

### 优化器
优化器是在表里有多个索引的时候决定使用哪个索引；或者有多表关联的时候决定各个表的连接顺序。例如`select * from t1 join t2 using(id) where t1.c=10 and t2.d=20`，就可以有两种处理方式:

* 先从表t1中取出c=10的记录的id，根据id关联到表t2，判断t2中d的值是否为20
* 先从表t2中取出d=20的记录的id，根据id关联到表t1，判断t1中c的值是否为10

这两种方法执行的效率可能不同，优化器就是用来决定使用哪种方案更合理。

### 执行器
执行时，先去判断该用户有没有对这个表的要做的操作的权限，如果没有会返回相应的错误。有权限的话则打开表继续执行，执行器会根据表的引擎定义，使用过这个引擎提供的接口来执行。


InnoDB
-------
`InnoDB`是一个将表中的数据存储到磁盘上的存储引擎，真正处理数据的过程是发生在内存上的，所以需要把数据从磁盘加载到内存中，如果是处理写入或更新时，还需要把内存中的内容写回磁盘中。`InnoDB`将数据划分为若干个页，每页大小为16KB，以页做为硬盘和内存交互的基本单位，一般情况下，每次至少会读取或写回16KB的内容。

### 数据页
这些页有很多的种类，例如存放空间头部信息的页、存放日志信息的页等等。我们先来了解存放记录的页，也就是数据页，官方称为索引页。

数据页被分为7个部分，有的部分占用固定大小的空间，有的不固定:

|名称|中文名|占用空间|简单描述|
|:--:|:--:|:--:|:--:|
|`File Header`|文件头部|`38`字节|页的一些通用信息|
|`Page Header`|页面头部|`56`字节|数据页专有的一些信息|
|`Infimum + Supremum`|最小和最大记录|`26`字节|两个虚拟的行记录|
|`User Records`|用户记录|不确定|实际存储的行记录内容|
|`Free Space`|空闲空间|不确定|页中尚未使用的空间|
|`Page Directory`|页面目录|不确定|页中的某些记录的相对位置|
|`File Trailer`|文件尾部|`8`字节|校验页是否完整|

在⻚的7个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到User Records中。但在一开始生成⻚的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space中申请一个记录大小的空间划分到User Records，当Free Space的空间全部被替换掉后，也就意味着这个⻚使用完 了，如果还有新的记录插入的话，就需要去申请新的⻚了。

每条记录的头信息中有一个`next_record`属性，从而使页中的数据串联成一个单链表，链表中的各个节点按主键的值由小到大连接起来。Innodb会把这些记录分成若干个不同的组，每组的最后一条记录的地址偏移量会存放在`Page Directory`中，这样通过主键在一个页中查找到一条记录就会非常的快，首先通过二分法查到它应该在哪个组中，接着遍历这个组找到相应的记录。

`File Header`主要存了上一页和下一页的编号，使得所有的数据页构成一个双向链表。而`File Trailer`会加入一些效验值，以保证从内存至硬盘同步数据的完整性。

### 行格式
每条用户记录在磁盘上的存放方式也被称为`行格式`或`记录格式`，行格式被分为四种，即`Compact`、`Redundant`、`Dynamic`和`Compressed`。它们原理上大体相同，所以我们以Compact格式为例来详细了解一下。

如图所示，每条记录被分为两个部分，记录的真实数据和记录的额外信息。
![record](./images/record.jpg)

Mysql支持一些变长的数据类型，如VARCHAR、各种TEXT、各种BLOB等类型，对于这类变长字段，除了存放它们真正的数据内容，还需要存它们占用了多大空间，在Compact中，会把它们占用多大空间按列的逆序存放在每条记录的头部。所以第一部分就是变长字段长度列表，它只存非NULL值的变长字段的列，如果表中没有变长字段，那就没有这一部分。但是如果当前表采用的字符集是变长字符集，那么对于CHAR类型的字段所占用的空间也会被加入到变长字段长度列表中。

为了让NULL值不占用过多的空间，Compact把NULL值的列统一管理在一个地方。它首先会统计表中哪些列允许有NULL值，即忽略掉主键列和被`NOT NULL`修饰的列；其次将这些统计出来的列逆序的对应一个个二进制位，每位为1时就代表这列当前的值为NULL。同样的，若表中没有允许存储NULL的列，那么这部分也不存在。

而记录的头信息都是一些二进制位，共计40位:

|名称|大小(bit)|描述|
|:--:|:--:|:--:|
|`预留位1`|`1`|没有使用|
|`预留位2`|`1`|没有使用|
|`delete_mask`|`1`|标记该记录是否被删除|
|`min_rec_mask`|`1`|B+树的每层非叶子节点中的最小记录都会添加该标记|
|`n_owned`|`4`|表示当前记录拥有的记录数|
|`heap_no`|`13`|表示当前记录在记录堆的位置信息|
|`record_type`|`3`|表示当前记录的类型|
|`next_record`|`16`|表示下一条记录的相对位置|

对于记录的真实数据部分，Mysql会为每条记录默认的添加一些列，也就是隐藏列，包括:

|列名|是否必须|占用空间|描述|
|:--:|:--:|:--:|:--:|
|`DB_ROW_ID`|否|`6`字节|行ID，唯一标识一条记录|
|`DB_TRX_ID`|是|`6`字节|事务ID|
|`DB_ROLL_PTR`|是|`7`字节|回滚指针|

对于主键，优先使用用户定义的，如果未定义则选取一个`Unique`键作为主键，如果没有`Unique`键则会添加一个`DB_ROW_ID`的隐藏列作为主键，所以这个隐藏列可能不存在。

之前提到一个数据页只有16KB，也就是16384字节，而VARCHAR、CHAR、TEXT、BLOB等字段都有可能大于它，这就造成了一个页存放不了一条记录的情况。我们把这种现象称为行溢出。对于这种情况，Compact会在记录的真实数据部分只存储这条记录的一部分，剩余的数据分散在其他的页中，然后真实数据部分还有20个字节指向这些页的地址。Dynamic、Compressed的行格式和Compact很像，只是在处理行溢出时有些不同罢了，它们只在记录的真实数据处存其他页面的地址，数据都在其他页面。Compressed采用压缩算法对页面进行压缩以节省空间。Mysql5.7默认的行格式就是Dynamic，Redundant属于Mysql5.0之前的快被淘汰的格式。

### 聚簇索引
在没有索引的情况下，我们无法快速定位到数据所在的页，只能从第一个页沿着双向链表依次向下找每个页，在每个页中如果查找的不是主键，还得依次去比对每条记录。显然，这种查询效率是非常低的。因此我们先来考虑一种简单的索引方式，先把页的结构简化来看。

![datapage](./images/datapage.jpg)

数据页中我们暂时认为每页存储三条记录就满了，每条记录我们只关注record_type，0表示普通记录，2表示最小记录，3表示最大记录，以及next_record表示下一条记录。

接下来对于数据的增删改操作，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立:下一个数据⻚中用户记录的主键值必须大于上一个⻚中用户记录的主键值。这个过程称为⻚分裂。有了这个状态的保证，我们可以给每个页建立一个目录项，每个目录项包括其对应的页号以及页中用户记录的最小的主键值，大概是这样的:

![index](./images/simpleindex.jpg)

这形成了一个简单的索引方案，我们把这些目录项放到一个数组中，当通过主键查找时就能通过这个数组找到对应的数据页，在根据数据页的Page Directory和二分法就可以迅速找到记录。

这个方案的问题是我们需要一段连续的物理空间来放这个存储目录项的数组，但Mysql只能保证页的数据是连续的，即16KB的连续空间。随着表中的数据越来越多，多到16KB根本放不下这些目录项怎么办？另一个问题是如果我们删除数据记录使得某一页中没有内容，那么这页就没必要存在，那么这页对应的目录项也没必要存在，把目录项删除后其后的目录项都得向前移动一下，这显然不是好的设计。

因此InnoDB复用了数据页来存储目录项，每条记录就是一个目录项，只不过这条记录的record_type是1，表示这是一条目录项记录，现在变成了这样:

![index](./images/index.jpg)

如果一个目录页放满了，就新增一个目录页，同时在其上再加一层目录页记录这两个目录页。这种数据组织方式就是B+树。

这种组织方式有两个特点:

1、 使用记录主键值的大小进行记录和⻚的排序，这包括三个方面的含义:

* ⻚内的记录是按照主键的大小顺序排成一个单向链表
* 各个存放用户记录的⻚是根据⻚中用户记录的主键大小顺序排成一个双向链表
* 存放目录项记录的⻚分为不同的层次，在同一层次中的⻚是根据⻚中目录项记录的主键大小顺序排成一个双向链表

2、 B+树的叶子节点存储的是完整的用户记录，即记录中包含了所有列的值。

我们把符合这两个特点的B+树称为聚簇索引，InnoDB会自动为我们创建聚簇索引，而由于所有的记录都在叶子节点上，也就是所谓的索引即数据，数据即索引。