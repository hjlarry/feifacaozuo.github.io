'use strict';(function(){const indexCfg={encode:false,tokenize:function(str){return str.replace(/[\x00-\x7F]/g,'').split('');}};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/sicp/hardware/','title':"硬件部分",'content':" 计算机科学基础知识之硬件部分 现代计算机体系的基础理论部分仍然是70年代就已经产生的，这些年来一直没有多大突破，只是制造水平和加工工艺在逐步提升。未来除非是量子计算、生物计算等发展成熟，才可能使得计算机基础理论获得革命性突破。\n我们在应用软件开发领域，往往非常善于创造包装一些名词，但它们的本质就是那么回事，学习计算机体系的理论有助于我们抓住这些本质。\n体系结构 CPU要运行一个程序，它需要指令和数据，指令相当于你要干什么，数据是干这件事所需要的材料。\n冯诺依曼结构 冯诺依曼结构就是把指令也当做数据，把指令和数据放在一起。好处就是设计上会简单一些，可以使用一条总线集中存储；另外它还采用了二进制编码的线性地址空间。缺点就是它的数据传输效率远低于CPU的运算效率，因此需要缓存来提升效率。\n它的CPU有两套单元： * ALU：算术逻辑单元，实现多组算术和逻辑运算。由与门和或门组成，进行二进制的算术运算，包括加、减、乘、与、或、非、异或。 * CU：控制单元，用于程序流程的管理。从内存中取指令放入指令寄存器中分析并执行。\nPS：在系统层面上，我们说的内存并不是指物理上的两根内存条，那个叫主存。比如硬盘上的缓存也是内存、打印机上也有缓存等等。\n哈佛结构 哈佛结构将指令和数据分开处理，指令和数据拥有不同的总线和地址空间，并行能力非常强，早期的大型计算机就采用这种结构。缺点就是早期电子电路昂贵，成本的问题使得它不适合于通用计算机没有推广开来。 现在纯粹的哈佛结构多用于数字信号处理器（DSP）、单片机等特定领域，它们的指令相对简单也没有缓存。\n对比总结 实际上现代计算机是对两种架构做了一些折中的。在内存中指令和数据是在一起的，在CPU的L1缓存中，会区分指令缓存和数据缓存，最终执行的时候指令和数据是从两个不同的地方出来的。另外冯诺依曼统一的地址空间也便于我们实现操作系统内存的管理、动态加载程序、JIT等。\n总线 我们通常所说的总线未必是电路板上一条条线路，它只是一种方式，可能是软件的，也可能是硬件的，代表了一整套的规范体系。就像高速公路交通网，包括了公路、收费站、加油站、维护人员、交通规则、信号灯指示牌，总线也是一样，除了数据通道，还包括了数据交换方式，比如从何处取（内存），从哪开始从哪结束有多长，取出来的是数据还是地址等。\n现在主流的总线标准为PCI/PCIe，该标准的带宽高，能探测硬件变更，支持热插拔。\n总线结构 按照不同的传输速度，我们会把总线分开，通过不同的速度来进行分流，使快速的部分拥有更多的流量带宽。北桥芯片处理快速设备，例如CPU、内存、显卡等，南桥芯片处理慢速设备，例如硬盘、网卡等。\n前端总线（FSB）负责CPU与北桥芯片的数据传输，代表CPU与外界数据的通讯速度，相当于CPU能处理的最高能力。而后端总线（BSB）负责与CPU内核通讯，其速度高于FSB。现在的芯片集成度越来越高的趋势也正是因为想减少各样的总线来提升各部件之间传输的速度。\n中央处理器 中央处理器是用来解释指令、处理数据的。编程实质上就是针对CPU而言的。例如我们往硬盘里写一个文件，就要知道文件名称、写在哪个地址、写入的长度等，即使这些工作不全是由CPU完成，CPU至少也要完成其中的调度工作。\n主频、外频 主频是内核工作频率，表达脉冲信号的震荡速度，与CPU的实际运算能力没有直接关系。而外频是内核与主板间的同步速度，同时也是内存和主板之间的同步速度。\n对现代的CPU而言，衡量其运算速度和性能要看各方面的性能指标，例如缓存、指令集等。很可能出现主频较高的CPU实际运算速度较低的情况。\n指令集 指令集是包含了基本数据类型、指令、寄存器、寻址模式、存储体系、中断和异常处理等打包的一套规范，是CPU真正能够理解的东西。\n我们通常分为精简指令集（RISC）和复杂指令集（CISC）。\n典型的复杂指令集就是x86，它的指令特别多，功能丰富，但每条指令的字长不等，也就造成了它需要先读出指令才知道后面的数据/参数有多长，执行速度相对较慢。而有一些虚拟机内会把指令设置为定长的，默认就是两个参数，这样它的缓存亲和性好，效率就高。x86这么设计有一些历史原因，当时还没有CPU缓存的概念。而精简指令集在早期反而是一种高大上的东西，它的指令和寻址方式少，格式统一，并行速度快，主要用于大型机和中高档服务器中。\nIntel认为自己定义的x86指令集由于历史原因等不好，于是在64位时代定义了IA-64指令集，但这种指令集和以前的x86并不兼容，它采用了模拟的方式去运行x86，这种方式在当时的windows2000等系统上运行的不好，所以微软持反对态度。此时AMD抓住了机会，它基于原有的386/IA-32标准做了扩充，也就有了现在的x86-64指令集，也可以叫做x64或AMD64。后来，Intel迫于其他厂商的压力，也去使用AMD64指令集，并在后来发展出了兼容的Intel 64，这种指令集和AMD64大部分是相同的。\n32位处理器的最大寻址为4GB（2的32次方），但64位处理器的最大寻址却不是2的64次方。我们知道存储单位的级别从小到大分别为Bytes、KB、MB、GB、TB、PB、EB，每级都等于前一级*1024，所以AMD64理论上可以访问16EB的地址空间，但目前的操作系统只支持到48位，也就是256TB的最大寻址，这种设定的根本原因就是能降低成本。\n此外，AMD64里增加了R8-R15的通用寄存器。\n寄存器和缓存 寄存器是所有存储体里最快的一个，因为数量少，所以可以直接给每个寄存器取个名字，而无需用地址。\n早期，数据由硬盘到内存，再经过前端总线直接到寄存器，因为前端总线传输的效率远低于CPU运算的效率，为了提高性能，我们在CPU内部，寄存器和内存之间增加了一层cache，使得前端总线每次传输更多的内容进入CPU。早期的CPU缓存只有L1，它将指令和数据分开；后来发展至L2，L2不区分指令和数据；再后来多核时代有了L3，能在一个物理处理器的多个核中共享。\n缓存只是解决性能问题的一个媒介，它本身有易丢失、易覆盖的特性，不能像寄存器和主存一样当做目标存储器使用。当CPU需要一个数据时，它会先去L1找，找不到则去L2，再找不到去L3找，再找不到就会去系统总线，找到以后批量的传到L3，再把命中的一部分填充至L2，再填充至L1，再返回给处理器。所以L1里有的数据L2、L3肯定有，每级缓存数据都是下一级的一部分。\n同时，基于时间局部性（正在被访问的数据可能近期再次被访问）、空间局部性（临近地址数据可能即将被访问）、顺序局部性（大部分指令是顺序执行），可以让缓存有较高的命中率。PS:我们宏观世界的缓存例如web服务中的memcache往往只是基于时间局部性，因为CPU是针对指令和字节的才去讨论其空间局部性和顺序局部性。\n我们写程序要尽可能的让其缓存亲和性更高，数据连续性更高，比如按一定长度对齐某些数据；对于性能要求高的程序，向操作系统申请锁死主存的一部分，避免被交换到硬盘当中去；甚至对于性能要求极致的场景，可以使用汇编以尽可能的使用寄存器。\n缓存由多个块组成，每个块我们称为cache line，每行的数据是连续的，每行的大小通常是64字节，行与行之间可能不连续，所以我们对齐数据的时候也是按行来对齐。同时，缓存中有很多的标志位，通过这些标志位去检查缓存是否更新，以决定是否需要置换回内存。\n多核 在一个处理器内集成多个独立实体物理内核。我们提及Core1、Core2的时候就表示多核，而CPU1、CPU2的时候则是多个CPU。多核能更好的在成本和性能上做出平衡，也不一定比多CPU慢，这主要看软件层面的优化。多核之间可以通过内部的L3缓存进行通讯或数据共享，而多CPU只能通过前端总线或额外建立其他外部通讯机制。\n多核架构又分为两种：\n对称多处理架构（SMP），多用于桌面端。每个处理器（在多核心处理器的例子中，对称多处理架构，将每一个核心都当成是独立的处理器）的地位是平等的，对资源的使用权限相同。好处是体系简单，缺点就是由于只有一个内存控制器，存在资源竞争的问题，一般是通过软硬件锁的机制解决，但随着处理器数量增加访问冲突就会增加，效率就会下降。\n非统一内存访问架构（NUMA），是一种为多处理器的电脑设计的内存架构。它将内存分散给多个处理器，处理器访问它自己的本地内存的速度比非本地内存（内存位于另一个处理器，或者是处理器之间共享的内存）快一些。它的扩展性更好，更适用于服务器，针对这种架构去编写程序效率也会更高。\n超线程 对于IO密集型任务，会出现CPU等待时间长的情况。那么超线程就是利用特殊的指令，在单个物理核内虚拟出多个逻辑处理器，在指令等待时做别的任务来减少闲置的时间，当然也需要额外的地方（AS，architectural state）保存当前上下文以切换任务。\n一般语言里提供的CPU数量都是逻辑处理器的数量，会将超线程虚拟的也算进去。例如python的multiprocessing.cpu_count()，或Go的runtime.NumCPU()。\n超线程多数时候可提升执行效率，但在有些情况下可能会导致性能下降，例如一些CPU密集的场合可能会对垃圾回收器造成负担；或者资源冲突时，依然需要等待，类似于同步锁。\n内存 内存严格来说叫内部存储器，不止包括物理上的内存条（即主存），硬盘、打印机等缓存也算作内部存储器。\n这里说的是主存，即随机存取存储器（RAM，Random Access Memory），它是与CPU直接交换数据的内部存储器。它可以随时读写，且速度很快，通常做为操作系统的临时数据存储介质。所谓的随机存取，是指当存储器的消息被读取或写入时，所需要的时间与这段信息所在的位置无关。\nDRAM 动态随机存取存储器。它具有结构简单，空间小，需要刷新的特点，往往被用于作为主存。\n需要刷新，是指电容器充满电后代表1，未充电的代表0。由于电容器或多或少有漏电的情形，若不作特别处理，电荷会渐渐随时间流失而使数据发生错误。刷新是指重新为电容器充电，弥补流失了的电荷。\nDDR是指具有双倍数据传输率的SDRAM（动态随机存取存储器），其数据传输速度为系统时脉的两倍。\nSRAM 静态随机存取存储器。它具有结构复杂，成本高，速度快的特点，一个典型的应用就是缓存。\n所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。相对之下，DRAM里面所储存的数据就需要周期性地更新。\n双通道 它在北桥内使用两个内存控制器分别控制一个通道，从而增加寻址和存储带宽，但是由于缓存的存在，并不需要这样的带宽，所以它对性能的提升往往感受不出来。在集成显卡的场景下会有一定帮助，因为集成显卡用内存作为显存，可以专门使用一条通道。\n显卡 转换显示信息，向显示器提供扫描信号。\n 2D芯片处理3D时需要CPU参与，称作软加速。 3D芯片自己完成，称作硬加速。  GPU是专门用来执行复杂的数学和几何计算的，它和CPU有什么区别呢？\nCPU需要很强的通用性来处理各种不同的数据类型，同时又要逻辑判断又会引入大量的分支跳转和中断的处理。这些都使得CPU的内部结构异常复杂。而GPU面对的则是类型高度统一的、相互无依赖的大规模数据和不需要被打断的纯净的计算环境。GPU的核数远超CPU，被称为众核（NVIDIA Fermi有512个核）。每个核拥有的缓存大小相对小，数字逻辑运算单元也少而简单。\n当程序员为CPU编写程序时，他们倾向于利用复杂的逻辑结构优化算法从而减少计算任务的运行时间，即Latency。当程序员为GPU编写程序时，则利用其处理海量数据的优势，通过提高总的数据吞吐量（Throughput）来掩盖Lantency。\n硬盘 主要的持久化存储媒介。\n分为固态硬盘（SSD）和机械硬盘（HDD）。SSD使⽤非易失性内存NAND Flash存储数据，无须电⼒维持。又分为单层SLC、双层MLC、三层TLC。单层最快，寿命最⻓，成本也最⾼。现在多使⽤MLC，TLC常作为U盘。\n其接口又分为SATA和SCSI。SATA是串行ATA，PC的标准接口。SCSI多用于小型机。\n其工作模式在BIOS可以设置，早期大多使用PIO，通过CPU执行IO指令读写数据，CPU要持续参与。现在多使用DMA，CPU只需要在开始和结束时参与，中间由DMA完成。\nIO cpu如何访问一大堆的设备？分为PMIO和MMIO。\nPMIO（Port Mapped I/O）是指端口映射输入输出，早期的时候会把主存和其他设备分开，分别用不同的CPU指令读写。因为使用了不同的地址总线，南桥一些慢速设备的访问不会拖累主存访问的效率。\n后来发现这种方式不好，64位时代内存地址空间充裕了就使用了MMIO（Memory Mapped I/O），它把内存地址空间分段，某一段设备用、程序用、操作系统用等，CPU使用相同的指令不同的地址就可操作设备，所有的设备都在监控地址总线，发现自己被访问就通过自身的缓存和MMU建立连接。\nBIOS 基本输入输出系统，启动后加载的第一个程序。\n最早没有操作系统的时候，写的程序就是面向BIOS的，BIOS在完成硬件初始化之后，会去执行硬盘上某个特定扇区的指令，所以只要把程序放在特定位置程序就可以启动。后来操作系统就放在那个位置，我们写的程序面向操作系统。\n它向操作系统提供系统参数、引导操作系统，但现代的操作系统比如mac就没有BIOS，而是直接控制硬件。\n"});index.add({'id':1,'href':'/docs/sicp/software/','title':"软件部分",'content':" 计算机科学基础知识之软件部分 操作系统 它是计算机体系的内核和基石，管理计算机硬件与软件资源。分为:\n 个人机: Windows, macOS, Linux/BSD 大型机: Linux, Unix 嵌入式: VxWorks 移动端: Android, Windows CE  因为Unix商业版权的原因，必须完全符合UNIX标准才能称为UNIX系统，其他的BSD/Linux只能称为UNIX-like。学术上的操作系统和我们日常口中说的操作系统不太一样，我们一般说的windows严格来说属于一个操作系统产品或者说一个操作系统的发行版，它是系统本身和一些软件（浏览器、扫雷）的打包，而学术上的操作系统指的是内核和一些必要的服务。\n现代操作系统的基本功能包括:\n 内存管理（memory management） 进程管理（process management） 中断处理（interrupt handling） 文件系统（file system) 安全机制（protection and security） 进程通信（inter-process communications） 设备驱动（device driver）  内核 微内核就是把最核心、最基础的部分单独作为内核，其他功能围绕它处理。包括地址空间、线程处理、进程通信等。这类东西它们需要以特权模式运行，其他基础服务当做普通应用程序独立运行。\n在内核中运行的程序使用的内存，叫内核空间，也叫内核态。其他程序运行在用户空间，也叫用户态。用户态的代码需要在内核态运行时，并不是直接放在内核态中运行的，这样安全没法保证，首先会做权限检查，通过之后相当于提交了申请，内核运行完成以后返回结果唤醒用户态的程序，这就又涉及到了上下文切换和状态保存。所以用户态和内核态的切换会消耗大量的资源。\n微内核的优点就是内核很小，裁剪起来方便，裁剪不同的基础服务就可以形成不同的版本面向不同的用户，另外就是其中某个服务崩溃的话不会影响到内核，内核可以重启改服务。当然缺点就是由于处于不同的地址空间，基础服务和内核通信时得使用类似于IPC（Inter-Process Communication）的方式通讯，效率相对会差一些。\n微内核的典型代表是学术上的windows和macOS，而不是Linux，早期的Linux为了性能考虑采用了宏内核。\n宏内核也叫单一内核，把核心和基础服务放在一个地址空间内均以特权模式运行，好处就是调用一些基础服务的时候相当于函数调用，不需要通讯，性能很高。缺点就是复杂度和耦合度很高，虽然代码是模块化的，但其中某个模块崩溃都可能导致整个系统崩溃，也不方便裁剪和移植。\n现代的操作系统往往是采用混合内核的，并不是泾渭分明的。\n系统调用 系统调用是内核对外的接口，内核态的一些内核函数。应用程序只要和硬件打交道都会涉及到系统调用，向操作系统申请并等待回复，应该尽量避免或考虑优化，比如有些场景可以使用在用户空间的带buffer的文件替代操作系统提供的文件读写API。\n典型的系统调用汇编代码:\nglobal _start section .data hello : db `hello, world!\\n` section .text _start: mov rax, 1 ; system call number should be store in rax mov rdi, 1 ; argument #1 in rdi: where to write (descriptor)? mov rsi, hello ; argument #2 in rsi: where does the string start? mov rdx, 14 ; argument #3 in rdx: how many bytes to write? syscall ; this instruction invokes a system call mov rax, 60 ; 'exit' syscall number xor rdi, rdi syscall  相比于call指令， int属于中断指令，需要栈切换并进行相关检查，开销更大一些。\n进程 基础概念 程序和进程有什么区别？\n某个程序里包含了某个进程所需要的数据，但在某个时间点，进程中的内容未必和程序中的内容是一一对应的。我们开发一个程序，不仅包括可执行的代码，还有周边的素材等等，程序运行的时候，也未必会把全部内容都载入到内存。而进程指的是程序运行时，在内存当中受操作系统管理的部分。程序就像是蓝图，我们可以是照着同一份蓝图启动多个进程。\n进程不是执行单位，而是一个资源边界。相当于在内存这个世界里面，进程圈了一块地，这块地有很多的属性，比如虚拟地址空间、PID等，而地上的工人、流水线才是执行单位，我们称为线程。所以每个进程都有一个主线程。\n 进程是程序的运行期实例（但不同操作系统对进程定义可能不同） 是系统动态执行基本单元 是系统资源分配单位 是线程的容器 是指令、数据及相关资源的集合 是程序运行过程的抽象  状态  ready:除分配CPU外，其他准备就绪（按优先级排队调度） running:占用处理器资源，正在执行 waiting:因IO blocking、sync等原因⽆无法继续执⾏  调度 采用抢占式调度，CPU分配时间片，时间片结束则强制性切换并保存上下文。另外一种调度模式叫协作式调度，一般是在用户空间实现的。\n线程 也称轻量级进程（LWP），是进程中的实际执行单位，由程序计数器、寄存器、栈内存组成。\n 进程拥有一到多个线程 线程是调度和时间片的分配单位，更多线程理论上会获得更多的CPU资源 线程共享进程的资源 同一程序的多个线程是可以在多核处理器上并行执行来提高执行吞吐率的，这个要看操作系统的调度策略  协程只是在用户空间的线程里实现的一种策略，本身和线程有很大的区别。\n内核线程和用户线程是有区别的，我们一般使用的线程都是被包装过的，很少通过系统调用来使用线程。用户线程可能是系统线程的包装体，它们是一对一关系；也可能是多个用户线程对应一个系统线程，多个用户线程分享一个时间片，这是多对一关系；还有一种可能是多对多关系，类似于Go的机制，某个时刻一个用户线程必然对应一个系统线程，但总体来看用户线程可能比系统线程更多或者更少。\n虚拟存储器 基础概念 操作系统会有一个很大的地址空间，也叫虚拟地址空间。这个空间的前面一大段是操作系统用的，之后的每个进程也都会有一个独立的很大的地址空间。这样不同的程序可以使用相同的虚拟地址，当程序在运行时访问这个地址就是访问进程内的虚拟地址，通过内存管理单元（MMU）翻译映射到一个物理地址。这样的好处就是无论在程序内的地址空间怎么折腾都不会影响到其他的程序，对编译器也更友好更方便，可以提前分配。\n我们在编译时看到的都是虚拟地址，物理地址在运行期才能看到。虚拟地址空间未必会全部映射到主存中，也会给各个设备保留一段空间。\n虚拟存储器可以看成硬盘保存的一个字节数组，虚拟地址空间有256TB，而实际的物理内存可能只有8GB，有这么大的虚拟地址空间就不能阻止程序去使用，不够的物理存储体我们就通过硬盘上的交换分区来弥补。也有可能物理内存加上交换分区都不够程序使用，在Linux中就会引发OOM机制。\n内存分配过程 假设某个程序需要内存分配器分配10MB的内存，那么操作系统会怎么做呢？首先会划分出一个虚拟地址范围，然后返回起始地址的指针。它此时没有必要通过MMU分配真实的物理内存，因为有可能这段内存后续根本没有读写发生。接下来若写入数据，也只会以页（8KB）为单位一点点的去写，每次写入的时候操作系统再去补物理内存，采用一种按需分配的机会主义原则。具体如何实现呢？当向一个虚拟地址写入数据时，就会去MMU找对应的物理地址，没有找到就说明没有建立映射关系还没有分配物理内存，就会引发一个缺页异常（page fault），操作系统内有专门的程序把这一页补上，来实现按需分配。\n我们通过程序可以模拟这种虚拟内存和物理内存的关系:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // gcc -g -O0 -o test test.c // ./test int main() { const size_t length = 1024 * 1024 * 100; const size_t pause = length / 10; unsigned char *p = malloc(length); // 分配100MB内存 unsigned char *x = p; for (int i = 0; i \u0026lt; (int)length; i++) // 循环写入数据 { *x = 1; x++; if (i % (int)pause == 0) // 隔一段时间暂停一下便于观察 { printf(\u0026quot;%d\\n\u0026quot;, i); getchar(); // 可以让用户在命令行中随时控制运行进度 } } free(p); return EXIT_SUCCESS; }  观察运行结果:\n[ubuntu] ~/.mac $ pidstat -r -p `pidof test` 1 │Linux 4.9.184-linuxkit (cabd4e519687) 12/06/19 _x86_64_ (2 CPU)│ │11:10:18 UID PID minflt/s majflt/s VSZ RSS %MEM Command │11:10:19 0 180 0.00 0.00 106908 21624 1.06 test │11:10:20 0 180 0.00 0.00 106908 21624 1.06 test │11:10:21 0 180 0.00 0.00 106908 21624 1.06 test │11:10:22 0 180 2560.00 0.00 106908 31920 1.56 test │11:10:23 0 180 0.00 0.00 106908 31920 1.56 test │11:10:24 0 180 2534.65 0.00 106908 42216 2.06 test │11:10:25 0 180 0.00 0.00 106908 42216 2.06 test │11:10:26 0 180 2560.00 0.00 106908 52512 2.57 test │11:10:27 0 180 0.00 0.00 106908 52512 2.57 test │11:10:28 0 180 0.00 0.00 106908 52512 2.57 test │11:10:29 0 180 0.00 0.00 106908 52512 2.57 test │11:10:30 0 180 2560.00 0.00 106908 62544 3.06 test  VSZ表示虚拟内存，RSS表示物理内存，可以看到随用户的控制，数据不断写入，物理内存增加。\n换入换出 假设这10MB内存已经分配下来，该程序却长时间不用，操作系统就会把这10MB内存的数据保存到硬盘的交换分区上，并对这些内存页的状态做变更，MMU的映射地址做变更，这些内存就可以去给别的程序用，这就叫换出（swap out）。下次重新激活该程序时，会把硬盘上交换分区的数据重新放回某些空闲的页并重新建立映射，这就是换入（swap in）。我们可以通过监控工具观察到系统内的换入换出情况:\n[ubuntu] ~ $ dstat You did not select any stats, using -cdngy by default. --total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system-- usr sys idl wai stl| read writ| recv send| in out | int csw 3 4 77 16 0| 12M 101k| 0 0 | 0 0 |1464 2562 0 0 100 0 0| 0 0 | 0 0 | 0 0 | 175 408 0 0 100 0 0| 0 0 | 0 0 | 0 0 | 148 345 0 0 100 0 0| 0 0 | 0 0 | 0 0 | 143 341 // paging的in和out即为当前换入换出大小,int表示当前有多少中断,csw表示当前有多少上下文切换  当程序运行需要的内存大于机器的物理内存时，就可能造成频繁的换入换出，产生颠簸效应（thrashing）。\n性能相关 如果程序需要性能更高、速度要有保障，就需要向操作系统申请锁死这段内存。同时，缺页异常属于内核级别的，有一定的开销，所以为了追求性能的极致，有的C程序会先进行一个初始化操作，缺页异常仍然会有只是会提前，在执行具体的算法时就会更高效不受缺页异常的影响，而一些高级语言可能会由于编译器的优化使得提前初始化写入被优化忽略掉。\n物理内存分配还采用了写入时复制（copy-on-write）的机制，即A若引用一块内存，那么复制A到B的时候并不会复制这块内存，只有当去写入A或B的时候才会去复制这块内存，起到节约内存的目的。\n对于服务器来讲，假设物理内存有8G，当前运行的程序只有4G，操作系统就会拿另外4G当做自己的cache用，比如缓存文件读写等，程序需要使用时再从cache里还回来。但对于桌面端用户来讲，GUI程序居多，占用内存也多，所以往往会有足够的内存来让用户载入一个程序的速度更快。服务器往往运行的程序数量和时间更长更稳定，所以不同操作系统的分配内存策略也不同。\n某种角度上，假设所有数据都交换到硬盘上，我们可以认为所有的数据保存在硬盘上，内存上只保存活跃数据，内存可以看成是硬盘的缓存或者说L4，虚拟存储器就可以看成硬盘上一个巨大的数组。\n可执行文件 一个可执行程序看上去像是单个文件的数据库，里面分成不同的表。可查看其头部信息:\n[ubuntu] ~/.mac $ readelf -h test ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 // 一个64位程序 Data: 2's complement, little endian // 大小端情况 Version: 1 (current) OS/ABI: UNIX - System V // 哪个平台使用 ABI Version: 0 Type: DYN (Shared object file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x610 //入口地址 Start of program headers: 64 (bytes into file) Start of section headers: 8880 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 9 Size of section headers: 64 (bytes) Number of section headers: 34 Section header string table index: 33  还可以查看其内部的分布情况:\n[ubuntu] ~/.mac $ readelf -S test There are 34 section headers, starting at offset 0x22b0: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .interp PROGBITS 0000000000000238 00000238 000000000000001c 0000000000000000 A 0 0 1 [ 2] .note.ABI-tag NOTE 0000000000000254 00000254 0000000000000020 0000000000000000 A 0 0 4 [ 3] .note.gnu.build-i NOTE 0000000000000274 00000274 0000000000000024 0000000000000000 A 0 0 4 [ 4] .gnu.hash GNU_HASH 0000000000000298 00000298 000000000000001c 0000000000000000 A 5 0 8 [ 5] .dynsym DYNSYM 00000000000002b8 000002b8 00000000000000f0 0000000000000018 A 6 1 8 [ 6] .dynstr STRTAB 00000000000003a8 000003a8 0000000000000098 0000000000000000 A 0 0 1 [ 7] .gnu.version VERSYM 0000000000000440 00000440 0000000000000014 0000000000000002 A 5 0 2 [ 8] .gnu.version_r VERNEED 0000000000000458 00000458 0000000000000020 0000000000000000 A 6 1 8 [ 9] .rela.dyn RELA 0000000000000478 00000478 00000000000000c0 0000000000000018 A 5 0 8 [10] .rela.plt RELA 0000000000000538 00000538 0000000000000060 0000000000000018 AI 5 22 8 [11] .init PROGBITS 0000000000000598 00000598 0000000000000017 0000000000000000 AX 0 0 4 [12] .plt PROGBITS 00000000000005b0 000005b0 0000000000000050 0000000000000010 AX 0 0 16 [13] .plt.got PROGBITS 0000000000000600 00000600 0000000000000008 0000000000000008 AX 0 0 8 [14] .text PROGBITS 0000000000000610 00000610 0000000000000222 0000000000000000 AX 0 0 16 [15] .fini PROGBITS 0000000000000834 00000834 0000000000000009 0000000000000000 AX 0 0 4 [16] .rodata PROGBITS 0000000000000840 00000840 0000000000000008 0000000000000000 A 0 0 4 [17] .eh_frame_hdr PROGBITS 0000000000000848 00000848 000000000000003c 0000000000000000 A 0 0 4 [18] .eh_frame PROGBITS 0000000000000888 00000888 0000000000000108 0000000000000000 A 0 0 8 [19] .init_array INIT_ARRAY 0000000000200da0 00000da0 0000000000000008 0000000000000008 WA 0 0 8 [20] .fini_array FINI_ARRAY 0000000000200da8 00000da8 0000000000000008 0000000000000008 WA 0 0 8 [21] .dynamic DYNAMIC 0000000000200db0 00000db0 00000000000001f0 0000000000000010 WA 6 0 8 [22] .got PROGBITS 0000000000200fa0 00000fa0 0000000000000060 0000000000000008 WA 0 0 8 [23] .data PROGBITS 0000000000201000 00001000 0000000000000010 0000000000000000 WA 0 0 8 [24] .bss NOBITS 0000000000201010 00001010 0000000000000008 0000000000000000 WA 0 0 1 [25] .comment PROGBITS 0000000000000000 00001010 000000000000002b 0000000000000001 MS 0 0 1 [26] .debug_aranges PROGBITS 0000000000000000 0000103b 0000000000000030 0000000000000000 0 0 1 [27] .debug_info PROGBITS 0000000000000000 0000106b 000000000000038d 0000000000000000 0 0 1 [28] .debug_abbrev PROGBITS 0000000000000000 000013f8 0000000000000109 0000000000000000 0 0 1 [29] .debug_line PROGBITS 0000000000000000 00001501 00000000000000ee 0000000000000000 0 0 1 [30] .debug_str PROGBITS 0000000000000000 000015ef 0000000000000295 0000000000000001 MS 0 0 1 [31] .symtab SYMTAB 0000000000000000 00001888 00000000000006a8 0000000000000018 32 48 8 [32] .strtab STRTAB 0000000000000000 00001f30 000000000000023f 0000000000000000 0 0 1 [33] .shstrtab STRTAB 0000000000000000 0000216f 000000000000013e 0000000000000000 0 0 1  可以看出该文件有34个表，每个表有自己的名字、起始和终止的虚拟地址、长度信息、权限信息等。\n它等于是一个蓝图，执行时按这个蓝图虚拟存储器去规划并映射它的地址空间。\n"});index.add({'id':2,'href':'/categories/','title':"Categories",'content':""});index.add({'id':3,'href':'/docs/','title':"Docs",'content':""});index.add({'id':4,'href':'/docs/go/goroutine/','title':"Go并发机制",'content':" Go并发调度 背景知识 GO和其他语言不同的就是我们很少在GO中听到多线程的概念，其提供的API中也没有创建线程这种东西。因为这门语言从用户写的第一行代码开始就是并发状态的。\n并发与并行 并发是指多个逻辑可以同时执行，把CPU时间分成不同的时间片段，这些时间片段分配给不同的逻辑，构成一个完整的CPU执行时间序列。 而并行是一种特殊的并发，不同逻辑由于CPU的多核，分配在不同的核上可以在物理时间上同时执行。这种状态其实很难实现，因为往往任一操作系统，它本身跑的程序非常多，远大于CPU核数。\n线程与协程 线程是执行单位，相当于工厂里的生产线。操作系统是按线程分配时间片，所以程序的线程越多获得的执行时间也就越长。线程是在系统空间实现的，而协程是在用户空间实现的，操作系统根本不知道协程。\n比如某个线程上有A、B两个任务，若A有死循环或者A等待网络响应等就会发生B被饿死的情况，为了避免这种情况，A就会主动让给B或者调度器去执行。这就是协程的工作方式，任务之间相互协商，属于协作式多任务系统，通常是在用户空间实现一个框架。而多线程是抢占式调度，不管某个程序会不会主动让出，当前时间片执行完就会被操作系统强迫分给其他线程。\n程序等于算法加数据，算法相当于一个解决问题的过程，数据又分为系统数据和用户数据。用户数据保存在用户堆栈上。操作系统为每个线程分配一个栈，大多用来保存局部变量，通常编译期就能确定，运行期通过寄存器访问，无需垃圾回收。而堆内存属于进程，进程内的线程共享，需要运行期动态分配以及垃圾回收。\n运行时 现代的编程语言创建一个线程往往是使用一个标准库或者第三方库提供API的，分配内存也往往会向操作系统提前申请一大块内存，通过这样一层抽象来减少用户态和内核态的切换来提升效率，我们把这层抽象叫做runtime（运行时）。它就像一个弱化版的操作系统，可以针对用户空间内的代码，结合当前语言的特性做大量的优化。\nGo运行时第一个抽象出的概念就是P（Processor），相当于处理器。物理上有多少个CPU、有多少个核，runtime并不关心，它是在OS上的一层抽象，os才是在硬件的上一层抽象。runtime认为在当前的环境内只有一个程序，所以我们可以通过P来设定并发的数量，同时能执行这个程序内的多少个并发任务。\n第二个抽象是M（Machine），对应了一个系统线程，是对线程的包装，也就是说P控制了同时有多少个M在执行。它是实际执行体，和P绑定，以调度循环方式不断执行G并发任务。\n第三个抽象就是G（Goroutine），实际上就是任务载体，或者说资源包，包括了函数地址，需要的参数，所需的内存。当我们使用go func(){}()时，实际上就是创建了一个G对象。\n为什么G需要内存，按说M相当于线程也就应该有了栈内存？实际上它们都有自己的内存，G中的内存为G.stack（默认大小2KB），M中的内存为G0。G在M上运行，就像是列车在线路上运行，线路本身也需要去投入资源维护。而把两块内存分开，是因为M所需的内存比较连续、相对固定、逻辑完整，G却会因为各种各样的原因或者异常可能会调度到别的M上去。\nG、M、P共同构成了多任务并发执行的基本模式，P用来控制同时有多少个并发任务执行，M对应到某个线程，G代表了go func语句翻译的一个任务包，最终还得有个调度器统合起来，把G放到合适的M上去执行。\n任务平衡 正向分析 当我们在一个for循环中创建了成千上万个并发任务时，它们并不是立即执行的，而是打包成一个个G对象保存在两个队列中（P本地队列和G全局队列）。\n假设当前只有4个P，在main函数执行的时候就需要一个P1/M1绑定体，main中创建的其他go func就会打包成G对象放在P1.queue中。也就是说任一M内创建的G都会保存在当前这个P的本地队列中，为什么不能放在P2、P3、P4的队列中？放在别的队列就需要去判断这个P是不是闲置的，还可能需要加锁等等，会变得很复杂。\n那么如果在main中创建了1000个G，它们就得等P1/M1中当前的任务执行完了才会得到执行，可能P2、P3、P4都是闲置的，这明显不合理。如何在多个P之间去平衡任务呢？使用了两种方法，一种是规定了每个P本地队列只能放256个G，一次放的过多时会按一定规则比如放一半到全局队列中去；另一种是某个P若闲置了就会在全局队列中去找（可能有很多P都在全局中找，就需要排队去找），找到了就把一部分任务移动到自己的本地队列中，没有找到就会去其他P中偷一部分任务过来，从全局队里或其他P中偷都是需要加锁的，效率相对会低一些。\n这样的平衡方式也就决定了我们没有办法确定哪个方法先执行，哪个后执行，除非我们自己写逻辑去判断先后。我们再来看一个关于执行顺序的示例:\nfunc main() { runtime.GOMAXPROCS(1) // 设置P为1 for i := 0; i \u0026lt; 10; i++ { go func(id int) { // 创建10个G time.Sleep(time.Second) fmt.Println(id) }(i) } time.Sleep(time.Second * 2) }  执行结果:\n[ubuntu] ~/.mac/gocode $ go run goroutine.go 9 0 1 2 3 4 5 6 7 8   为什么当P为1的时候，它不是顺序输出的，9总是在第一个？\n 每个P的本地队列中其实包含两个部分，runnext[1]和runq[256]。当我们每次添加一个任务的时候，它会先放在runnext中，再添加一个任务时，会把新添加的放在runnext，之前添加的放在runq中。runnext总是保留用户最后创建的任务，执行的时候先查runnext去执行。\n 为什么要有runnext的设计？\n 假设只创建了一个并发任务，也放在runq中让别的P去抢没有必要，而且大多数情况下我们不会去批量创建G；另外若runq既用来P1执行又让P2、P3去偷，那就又会涉及到加锁。\n 那么为什么是G9放在runnext，而不是G0？\n 因为放在runnext以后我们无法保证还有多少逻辑执行完才轮到它，就可能会runq中的任务都被偷走了且执行完了G0才会执行，这对G0很不公平。\n显然任务被分成了三个性能层次，runnext是完全私有的，runq属于原子操作（原子操作对CPU来讲也是锁，锁的是地址总线），Global属于一定要加mutex锁的，这三个层次产生资源竞争的可能性逐步增大。\n逆向分析 在最开始的时候，我们先设计为一个循环队列，它底层结构可能就是一个数组。问题在于，当有多个人去竞争的时候，这个数组就会存在资源竞争效应，我们就会考虑加入锁，显然这种效率是最低的。\n假设现在有3个P/M，我们就可以把一个大的队列拆分成3个小的队列，让每个P/M持有一个私有的队列，这种优化策略使得锁的问题可以解决掉。但也带来新的问题，可能P1已执行完自己的任务，P2、P3还得执行很久，我们可能一开始按任务的数量平均分配至各个私有队列，但有的任务执行时间很长，有的任务很快就能执行完。\n因此，P1应该去P2、P3中拿取任务才是合理的，所有人有义务去完成整个系统的任务。P1直接去拿就会和P2、P3打起来形成竞争效应，第二步的优化策略就是保留一个全局队列，P1可以先去全局队列里找，而P2、P3有很大概率是在本地队列去找的，P1获得锁的概率就会更大，全局队列使得锁的压力被分摊，同时也使得P2、P3中若有多余的任务也可以放进去。\n当P1的本地队列已执行完，全局队列中的任务也被执行完时，它就会任选P2或P3，形成直接的竞争。这时候我们考虑的优化策略，就是把本地队列一分为二，上面是runnext用于本地执行，下面是runq[256]用来给P1偷的。\n这种结构很像CPU的存储结构，通过分散距离、增加存储层次来减少直接竞争冲突的概率。\n调度执行 P、M解绑 当我们创建一个G的时候，实际上是背后的调度器在当前M上的G0去执行的，它发现有新的任务出现时，会发出一个唤醒信号，去检查有没有P空闲的，以及有没有M是休眠状态的？若P空闲且没有休眠的M，就会去创建一个M对象。所以唤醒操作要有意义，就得有P闲着没事干。\n那么M是怎样变为休眠状态的？\n当一个P和M绑定之后，它会进入到一个调度程序（Schedule函数），调度程序会去找G对象（按runnext、runq、Global、other P的顺序），找到之后内存由G0上执行切换到G.stack上去执行，执行完成之后进入收尾阶段，清理现场把G当做一个包装对象让它能重复使用。然后重新回到Schedule函数形成一个调度循环。\n这个循环可能因为找不到G对象而中断，比如说当前就只有一个任务。那么P和M就会解绑，M会进入休眠状态。\n还有一种P和M解绑的情况，比如当前在进行一个系统调用，而这个系统调用花了很长时间，调度器就会把这个P拿走干别的事，而M压根不知道，因为它在内核态，等系统调用结束以后M发现找不到P，那它就没法继续执行，只能把当前的任务状态保存回G.stack，在把执行一半的任务重新放回队列，M再次进入休眠状态，执行一半的任务再下次遇到P/M时接着执行。\n这就可能导致一个问题，创建出大量的空闲的M，不会被回收。M是会在操作系统内核中创建一个线程，尽管这种休眠状态下的M不会被CPU分配时间片，但仍然会占用管理资源，另外每个M上都带着G0内存，相当于资源泄漏了。我们通过如下代码来模拟这种情况：\nfunc main(){ for i :=0;i\u0026lt;1000;i++{ go func(){ runtime.LockOSThread() //通过锁模拟系统调用 defer runtime.UnlockOSThread() time.Sleep(time.Second*5) }() } time.Sleep(time.Minute) }  通过go build test.go \u0026amp;\u0026amp; GODEBUG=schedtrace=1000 ./test运行：\nSCHED 0ms: gomaxprocs=4 idleprocs=2 threads=5 spinningthreads=1 idlethreads=2 runqueue=0 [0 0 0 0] SCHED 1002ms: gomaxprocs=4 idleprocs=4 threads=1010 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0] SCHED 2008ms: gomaxprocs=4 idleprocs=4 threads=1010 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0] SCHED 3013ms: gomaxprocs=4 idleprocs=4 threads=1010 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0] SCHED 4014ms: gomaxprocs=4 idleprocs=4 threads=1010 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0] SCHED 5015ms: gomaxprocs=4 idleprocs=4 threads=1010 spinningthreads=0 idlethreads=127 runqueue=0 [0 0 0 0] SCHED 6017ms: gomaxprocs=4 idleprocs=4 threads=1010 spinningthreads=0 idlethreads=1007 runqueue=0 [0 0 0 0] SCHED 7025ms: gomaxprocs=4 idleprocs=4 threads=1010 spinningthreads=0 idlethreads=1007 runqueue=0 [0 0 0 0] SCHED 8027ms: gomaxprocs=4 idleprocs=4 threads=1010 spinningthreads=0 idlethreads=1007 runqueue=0 [0 0 0 0] SCHED 9029ms: gomaxprocs=4 idleprocs=4 threads=1010 spinningthreads=0 idlethreads=1007 runqueue=0 [0 0 0 0] SCHED 10031ms: gomaxprocs=4 idleprocs=4 threads=1010 spinningthreads=0 idlethreads=1007 runqueue=0 [0 0 0 0]  我们发现任务开始的时候共创建了1010个线程，任务执行完以后，仍然有1007个休眠的线程。当我们把runtime.LockOSThread()注释掉，重新运行：\nSCHED 0ms: gomaxprocs=4 idleprocs=1 threads=5 spinningthreads=1 idlethreads=1 runqueue=0 [48 49 133 0] SCHED 1004ms: gomaxprocs=4 idleprocs=4 threads=9 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0] SCHED 2008ms: gomaxprocs=4 idleprocs=4 threads=9 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0] SCHED 3010ms: gomaxprocs=4 idleprocs=4 threads=9 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0] SCHED 4015ms: gomaxprocs=4 idleprocs=4 threads=9 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0] SCHED 5026ms: gomaxprocs=4 idleprocs=4 threads=9 spinningthreads=0 idlethreads=7 runqueue=0 [0 0 0 0] SCHED 6031ms: gomaxprocs=4 idleprocs=4 threads=9 spinningthreads=0 idlethreads=7 runqueue=0 [0 0 0 0]  发现没有系统调用，那就根本不会有那么多线程。我们再把runtime.LockOSThread()保留，defer runtime.UnlockOSThread()去掉，运行结果如下：\nSCHED 0ms: gomaxprocs=4 idleprocs=2 threads=5 spinningthreads=1 idlethreads=2 runqueue=0 [0 0 152 0] SCHED 1000ms: gomaxprocs=4 idleprocs=4 threads=1010 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0] SCHED 2001ms: gomaxprocs=4 idleprocs=4 threads=1010 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0] SCHED 3008ms: gomaxprocs=4 idleprocs=4 threads=1010 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0] SCHED 4016ms: gomaxprocs=4 idleprocs=4 threads=1010 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0] SCHED 5019ms: gomaxprocs=4 idleprocs=0 threads=938 spinningthreads=0 idlethreads=4 runqueue=0 [18 1 3 7] SCHED 6027ms: gomaxprocs=4 idleprocs=4 threads=13 spinningthreads=0 idlethreads=10 runqueue=0 [0 0 0 0] SCHED 7037ms: gomaxprocs=4 idleprocs=4 threads=13 spinningthreads=0 idlethreads=10 runqueue=0 [0 0 0 0] SCHED 8042ms: gomaxprocs=4 idleprocs=4 threads=13 spinningthreads=0 idlethreads=10 runqueue=0 [0 0 0 0] SCHED 9044ms: gomaxprocs=4 idleprocs=4 threads=13 spinningthreads=0 idlethreads=10 runqueue=0 [0 0 0 0] cSCHED 10047ms: gomaxprocs=4 idleprocs=4 threads=13 spinningthreads=0 idlethreads=10 runqueue=0 [0 0 0 0]  我们发现那些创建的线程是会被回收的，线程没有被解锁意味着线程的状态没有被解除而陷入了死锁状态，线程不能再去接收新的任务没有存在的意义自然会被杀掉。\n综上，我们发现P往往是恒定的，而G和M是可复用的，复用虽然可能造成资源的浪费，但它避免了重新创建时的可能造成的竞争效应。对于一些长期运行的东西，我们需要再创建还是释放之间做一些权衡。\n任务饿死 假设当前的P/M正在执行一个G，这时候G里面创建了一个G1，G1会被放到当前P的runnext中，但它可能迟迟得不到执行被饿死，因为G中可能还有大量的逻辑代码执行完才轮到runnext，这显然是不合理的。怎么解决这个问题呢？是否可以让当前这个P/M交替的执行G和G1？P不是真正的CPU，没法实现基于时间片的抢占式调度，只能实现类似于协程那样的协作式调度。很多语言里都使用类似于Gosched()这样的函数来主动交出执行权，但Go中却很少见；还有一种形式是runtime带一个计数器，每执行一个任务后累加计数，当到达一个指定的计数就会被认为是使用完了时间片，向当前执行的P/M发出一个抢占式的信号，然后G主动让出执行权限。Go到底是怎样做的？我们来看如下示例：\n// GODEBUG=schedtrace=1000,scheddetail=1 ./test 可查看运行期GMP状态 func main(){ runtime.GOMAXPROCS(1) for i:=0;i\u0026lt;3;i++{ go func(id int){ println(id) x := 0 for{ // 死循环 x++ //print() } }(i) } time.Sleep(time.Second) }  我们模拟了只有一个P/M，这时候创建了3个G，让第一个G执行的过程中进入死循环，运行结果就是只打印出了任务0，其他G被饿死了。但当我们在死循环内x++后面加入一个函数，则任务0、1、2都会被打印出。问题就出在这个函数上。\n我们先使用一个简单的函数来观察：\n//go:noinline func test(){ println() } func main(){ test() }  使用go build \u0026amp;\u0026amp; go tool objdump -s \u0026quot;main\\.test\u0026quot; test反汇编：\nTEXT main.test(SB) /mnt/hgfs/disk/test.go test.go:5\t0x4525b0\t64488b0c25f8ffffff\tMOVQ FS:0xfffffff8, CX\ttest.go:5\t0x4525b9\t483b6110\tCMPQ 0x10(CX), SP\ttest.go:5\t0x4525bd\t7624\tJBE 0x4525e3\ttest.go:5\t0x4525bf\t4883ec08\tSUBQ $0x8, SP\ttest.go:5\t0x4525c3\t48892c24\tMOVQ BP, 0(SP)\ttest.go:5\t0x4525c7\t488d2c24\tLEAQ 0(SP), BP\ttest.go:6\t0x4525cb\te80031fdff\tCALL runtime.printlock(SB)\ttest.go:6\t0x4525d0\te88b33fdff\tCALL runtime.printnl(SB)\ttest.go:6\t0x4525d5\te87631fdff\tCALL runtime.printunlock(SB)\ttest.go:7\t0x4525da\t488b2c24\tMOVQ 0(SP), BP\ttest.go:7\t0x4525de\t4883c408\tADDQ $0x8, SP\ttest.go:7\t0x4525e2\tc3\tRET\ttest.go:5\t0x4525e3\te8187bffff\tCALL runtime.morestack_noctxt(SB)\ttest.go:5\t0x4525e8\tebc6\tJMP main.test(SB)\t 我们发现头部的三条指令和尾部的两条指令都是编译器插入的。runtime.morestack_noctxt会做两件事情，一是检查当前栈帧空间是否足够，如果不够可以帮助扩容；二是检查是否有人发出了抢占式调度信号，如果发现了信号，它就让出执行权限。函数前使用go:nosplit可以禁止编译器插入这样的指令。\n"});index.add({'id':5,'href':'/','title':"Introduction",'content':" 非法操作的知识库 主要用于记录学习过程中的重要知识点。\n关于作者  Github  Twitter  Email  Telegram  "});index.add({'id':6,'href':'/docs/mysql/query/','title':"Mysql查询",'content':" Mysql常用查询整理 数据准备 1、创建表格:\nCREATE TABLE student_info ( number INT PRIMARY KEY, name VARCHAR(5), sex ENUM('男', '女'), id_number CHAR(18), department VARCHAR(30), major VARCHAR(30), enrollment_time DATE, UNIQUE KEY (id_number) ); CREATE TABLE student_score ( number INT, subject VARCHAR(30), score TINYINT, PRIMARY KEY (number, subject), CONSTRAINT FOREIGN KEY(number) REFERENCES student_info(number) );  2、填充数据:\nINSERT INTO student_info(number, name, sex, id_number, department, major, enrollment_time) VALUES (20180101, '杜子腾', '男', '158177199901044792', '计算机学院', '计算机科学与工程', '2018-09-01'), (20180102, '杜琦燕', '女', '151008199801178529', '计算机学院', '计算机科学与工程', '2018-09-01'), (20180103, '范统', '男', '17156319980116959X', '计算机学院', '软件工程', '2018-09-01'), (20180104, '史珍香', '女', '141992199701078600', '计算机学院', '软件工程', '2018-09-01'), (20180105, '范剑', '男', '181048199308156368', '航天学院', '飞行器设计', '2018-09-01'), (20180106, '朱逸群', '男', '197995199501078445', '航天学院', '电子信息', '2018-09-01'); INSERT INTO student_score (number, subject, score) VALUES (20180101, '母猪的产后护理', 78), (20180101, '论萨达姆的战争准备', 88), (20180102, '母猪的产后护理', 100), (20180102, '论萨达姆的战争准备', 98), (20180103, '母猪的产后护理', 59), (20180103, '论萨达姆的战争准备', 61), (20180104, '母猪的产后护理', 55), (20180104, '论萨达姆的战争准备', 46);  3、填充结果:\nstudent_info表\n   number \u0026nbsp;name\u0026nbsp; sex id_number department \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;major\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; enrollment_time     20180101 杜子腾 男 158177199901044792 计算机学院 计算机科学与工程 2018-09-01   20180102 杜琦燕 女 151008199801178529 计算机学院 计算机科学与工程 2018-09-01   20180103 范统 男 17156319980116959X 计算机学院 软件工程 2018-09-01   20180104 史珍香 女 141992199701078600 计算机学院 软件工程 2018-09-01   20180105 范剑 男 181048199308156368 航天学院 飞行器设计 2018-09-01   20180106 朱逸群 男 197995199501078445 航天学院 电子信息 2018-09-01    student_score表\n   number subject score     20180101 母猪的产后护理 78   20180101 论萨达姆的战争准备 88   20180102 母猪的产后护理 100   20180102 论萨达姆的战争准备 98   20180103 母猪的产后护理 59   20180103 论萨达姆的战争准备 61   20180104 母猪的产后护理 55   20180104 论萨达姆的战争准备 46    基础查询 别名  方式一:select number as 学号 from student_score 方式二:select number 学号 from student_score\n  查询结果:\nmysql\u0026gt; select number 学号 from student_score; +----------+ | 学号 | +----------+ | 20180101 | | 20180101 | | 20180102 | | 20180102 | | 20180103 | | 20180103 | | 20180104 | | 20180104 | +----------+ 8 rows in set (0.00 sec)  多列也可以:\nmysql\u0026gt; select number 学号, name 姓名 from student_info; +----------+-----------+ | 学号 | 姓名 | +----------+-----------+ | 20180101 | 杜子腾 | | 20180102 | 杜琦燕 | | 20180103 | 范统 | | 20180104 | 史珍香 | | 20180105 | 范剑 | | 20180106 | 朱逸群 | +----------+-----------+ 6 rows in set (0.00 sec)  去重 单列去重:\nmysql\u0026gt; select distinct department from student_info; +-----------------+ | department | +-----------------+ | 计算机学院 | | 航天学院 | +-----------------+ 2 rows in set (0.00 sec)  多列去重:\nmysql\u0026gt; select distinct department,major from student_info; +-----------------+--------------------------+ | department | major | +-----------------+--------------------------+ | 计算机学院 | 计算机科学与工程 | | 计算机学院 | 软件工程 | | 航天学院 | 飞行器设计 | | 航天学院 | 电子信息 | +-----------------+--------------------------+ 4 rows in set (0.00 sec)  限制查询结果条数 使用limit 从哪开始，多少条，从哪开始可以省略，省略代表第0行。\nmysql\u0026gt; select * from student_info limit 3,8; +----------+-----------+------+--------------------+-----------------+-----------------+-----------------+ | number | name | sex | id_number | department | major | enrollment_time | +----------+-----------+------+--------------------+-----------------+-----------------+-----------------+ | 20180104 | 史珍香 | 女 | 141992199701078600 | 计算机学院 | 软件工程 | 2018-09-01 | | 20180105 | 范剑 | 男 | 181048199308156368 | 航天学院 | 飞行器设计 | 2018-09-01 | | 20180106 | 朱逸群 | 男 | 197995199501078445 | 航天学院 | 电子信息 | 2018-09-01 | +----------+-----------+------+--------------------+-----------------+-----------------+-----------------+ 3 rows in set (0.00 sec)  排序 多列排序:\nmysql\u0026gt; select * from student_info order by name asc, number desc; +----------+-----------+------+--------------------+-----------------+--------------------------+-----------------+ | number | name | sex | id_number | department | major | enrollment_time | +----------+-----------+------+--------------------+-----------------+--------------------------+-----------------+ | 20180104 | 史珍香 | 女 | 141992199701078600 | 计算机学院 | 软件工程 | 2018-09-01 | | 20180106 | 朱逸群 | 男 | 197995199501078445 | 航天学院 | 电子信息 | 2018-09-01 | | 20180101 | 杜子腾 | 男 | 158177199901044792 | 计算机学院 | 计算机科学与工程 | 2018-09-01 | | 20180102 | 杜琦燕 | 女 | 151008199801178529 | 计算机学院 | 计算机科学与工程 | 2018-09-01 | | 20180105 | 范剑 | 男 | 181048199308156368 | 航天学院 | 飞行器设计 | 2018-09-01 | | 20180103 | 范统 | 男 | 17156319980116959X | 计算机学院 | 软件工程 | 2018-09-01 | +----------+-----------+------+--------------------+-----------------+--------------------------+-----------------+ 6 rows in set (0.00 sec) mysql\u0026gt; select * from student_info order by name desc, number desc; +----------+-----------+------+--------------------+-----------------+--------------------------+-----------------+ | number | name | sex | id_number | department | major | enrollment_time | +----------+-----------+------+--------------------+-----------------+--------------------------+-----------------+ | 20180103 | 范统 | 男 | 17156319980116959X | 计算机学院 | 软件工程 | 2018-09-01 | | 20180105 | 范剑 | 男 | 181048199308156368 | 航天学院 | 飞行器设计 | 2018-09-01 | | 20180102 | 杜琦燕 | 女 | 151008199801178529 | 计算机学院 | 计算机科学与工程 | 2018-09-01 | | 20180101 | 杜子腾 | 男 | 158177199901044792 | 计算机学院 | 计算机科学与工程 | 2018-09-01 | | 20180106 | 朱逸群 | 男 | 197995199501078445 | 航天学院 | 电子信息 | 2018-09-01 | | 20180104 | 史珍香 | 女 | 141992199701078600 | 计算机学院 | 软件工程 | 2018-09-01 | +----------+-----------+------+--------------------+-----------------+--------------------------+-----------------+ 6 rows in set (0.00 sec)  带条件查询 简单搜索条件 不等于可以使用\u0026lt;\u0026gt;或!= :\nmysql\u0026gt; select * from student_info where department \u0026lt;\u0026gt; '计算机学院'; +----------+-----------+------+--------------------+--------------+-----------------+-----------------+ | number | name | sex | id_number | department | major | enrollment_time | +----------+-----------+------+--------------------+--------------+-----------------+-----------------+ | 20180105 | 范剑 | 男 | 181048199308156368 | 航天学院 | 飞行器设计 | 2018-09-01 | | 20180106 | 朱逸群 | 男 | 197995199501078445 | 航天学院 | 电子信息 | 2018-09-01 | +----------+-----------+------+--------------------+--------------+-----------------+-----------------+ 2 rows in set (0.00 sec)  区间内使用between...and...，不在某区间使用not between...and...:\nmysql\u0026gt; select * from student_info where number between 20180103 and 20180105; +----------+-----------+------+--------------------+-----------------+-----------------+-----------------+ | number | name | sex | id_number | department | major | enrollment_time | +----------+-----------+------+--------------------+-----------------+-----------------+-----------------+ | 20180103 | 范统 | 男 | 17156319980116959X | 计算机学院 | 软件工程 | 2018-09-01 | | 20180104 | 史珍香 | 女 | 141992199701078600 | 计算机学院 | 软件工程 | 2018-09-01 | | 20180105 | 范剑 | 男 | 181048199308156368 | 航天学院 | 飞行器设计 | 2018-09-01 | +----------+-----------+------+--------------------+-----------------+-----------------+-----------------+ 3 rows in set (0.01 sec) mysql\u0026gt; select * from student_info where number not between 20180103 and 20180105; +----------+-----------+------+--------------------+-----------------+--------------------------+-----------------+ | number | name | sex | id_number | department | major | enrollment_time | +----------+-----------+------+--------------------+-----------------+--------------------------+-----------------+ | 20180101 | 杜子腾 | 男 | 158177199901044792 | 计算机学院 | 计算机科学与工程 | 2018-09-01 | | 20180102 | 杜琦燕 | 女 | 151008199801178529 | 计算机学院 | 计算机科学与工程 | 2018-09-01 | | 20180106 | 朱逸群 | 男 | 197995199501078445 | 航天学院 | 电子信息 | 2018-09-01 | +----------+-----------+------+--------------------+-----------------+--------------------------+-----------------+ 3 rows in set (0.00 sec)  匹配列表中的元素 使用in (...)和not in筛选出在某个列表中的记录:\nmysql\u0026gt; select * from student_info where major in ('软件工程', '电子信息'); +----------+-----------+------+--------------------+-----------------+--------------+-----------------+ | number | name | sex | id_number | department | major | enrollment_time | +----------+-----------+------+--------------------+-----------------+--------------+-----------------+ | 20180103 | 范统 | 男 | 17156319980116959X | 计算机学院 | 软件工程 | 2018-09-01 | | 20180104 | 史珍香 | 女 | 141992199701078600 | 计算机学院 | 软件工程 | 2018-09-01 | | 20180106 | 朱逸群 | 男 | 197995199501078445 | 航天学院 | 电子信息 | 2018-09-01 | +----------+-----------+------+--------------------+-----------------+--------------+-----------------+ 3 rows in set (0.00 sec)  使用is null 和 is not null可筛选出某列是NULL的记录，而不能使用普通的操作符例如等号来进行比较，NULL代表没有值。\n多个搜索条件 AND优先级高于OR:\nmysql\u0026gt; SELECT * FROM student_score WHERE score \u0026gt; 95 OR score \u0026lt; 55 AND subject = '论萨达姆的战争准备'; +----------+-----------------------------+-------+ | number | subject | score | +----------+-----------------------------+-------+ | 20180102 | 母猪的产后护理 | 100 | | 20180102 | 论萨达姆的战争准备 | 98 | | 20180104 | 论萨达姆的战争准备 | 46 | +----------+-----------------------------+-------+ 3 rows in set (0.00 sec)  模糊查询 使用like和not like进行模糊匹配查询，%代表任意一个字符串，而_代表任意一个字符:\nmysql\u0026gt; select * from student_info where name like '杜_'; Empty set (0.00 sec) mysql\u0026gt; select * from student_info where name like '范_'; +----------+--------+------+--------------------+-----------------+-----------------+-----------------+ | number | name | sex | id_number | department | major | enrollment_time | +----------+--------+------+--------------------+-----------------+-----------------+-----------------+ | 20180103 | 范统 | 男 | 17156319980116959X | 计算机学院 | 软件工程 | 2018-09-01 | | 20180105 | 范剑 | 男 | 181048199308156368 | 航天学院 | 飞行器设计 | 2018-09-01 | +----------+--------+------+--------------------+-----------------+-----------------+-----------------+ 2 rows in set (0.00 sec) mysql\u0026gt; select * from student_info where name like '%杜%'; +----------+-----------+------+--------------------+-----------------+--------------------------+-----------------+ | number | name | sex | id_number | department | major | enrollment_time | +----------+-----------+------+--------------------+-----------------+--------------------------+-----------------+ | 20180101 | 杜子腾 | 男 | 158177199901044792 | 计算机学院 | 计算机科学与工程 | 2018-09-01 | | 20180102 | 杜琦燕 | 女 | 151008199801178529 | 计算机学院 | 计算机科学与工程 | 2018-09-01 | +----------+-----------+------+--------------------+-----------------+--------------------------+-----------------+ 2 rows in set (0.00 sec)  函数和表达式 表达式 可以将表达式放在查询列表中:\nmysql\u0026gt; select number,subject,score+100 from student_score; +----------+-----------------------------+-----------+ | number | subject | score+100 | +----------+-----------------------------+-----------+ | 20180101 | 母猪的产后护理 | 178 | | 20180101 | 论萨达姆的战争准备 | 188 | | 20180102 | 母猪的产后护理 | 200 | | 20180102 | 论萨达姆的战争准备 | 198 | | 20180103 | 母猪的产后护理 | 159 | | 20180103 | 论萨达姆的战争准备 | 161 | | 20180104 | 母猪的产后护理 | 155 | | 20180104 | 论萨达姆的战争准备 | 146 | +----------+-----------------------------+-----------+ 8 rows in set (0.00 sec)  也可以把表达式作为搜索的条件:\nmysql\u0026gt; select * from student_score where score%3=0; +----------+-----------------------+-------+ | number | subject | score | +----------+-----------------------+-------+ | 20180101 | 母猪的产后护理 | 78 | +----------+-----------------------+-------+ 1 row in set (0.00 sec)  文本处理 连接字符串:\nmysql\u0026gt; select concat('学号为',number,'的学生在[',subject,']的成绩为',score) from student_score; +--------------------------------------------------------------------------+ | concat('学号为',number,'的学生在[',subject,']的成绩为',score) | +--------------------------------------------------------------------------+ | 学号为20180101的学生在[母猪的产后护理]的成绩为78 | | 学号为20180101的学生在[论萨达姆的战争准备]的成绩为88 | | 学号为20180102的学生在[母猪的产后护理]的成绩为100 | | 学号为20180102的学生在[论萨达姆的战争准备]的成绩为98 | | 学号为20180103的学生在[母猪的产后护理]的成绩为59 | | 学号为20180103的学生在[论萨达姆的战争准备]的成绩为61 | | 学号为20180104的学生在[母猪的产后护理]的成绩为55 | | 学号为20180104的学生在[论萨达姆的战争准备]的成绩为46 | +--------------------------------------------------------------------------+ 8 rows in set (0.00 sec)  子串:\nmysql\u0026gt; select substring(number, 4, 5) as 学号尾号 from student_info; +--------------+ | 学号尾号 | +--------------+ | 80104 | | 80102 | | 80101 | | 80103 | | 80105 | | 80106 | +--------------+ 6 rows in set (0.00 sec)  时间处理函数 时间间隔:\nmysql\u0026gt; select date_add('2015-01-01 10:20:33', interval 2 minute); +----------------------------------------------------+ | date_add('2015-01-01 10:20:33', interval 2 minute) | +----------------------------------------------------+ | 2015-01-01 10:22:33 | +----------------------------------------------------+ 1 row in set (0.00 sec)  时间格式化:\nmysql\u0026gt; select date_format(now(), '%b/%d/%Y %h:%i:%s~%p'); +--------------------------------------------+ | date_format(now(), '%b/%d/%Y %h:%i:%s~%p') | +--------------------------------------------+ | Dec/02/2019 04:57:31~PM | +--------------------------------------------+ 1 row in set (0.00 sec)  聚集函数 COUNT用来统计行数 * COUNT(*)统计表中所有的行，包括NULL * COUNT(列名)统计表中某列的所有行，不包括NULL\nmysql\u0026gt; select count(*) from student_info; +----------+ | count(*) | +----------+ | 6 | +----------+ 1 row in set (0.00 sec) mysql\u0026gt; select count(distinct subject) from student_score; +-------------------------+ | count(distinct subject) | +-------------------------+ | 2 | +-------------------------+ 1 row in set (0.00 sec)  SUM和AVG:\nmysql\u0026gt; select sum(score) from student_score; +------------+ | sum(score) | +------------+ | 585 | +------------+ 1 row in set (0.00 sec) mysql\u0026gt; select avg(score) from student_score where subject=\u0026quot;论萨达姆的战争准备\u0026quot;; +------------+ | avg(score) | +------------+ | 73.2500 | +------------+ 1 row in set (0.00 sec)  组合使用:\nmysql\u0026gt; select count(*) as 成绩记录总数, max(score) as 最高分, min(score) as 最低分,avg(score) as 平均分 from student_score; +--------------------+-----------+-----------+-----------+ | 成绩记录总数 | 最高分 | 最低分 | 平均分 | +--------------------+-----------+-----------+-----------+ | 8 | 100 | 46 | 73.1250 | +--------------------+-----------+-----------+-----------+ 1 row in set (0.00 sec)  隐式类型转换 Mysql会尽量把值转换为表达式中需要的类型，而不是产生错误:\nmysql\u0026gt; select 1 + '2'; +---------+ | 1 + '2' | +---------+ | 3 | +---------+ 1 row in set (0.00 sec) mysql\u0026gt; select '23sds'+17; +------------+ | '23sds'+17 | +------------+ | 40 | +------------+ 1 row in set, 1 warning (0.00 sec)  但这种转换不能用于存储数据:\nmysql\u0026gt; insert into student_score(score,number,subject) values (100,20180101,300); Query OK, 1 row affected (0.00 sec) mysql\u0026gt; insert into student_score(score,number,subject) values ('100',20180101,400); Query OK, 1 row affected (0.00 sec) mysql\u0026gt; insert into student_score(score,number,subject) values ('asd',20180101,400); ERROR 1366 (HY000): Incorrect integer value: 'asd' for column 'score' at row 1  分组查询 基础查询 分组就是针对某个列，将该列的值相同的记录分到一个组中:\nmysql\u0026gt; select subject, sum(score) from student_score group by subject; +-----------------------------+------------+ | subject | sum(score) | +-----------------------------+------------+ | 母猪的产后护理 | 292 | | 论萨达姆的战争准备 | 293 | +-----------------------------+------------+ 2 rows in set (0.00 sec)  把非分组列放入查询列表中会引起争议，导致结果不确定:\nmysql\u0026gt; select subject, sum(score),number from student_score group by subject; ERROR 1055 (42000): Expression #3 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'student.student_score.number' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by  分组和过滤条件 是先过滤出符合条件的数据，在进行分组运算的:\nmysql\u0026gt; select subject, sum(score) from student_score where score\u0026gt;70 group by subject; +-----------------------------+------------+ | subject | sum(score) | +-----------------------------+------------+ | 母猪的产后护理 | 178 | | 论萨达姆的战争准备 | 186 | +-----------------------------+------------+ 2 rows in set (0.00 sec)  也可以分组后，在筛选出合适的分组:\nmysql\u0026gt; select subject, sum(score) from student_score group by subject having max(score)\u0026gt;98; +-----------------------+------------+ | subject | sum(score) | +-----------------------+------------+ | 母猪的产后护理 | 292 | +-----------------------+------------+ 1 row in set (0.00 sec)  分组和排序 mysql\u0026gt; select subject, sum(score) as sum_s from student_score group by subject order by sum_s desc; +-----------------------------+-------+ | subject | sum_s | +-----------------------------+-------+ | 论萨达姆的战争准备 | 293 | | 母猪的产后护理 | 292 | +-----------------------------+-------+ 2 rows in set (0.00 sec)  嵌套分组 如下例，可先按department分成大组，再按major分为小组:\nmysql\u0026gt; select department, major, count(*) from student_info group by department, major; +-----------------+--------------------------+----------+ | department | major | count(*) | +-----------------+--------------------------+----------+ | 航天学院 | 电子信息 | 1 | | 航天学院 | 飞行器设计 | 1 | | 计算机学院 | 计算机科学与工程 | 2 | | 计算机学院 | 软件工程 | 2 | +-----------------+--------------------------+----------+ 4 rows in set (0.00 sec)  注意事项  如果分组列中有NULL值，那么NULL会作为一个独立的分组 如果是嵌套分组，聚集函数将作用在最后的分组列上 非分组列不能单独出现在检索列表中（可以被放到聚集函数中） GROUP BY子句后可以跟随表达式（但不能是聚集函数）  简单查询语句中各子句的顺序为:\nSELECT [DISTINCT] 查询列表 [FROM 表名] [WHERE 布尔表达式] [GROUP BY 分组列表 ] [HAVING 分组过滤条件] [ORDER BY 排序列表] [LIMIT 开始行, 限制条数]  子查询 标量子查询 标量子查询单纯的代表一个值，可以作为表达式参与运算或作为搜索条件:\nmysql\u0026gt; select * from student_score where number=(select number from student_info where name='范统'); +----------+-----------------------------+-------+ | number | subject | score | +----------+-----------------------------+-------+ | 20180103 | 母猪的产后护理 | 59 | | 20180103 | 论萨达姆的战争准备 | 61 | +----------+-----------------------------+-------+ 2 rows in set (0.00 sec)  列子查询 内层查询结果不是一个单独的值，而是一个列:\nmysql\u0026gt; select * from student_score where number=(select number from student_info where sex='男'); ERROR 1242 (21000): Subquery returns more than 1 row mysql\u0026gt; select * from student_score where number in (select number from student_info where sex='男'); +----------+-----------------------------+-------+ | number | subject | score | +----------+-----------------------------+-------+ | 20180101 | 母猪的产后护理 | 78 | | 20180101 | 论萨达姆的战争准备 | 88 | | 20180103 | 母猪的产后护理 | 59 | | 20180103 | 论萨达姆的战争准备 | 61 | +----------+-----------------------------+-------+ 4 rows in set (0.00 sec)  而行子查询、表子查询不常用，省略。\nEXISTS和相关子查询 EXISTS和NOT EXISTS单独看很像一个函数，返回查询结果是否为空集:\nmysql\u0026gt; select exists (select * from student_info where number=20180101); +-----------------------------------------------------------+ | exists (select * from student_info where number=20180101) | +-----------------------------------------------------------+ | 1 | +-----------------------------------------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select not exists (select * from student_info where number=20180101); +---------------------------------------------------------------+ | not exists (select * from student_info where number=20180101) | +---------------------------------------------------------------+ | 0 | +---------------------------------------------------------------+ 1 row in set (0.00 sec)  之前我们尝试的都是不相关子查询，而相关子查询就是内层查询语句要用到外层查询语句的值，比如我们查学生的基本信息并要求这些学生有成绩的记录:\nmysql\u0026gt; select * from student_info where exists(select * from student_score where student_score.number=student_info.number); +----------+-----------+------+--------------------+-----------------+--------------------------+-----------------+ | number | name | sex | id_number | department | major | enrollment_time | +----------+-----------+------+--------------------+-----------------+--------------------------+-----------------+ | 20180101 | 杜子腾 | 男 | 158177199901044792 | 计算机学院 | 计算机科学与工程 | 2018-09-01 | | 20180102 | 杜琦燕 | 女 | 151008199801178529 | 计算机学院 | 计算机科学与工程 | 2018-09-01 | | 20180103 | 范统 | 男 | 17156319980116959X | 计算机学院 | 软件工程 | 2018-09-01 | | 20180104 | 史珍香 | 女 | 141992199701078600 | 计算机学院 | 软件工程 | 2018-09-01 | +----------+-----------+------+--------------------+-----------------+--------------------------+-----------------+ 4 rows in set (0.00 sec)  这个相关子查询的查询过程是:先执行外层查询获得到student_info表的第一条记录，发现它的number值是20180101。把20180101当作参数传入到子查询，此时子查询的意思是判断student_score表的number字段是否有20180101这个值存在，子查询的结果是该值存在，所以整个EXISTS表达式的值为TRUE，那么student_info表的第一条记录可以被加入到结果集。每条记录依次按这个过程执行。\n此外，子查询还可以应用于同一个表，比如我们去查student_score表中分数大于平均分的记录，第一印象可能是如下写法:\nmysql\u0026gt; select * from student_score where score \u0026gt; avg(score); ERROR 1111 (HY000): Invalid use of group function  实际应该使用子查询来实现:\nmysql\u0026gt; select * from student_score where score \u0026gt; (select avg(score) from student_score); +----------+-----------------------------+-------+ | number | subject | score | +----------+-----------------------------+-------+ | 20180101 | 母猪的产后护理 | 78 | | 20180101 | 论萨达姆的战争准备 | 88 | | 20180102 | 母猪的产后护理 | 100 | | 20180102 | 论萨达姆的战争准备 | 98 | +----------+-----------------------------+-------+ 4 rows in set (0.00 sec)  因为聚集函数不能用于WHERE子句，可以把上述写法看做是给student_score做了一个副本。\n连接查询 基础概念 连接的本质就是将各个表中的记录都拉取出来，依次匹配组合形成一个结果集，也就是笛卡尔积的方式。\n我们来看一个示例:\nmysql\u0026gt; create table t1(m1 int, n1 char(1)); Query OK, 0 rows affected (0.02 sec) mysql\u0026gt; create table t2(m2 int, n2 char(1)); Query OK, 0 rows affected (0.02 sec) mysql\u0026gt; insert into t1 values(1, 'a'),(2, 'b'),(3, 'c'); Query OK, 3 rows affected (0.00 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql\u0026gt; insert into t2 values(2, 'a'),(3, 'b'),(4, 'c'); Query OK, 3 rows affected (0.00 sec) Records: 3 Duplicates: 0 Warnings: 0  新建了两个表，并各插入了三条数据，那么连接可以这样做:\nmysql\u0026gt; select * from t1,t2; +------+------+------+------+ | m1 | n1 | m2 | n2 | +------+------+------+------+ | 1 | a | 2 | a | | 2 | b | 2 | a | | 3 | c | 2 | a | | 1 | a | 3 | b | | 2 | b | 3 | b | | 3 | c | 3 | b | | 1 | a | 4 | c | | 2 | b | 4 | c | | 3 | c | 4 | c | +------+------+------+------+ 9 rows in set (0.00 sec)  使用以下写法连接都是可以的:\n select t1.m1,t1.n1,t2.m2,t2.n2 from t1, t2 select m1,n1,m2,n2 from t1, t2 select t1.*,t2.* from t1, t2  内外连接 现在我们想通过一条语句既查到学生的基本信息，又查到他的成绩信息:\nmysql\u0026gt; select student_info.number,name,sex,subject,score from student_info, student_score where student_info.number = student_score.number; +----------+-----------+------+-----------------------------+-------+ | number | name | sex | subject | score | +----------+-----------+------+-----------------------------+-------+ | 20180101 | 杜子腾 | 男 | 母猪的产后护理 | 78 | | 20180101 | 杜子腾 | 男 | 论萨达姆的战争准备 | 88 | | 20180102 | 杜琦燕 | 女 | 母猪的产后护理 | 100 | | 20180102 | 杜琦燕 | 女 | 论萨达姆的战争准备 | 98 | | 20180103 | 范统 | 男 | 母猪的产后护理 | 59 | | 20180103 | 范统 | 男 | 论萨达姆的战争准备 | 61 | | 20180104 | 史珍香 | 女 | 母猪的产后护理 | 55 | | 20180104 | 史珍香 | 女 | 论萨达姆的战争准备 | 46 | +----------+-----------+------+-----------------------------+-------+ 8 rows in set (0.00 sec)  这时候我们发现有两个人没有成绩，所以他们没有显示在查询结果中。为了有办法让其显示出，就有了内连接和外连接的概念:\n 内连接就是我们之前使用的，没有匹配的记录则结果不会加入到最后的结果集 对于外连接的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集  而外连接又分为左外连接，即左侧的表为驱动表。右外连接，即右侧的表为驱动表。\n此外，WHERE子句不论内外连接，凡是不符合WHERE条件的记录都不会在最后的结果集中。而对于外连接的驱动表，ON可以将被驱动表中找不到记录的对应驱动表记录加入到结果集，内连接中WHERE子句和ON子句是等价的。所以我们一般会把WHERE用于涉及单表的过滤条件，ON用于涉及多表的过滤条件。\n外连接的标准语法为: select * from t1 left/right [outer] join t2 on 连接条件 [where 普通过滤条件]，outer和where可省略。\n上例中使用外连接的结果为:\nmysql\u0026gt; select student_info.number,name,sex,subject,score from student_info left join student_score on student_info.number = student_score.number; +----------+-----------+------+-----------------------------+-------+ | number | name | sex | subject | score | +----------+-----------+------+-----------------------------+-------+ | 20180101 | 杜子腾 | 男 | 母猪的产后护理 | 78 | | 20180101 | 杜子腾 | 男 | 论萨达姆的战争准备 | 88 | | 20180102 | 杜琦燕 | 女 | 母猪的产后护理 | 100 | | 20180102 | 杜琦燕 | 女 | 论萨达姆的战争准备 | 98 | | 20180103 | 范统 | 男 | 母猪的产后护理 | 59 | | 20180103 | 范统 | 男 | 论萨达姆的战争准备 | 61 | | 20180104 | 史珍香 | 女 | 母猪的产后护理 | 55 | | 20180104 | 史珍香 | 女 | 论萨达姆的战争准备 | 46 | | 20180105 | 范剑 | 男 | NULL | NULL | | 20180106 | 朱逸群 | 男 | NULL | NULL | +----------+-----------+------+-----------------------------+-------+ 10 rows in set (0.00 sec)  内连接以下的写法是等价的:\n select * from t1, t2 select * from t1 join t2 select * from t1 inner join t2 select * from t1 cross join t2  综上，我们总结以下三种连接的结果差异:\nmysql\u0026gt; select * from t1 inner join t2 on t1.m1=t2.m2; +------+------+------+------+ | m1 | n1 | m2 | n2 | +------+------+------+------+ | 2 | b | 2 | a | | 3 | c | 3 | b | +------+------+------+------+ 2 rows in set (0.00 sec) mysql\u0026gt; select * from t1 left join t2 on t1.m1=t2.m2; +------+------+------+------+ | m1 | n1 | m2 | n2 | +------+------+------+------+ | 2 | b | 2 | a | | 3 | c | 3 | b | | 1 | a | NULL | NULL | +------+------+------+------+ 3 rows in set (0.00 sec) mysql\u0026gt; select * from t1 right join t2 on t1.m1=t2.m2; +------+------+------+------+ | m1 | n1 | m2 | n2 | +------+------+------+------+ | 2 | b | 2 | a | | 3 | c | 3 | b | | NULL | NULL | 4 | c | +------+------+------+------+ 3 rows in set (0.00 sec)  多表连接 我们可以连接任意数量的表，我们再加入一张表试验:\nmysql\u0026gt; create table t3(m3 int, n3 char(1)); Query OK, 0 rows affected (0.07 sec) mysql\u0026gt; insert into t3 values(3, 'a'),(3, 'b'),(4, 'c'); Query OK, 3 rows affected (0.01 sec) Records: 3 Duplicates: 0 Warnings: 0  我们使用下面的语法查询是等价的:\n select * from t1 inner join t2 inner join t3 where t1.m1=t2.m2 and t2.m2=t3.m3; select * from t1 inner join t2 on t1.m1=t2.m2 inner join t3 on t1.m1=t3.m3;  查询结果:\nmysql\u0026gt; select * from t1 inner join t2 on t1.m1=t2.m2 inner join t3 on t1.m1=t3.m3; +------+------+------+------+------+------+ | m1 | n1 | m2 | n2 | m3 | n3 | +------+------+------+------+------+------+ | 3 | c | 3 | b | 3 | a | | 3 | c | 3 | b | 3 | b | +------+------+------+------+------+------+ 2 rows in set (0.00 sec)  也可以用伪代码来描述:\nfor each_row in t1{ for each_row in t2 which t1.m1=t2.m2{ for each_row in t3 which t2.m2=t3.m3{ add_result(each_row) } } }  自连接 我们无法直接自连接，但可以通过别名:\nmysql\u0026gt; select * from t1, t1; ERROR 1066 (42000): Not unique table/alias: 't1' mysql\u0026gt; select * from t1 as table1, t1 as table2; +------+------+------+------+ | m1 | n1 | m1 | n1 | +------+------+------+------+ | 1 | a | 1 | a | | 2 | b | 1 | a | | 3 | c | 1 | a | | 1 | a | 2 | b | | 2 | b | 2 | b | | 3 | c | 2 | b | | 1 | a | 3 | c | | 2 | b | 3 | c | | 3 | c | 3 | c | +------+------+------+------+ 9 rows in set (0.00 sec)  而自连接的意义，比如要查询与\u0026rsquo;范统\u0026rsquo;的专业相同的同学:\nmysql\u0026gt; select * from student_info as s1, student_info as s2 where s1.name='范统' and s1.major=s2.major; +----------+--------+------+--------------------+-----------------+--------------+-----------------+----------+-----------+------+--------------------+-----------------+--------------+-----------------+ | number | name | sex | id_number | department | major | enrollment_time | number | name | sex | id_number | department | major | enrollment_time | +----------+--------+------+--------------------+-----------------+--------------+-----------------+----------+-----------+------+--------------------+-----------------+--------------+-----------------+ | 20180103 | 范统 | 男 | 17156319980116959X | 计算机学院 | 软件工程 | 2018-09-01 | 20180103 | 范统 | 男 | 17156319980116959X | 计算机学院 | 软件工程 | 2018-09-01 | | 20180103 | 范统 | 男 | 17156319980116959X | 计算机学院 | 软件工程 | 2018-09-01 | 20180104 | 史珍香 | 女 | 141992199701078600 | 计算机学院 | 软件工程 | 2018-09-01 | +----------+--------+------+--------------------+-----------------+--------------+-----------------+----------+-----------+------+--------------------+-----------------+--------------+-----------------+ 2 rows in set (0.00 sec)  与子查询转换 有的需求既可以用连接查询，也可以用子查询:\nmysql\u0026gt; select * from student_score where number in (select number from student_info where major='软件工程'); +----------+-----------------------------+-------+ | number | subject | score | +----------+-----------------------------+-------+ | 20180103 | 母猪的产后护理 | 59 | | 20180103 | 论萨达姆的战争准备 | 61 | | 20180104 | 母猪的产后护理 | 55 | | 20180104 | 论萨达姆的战争准备 | 46 | +----------+-----------------------------+-------+ 4 rows in set (0.00 sec) mysql\u0026gt; select s2.* from student_score as s2, student_info as s1 where s1.number=s2.number and s1.major='软件工程'; +----------+-----------------------------+-------+ | number | subject | score | +----------+-----------------------------+-------+ | 20180103 | 母猪的产后护理 | 59 | | 20180103 | 论萨达姆的战争准备 | 61 | | 20180104 | 母猪的产后护理 | 55 | | 20180104 | 论萨达姆的战争准备 | 46 | +----------+-----------------------------+-------+ 4 rows in set (0.00 sec)  "});index.add({'id':7,'href':'/tags/','title':"Tags",'content':""});})();