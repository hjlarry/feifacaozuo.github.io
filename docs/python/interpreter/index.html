<!DOCTYPE html>
<html lang="cn">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="CPython解释器 字节码 Python中的字节码并不能被CPU执行，而是由栈式虚拟机执行，每条指令的背后都对应了一大堆C实现的机器指令。
字节码被存储在代码对象(即__code__)的co_code中，以一个函数为例: &gt;&gt;&gt; def add(x, y): ... z = x &#43; y ... return z &gt;&gt;&gt; &#34; &#34;.join(str(b) for b in add.__code__.co_code) &#39;124 0 124 1 23 0 125 2 124 2 83 0&#39; 字节码中每两个数字为一组，第一个为指令，第二个为参数，指令对应的二进制数可以在CPython源码中找到: &lt;!-- cpython/Include/opcode.h --&gt; #define BINARY_ADD 23 #define RETURN_VALUE 83 #define LOAD_FAST 124 #define STORE_FAST 125 这就可以和dis的输出结果对应起来: &gt;&gt;&gt; dis.dis(add) &lt;!-- 源码行 偏移量 指令 参数(目标对象) --&gt; 2 0 LOAD_FAST 0 (x) 2 LOAD_FAST 1 (y) 4 BINARY_ADD 6 STORE_FAST 2 (z) 3 8 LOAD_FAST 2 (z) 10 RETURN_VALUE 指令所对应的源码行这个信息其实保存在代码对象的两个相关属性中，co_firstlineno用来存储该段代码起始的行号，co_lnotab由每两个数字一组组成，前一个为字节码偏移的位置，后一个为相对前一组行号的增量。每条字节码指令代表的意义可通过官方文档此处查询到。"><meta property="og:title" content="CPython解释器" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/docs/python/interpreter/" />

<title>CPython解释器 | Home</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.63eb88daa545365405ecdbb21033286a325c60a36cfa6d22d21e7c3bc9286941.css" integrity="sha256-Y&#43;uI2qVFNlQF7NuyEDMoajJcYKNs&#43;m0i0h58O8koaUE=">
<script defer src="/cn.search.min.e2f9991fce850051589d642e11744c0e5b670dd7865582e37742416e531704a5.js" integrity="sha256-4vmZH86FAFFYnWQuEXRMDltnDdeGVYLjd0JBblMXBKU="></script>
<link rel="alternate" type="application/rss+xml" href="/docs/python/interpreter/index.xml" title="Home" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><img src="/logo.png" alt="Logo" /><span>Home</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  <ul>
<li><strong>计算机基础</strong>
<ul>
<li><a href="/docs/sicp/hardware/">硬件</a></li>
<li><a href="/docs/sicp/software/">软件</a></li>
<li><a href="/docs/sicp/asm/">汇编</a></li>
</ul>
</li>
<li><strong>GO语言</strong>
<ul>
<li><a href="/docs/go/map/">字典</a></li>
<li><a href="/docs/go/closure/">闭包</a></li>
<li><a href="/docs/go/defer/">延迟调用</a></li>
<li><a href="/docs/go/goroutine/">并发调度</a></li>
<li><a href="/docs/go/alloc/">内存分配</a></li>
<li><a href="/docs/go/gc/">垃圾回收</a></li>
<li><a href="/docs/go/lock/">锁</a></li>
</ul>
</li>
<li><strong>Python语言</strong>
<ul>
<li><a href="/docs/python/descriptor/">描述符</a></li>
<li><a href="/docs/python/memory/">内存管理</a></li>
<li><a href="/docs/python/interpreter/"class=active>解释器</a></li>
<li><a href="/docs/python/tools/">技巧工具</a></li>
</ul>
</li>
<li><strong>Mysql</strong>
<ul>
<li><a href="/docs/mysql/query/">查询</a></li>
<li><a href="/docs/mysql/theory/">原理</a></li>
</ul>
</li>
<li><strong>其他</strong>
<ul>
<li><a href="/docs/other/git/">git</a></li>
<li><a href="/docs/other/docker/">docker</a></li>
<li><a href="/docs/other/raft/">raft</a></li>
<li><a href="/docs/other/shell/">shell</a></li>
<li><a href="/docs/other/protocol/">网络协议</a></li>
<li><a href="/docs/other/tools/">系统工具</a></li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>CPython解释器</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#字节码">字节码</a></li>
    <li><a href="#gil">GIL</a></li>
    <li><a href="#执行过程">执行过程</a>
      <ul>
        <li><a href="#编码规范">编码规范</a></li>
        <li><a href="#执行方式">执行方式</a></li>
        <li><a href="#建立运行时环境">建立运行时环境</a></li>
        <li><a href="#通过输入运行">通过输入运行</a></li>
        <li><a href="#语义解析">语义解析</a></li>
        <li><a href="#ast">AST</a></li>
        <li><a href="#编译">编译</a></li>
        <li><a href="#终止">终止</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="cpython解释器">CPython解释器</h1>
<h2 id="字节码">字节码</h2>
<p>Python中的字节码并不能被CPU执行，而是由栈式虚拟机执行，每条指令的背后都对应了一大堆C实现的机器指令。</p>
<p>字节码被存储在代码对象(即<code>__code__</code>)的<code>co_code</code>中，以一个函数为例:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add</span>(x, y):                                                                                          
<span style="color:#f92672">...</span>     z <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> y
<span style="color:#f92672">...</span>     <span style="color:#66d9ef">return</span> z

<span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">.</span>join(str(b) <span style="color:#66d9ef">for</span> b <span style="color:#f92672">in</span> add<span style="color:#f92672">.</span>__code__<span style="color:#f92672">.</span>co_code)
<span style="color:#e6db74">&#39;124 0 124 1 23 0 125 2 124 2 83 0&#39;</span></code></pre></div>
字节码中每两个数字为一组，第一个为指令，第二个为参数，指令对应的二进制数可以在CPython源码中找到:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f92672">&lt;!--</span> cpython<span style="color:#f92672">/</span>Include<span style="color:#f92672">/</span>opcode.h <span style="color:#f92672">--&gt;</span>
<span style="color:#75715e">#define BINARY_ADD               23
</span><span style="color:#75715e">#define RETURN_VALUE             83
</span><span style="color:#75715e">#define LOAD_FAST               124
</span><span style="color:#75715e">#define STORE_FAST              125</span></code></pre></div>
这就可以和dis的输出结果对应起来:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> dis<span style="color:#f92672">.</span>dis(add)
<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">!</span><span style="color:#f92672">--</span> <span style="color:#960050;background-color:#1e0010">源码行</span>    <span style="color:#960050;background-color:#1e0010">偏移量</span> <span style="color:#960050;background-color:#1e0010">指令</span>           <span style="color:#960050;background-color:#1e0010">参数</span>(<span style="color:#960050;background-color:#1e0010">目标对象</span>)  <span style="color:#f92672">--&gt;</span>
  <span style="color:#ae81ff">2</span>           <span style="color:#ae81ff">0</span> LOAD_FAST                <span style="color:#ae81ff">0</span> (x)
              <span style="color:#ae81ff">2</span> LOAD_FAST                <span style="color:#ae81ff">1</span> (y)
              <span style="color:#ae81ff">4</span> BINARY_ADD
              <span style="color:#ae81ff">6</span> STORE_FAST               <span style="color:#ae81ff">2</span> (z)

  <span style="color:#ae81ff">3</span>           <span style="color:#ae81ff">8</span> LOAD_FAST                <span style="color:#ae81ff">2</span> (z)
             <span style="color:#ae81ff">10</span> RETURN_VALUE</code></pre></div>
指令所对应的源码行这个信息其实保存在代码对象的两个相关属性中，<code>co_firstlineno</code>用来存储该段代码起始的行号，<code>co_lnotab</code>由每两个数字一组组成，前一个为字节码偏移的位置，后一个为相对前一组行号的增量。每条字节码指令代表的意义可通过官方文档<a href="https://docs.python.org/3/library/dis.html">此处</a>查询到。</p>
<h2 id="gil">GIL</h2>
<p>全局解释器锁机制使得解释器在同一时刻仅有一个线程可以被调度执行，某个线程若想要执行，就先要拿到GIL，但在每个Python进程中，只有一个GIL。它的存在使得解释器本身的实现更简单一些，更容易实现对象的安全访问，便于进行内存管理和编写扩展。但在多核环境下无法实现并行，对于以多线程为基础的并发应用就是一个灾难。</p>
<p>对于IO密集型任务，线程是在发生阻塞时主动释放GIL的，让其他线程得以执行。而对于CPU密集型任务，采取超时策略。</p>
<p>当GIL被其他线程占用时，等待线程会阻塞一段时间。如果超时（默认为0.005秒）后，依然无法获取锁，则发出请求。这种请求设计的很轻巧，就是一个全局条件变量设置。正在执行的线程在解释循环内会检查该标记，然后释放锁，切换线程执行，其自身进入等待状态。属于典型的协作机制。相关源码:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f92672">&lt;!--</span> cpython<span style="color:#f92672">/</span>Python<span style="color:#f92672">/</span>ceval.c <span style="color:#f92672">--&gt;</span>
main_loop:
    <span style="color:#66d9ef">for</span> (;;) {
        <span style="color:#66d9ef">if</span> (_Py_atomic_load_relaxed(eval_breaker)) {
            opcode <span style="color:#f92672">=</span> _Py_OPCODE(<span style="color:#f92672">*</span>next_instr);
            <span style="color:#66d9ef">if</span> (_Py_atomic_load_relaxed(<span style="color:#f92672">&amp;</span>ceval<span style="color:#f92672">-&gt;</span>gil_drop_request)) {
                <span style="color:#75715e">/* Give another thread a chance */</span>
                drop_gil(ceval, tstate);

                <span style="color:#75715e">/* Other threads may run now */</span>
                take_gil(ceval, tstate);

                <span style="color:#75715e">/* Check if we should make a quick exit. */</span>
                exit_thread_if_finalizing(tstate);

                <span style="color:#66d9ef">if</span> (_PyThreadState_Swap(<span style="color:#f92672">&amp;</span>runtime<span style="color:#f92672">-&gt;</span>gilstate, tstate) <span style="color:#f92672">!=</span> NULL) {
                    Py_FatalError(<span style="color:#e6db74">&#34;ceval: orphan tstate&#34;</span>);
                }
            }
        }
        <span style="color:#66d9ef">switch</span> (opcode) {
          <span style="color:#66d9ef">case</span> TARGET(NOP)<span style="color:#f92672">:</span>
          <span style="color:#66d9ef">case</span> TARGET(LOAD_FAST)<span style="color:#f92672">:</span>
          ...
        }
    }</code></pre></div>
CPython使用系统线程，且没有实现线程调度。所以，具体哪个等待线程被切换执行，由操作系统决定。甚至，发出请求和被切换执行的未必就是同一个线程。</p>
<p>对于CPU密集型任务，除了使用多进程架构绕开，也可以使用C来编写多线程的扩展也能绕开GIL限制。</p>
<h2 id="执行过程">执行过程</h2>
<h3 id="编码规范">编码规范</h3>
<p>像<code>PEP8</code>一样，CPython也有自己的一套编码规范，为<a href="https://www.python.org/dev/peps/pep-0007/">PEP7</a>，有一些命名规范可以帮助我们更好的阅读源码:</p>
<ul>
<li>使用<code>Py</code>前缀的方法为公共方法，但不会用于静态方法。<code>Py_</code>前缀是为<code>Py_FatalError</code>这样的全局服务性函数保留的，对于特殊的类型(比如某类对象的API)会使用更长的前缀，例如<code>PyString_</code>都是字符串类的方法</li>
<li>公共函数和变量使用驼峰加上下划线，例如PyObject_GetAttr, Py_BuildValue, PyExc_TypeError等</li>
<li>偶尔有一些内部的函数，却需要对加载器可见，我们使用<code>_Py</code>前缀，例如_PyObject_Dump</li>
<li>宏使用驼峰前缀加大写，例如PyString_AS_STRING, Py_PRINT_RAW等</li>
</ul>
<h3 id="执行方式">执行方式</h3>
<p>Python的执行方式有五种:</p>
<ul>
<li>使用<code>python -c</code>执行单条语句</li>
<li>使用<code>python -m</code>执行某个模块</li>
<li>通常使用的运行某个文件</li>
<li>使用shell的管道连接，将<code>stdin</code>的内容作为python的输入</li>
<li>使用交互式命令行环境(REPL)</li>
</ul>
<p>通过这三个文件，我们能观察到一个整体的执行过程:</p>
<ol>
<li>Programs/python.c，一个简单的最初的程序入口</li>
<li>Modules/main.c，把整个执行过程的抽象打包再一起，包含加载环境信息、执行代码和清理内存</li>
<li>Python/initconfig.c，从系统中加载环境变量等信息，以及命令行中的参数等</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f92672">&lt;!--</span> cpython<span style="color:#f92672">/</span>Programs<span style="color:#f92672">/</span>python.c <span style="color:#f92672">--&gt;</span>
<span style="color:#66d9ef">int</span> main(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
{
    <span style="color:#75715e">// unix平台是_Py_UnixMain，windows平台是Py_Main
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> _Py_UnixMain(argc, argv);
}</code></pre></div>
<p>然后是选择执行模式:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f92672">&lt;!--</span> cpython<span style="color:#f92672">/</span>Modules<span style="color:#f92672">/</span>main.c <span style="color:#f92672">--&gt;</span>
<span style="color:#66d9ef">int</span> _Py_UnixMain(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
{
    <span style="color:#66d9ef">return</span> pymain_main(<span style="color:#f92672">&amp;</span>pymain);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> pymain_main(_PyMain <span style="color:#f92672">*</span>pymain)
{
    pymain_init(pymain);

    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> pymain_cmdline(pymain);
    <span style="color:#66d9ef">if</span> (res <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
        _Py_FatalInitError(pymain<span style="color:#f92672">-&gt;</span>err);
    }
    <span style="color:#66d9ef">if</span> (res <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">goto</span> done;
    }

    pymain_init_stdio(pymain);
    <span style="color:#75715e">// 初始化
</span><span style="color:#75715e"></span>    pymain<span style="color:#f92672">-&gt;</span>err <span style="color:#f92672">=</span> _Py_InitializeCore(<span style="color:#f92672">&amp;</span>pymain<span style="color:#f92672">-&gt;</span>config);

    <span style="color:#75715e">// 执行逻辑
</span><span style="color:#75715e"></span>    pymain_run_python(pymain);

    <span style="color:#66d9ef">if</span> (Py_FinalizeEx() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
        pymain<span style="color:#f92672">-&gt;</span>status <span style="color:#f92672">=</span> <span style="color:#ae81ff">120</span>;
    }

done:
    <span style="color:#75715e">// 退出清理
</span><span style="color:#75715e"></span>    pymain_free(pymain);

    <span style="color:#66d9ef">return</span> pymain<span style="color:#f92672">-&gt;</span>status;
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> pymain_run_python(_PyMain <span style="color:#f92672">*</span>pymain)
{
    PyCompilerFlags cf <span style="color:#f92672">=</span> {.cf_flags <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>};

    pymain_header(pymain);
    pymain_import_readline(pymain);

    <span style="color:#75715e">// 执行模式选择
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (pymain<span style="color:#f92672">-&gt;</span>command) {
        <span style="color:#75715e">// 命令行模式 -c
</span><span style="color:#75715e"></span>        pymain<span style="color:#f92672">-&gt;</span>status <span style="color:#f92672">=</span> pymain_run_command(pymain<span style="color:#f92672">-&gt;</span>command, <span style="color:#f92672">&amp;</span>cf);
    }
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (pymain<span style="color:#f92672">-&gt;</span>module) {
        <span style="color:#75715e">// 模块模式 -m
</span><span style="color:#75715e"></span>        pymain<span style="color:#f92672">-&gt;</span>status <span style="color:#f92672">=</span> (pymain_run_module(pymain<span style="color:#f92672">-&gt;</span>module, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);
    }
    <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// 入口文件模式
</span><span style="color:#75715e"></span>        pymain_run_filename(pymain, <span style="color:#f92672">&amp;</span>cf);
    }

    pymain_repl(pymain, <span style="color:#f92672">&amp;</span>cf);
}</code></pre></div></p>
<p>这个流程图能清晰的表达出上述代码:</p>
<p><img src="./images/exe_process.png" alt="" /></p>
<h3 id="建立运行时环境">建立运行时环境</h3>
<p>通过上图，我们可以看到无论执行任何python代码，运行时首先会建立相关环境。这个环境在<code>Include/cpython/initconfig.h</code>中定义为<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Include/cpython/initconfig.h#L407">PyConfig</a>，该结构体中的数据包括:</p>
<ul>
<li>运行模式的标记，比如debug或optimized模式</li>
<li>执行的模式，比如是以文件的方式、或者模块的方式、stdin的方式</li>
<li>通过<code>-X &lt;option&gt;</code>附加的拓展选项</li>
<li>运行时设置的环境变量</li>
</ul>
<p>这些值，我们也可以在运行时中查看到:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">[ubuntu] <span style="color:#f92672">/</span>tmp<span style="color:#f92672">/</span>missing<span style="color:#f92672">/</span>tt <span style="color:#960050;background-color:#1e0010">$</span> python3 <span style="color:#f92672">-</span>X dev <span style="color:#f92672">-</span>q <span style="color:#f92672">-</span>v
<span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">import</span> sys
<span style="color:#f92672">&gt;&gt;&gt;</span> sys<span style="color:#f92672">.</span>flags
sys<span style="color:#f92672">.</span>flags(debug<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, inspect<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, interactive<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, optimize<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, dont_write_bytecode<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, no_user_site<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, no_site<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, ignore_environment<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, verbose<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, bytes_warning<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, quiet<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, hash_randomization<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, isolated<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
<span style="color:#f92672">&gt;&gt;&gt;</span> sys<span style="color:#f92672">.</span>_xoptions
{<span style="color:#e6db74">&#39;dev&#39;</span>: True}</code></pre></div></p>
<h3 id="通过输入运行">通过输入运行</h3>
<h4 id="-c的方式">-c的方式</h4>
<p>例如<code>python -c &quot;print('hi')&quot;</code>，它的运行流程如图所示:</p>
<p><img src="./images/pymain_run_command.png" alt="pymain_run_command" /></p>
<p><a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Modules/main.c#L240">pymain_run_command()</a>的核心逻辑如下:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// 首个参数就是-c传递的指令
</span><span style="color:#75715e">// wchar_t*类型通常是CPython中用于存储Unicode数据的低级存储类型，因为该类型的大小也可以存储UTF8字符
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">pymain_run_command</span>(wchar_t <span style="color:#f92672">*</span>command, PyCompilerFlags <span style="color:#f92672">*</span>cf)
{
    PyObject <span style="color:#f92672">*</span>unicode, <span style="color:#f92672">*</span>bytes;

    <span style="color:#75715e">// 转换为PyUnicode对象
</span><span style="color:#75715e"></span>    unicode <span style="color:#f92672">=</span> PyUnicode_FromWideChar(command, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);

    <span style="color:#75715e">// 对unicode进行utf8编码得到一个python字节对象
</span><span style="color:#75715e"></span>    bytes <span style="color:#f92672">=</span> PyUnicode_AsUTF8String(unicode);

    <span style="color:#75715e">// 重新解码为字符串丢去执行
</span><span style="color:#75715e"></span>    ret <span style="color:#f92672">=</span> PyRun_SimpleStringFlags(PyBytes_AsString(bytes), cf);

    <span style="color:#66d9ef">return</span> (ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);
}</code></pre></div></p>
<p>而<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/pythonrun.c#L453">PyRun_SimpleStringFlags()</a>的目的是创建一个Python模块<code>__main__</code>，和一个字典，再将命令一起打包调用<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/pythonrun.c#L1008">PyRun_StringFlags()</a>，这个函数将创建一个假的文件名，接着就是调用Python解析器创建AST并返回模块mod了:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">PyRun_SimpleStringFlags</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>command, PyCompilerFlags <span style="color:#f92672">*</span>flags)
{
    PyObject <span style="color:#f92672">*</span>m, <span style="color:#f92672">*</span>d, <span style="color:#f92672">*</span>v;
    <span style="color:#75715e">// 建立入口模块
</span><span style="color:#75715e"></span>    m <span style="color:#f92672">=</span> PyImport_AddModule(<span style="color:#e6db74">&#34;__main__&#34;</span>);
    <span style="color:#75715e">// 创建字典，用于globals()和locals()
</span><span style="color:#75715e"></span>    d <span style="color:#f92672">=</span> PyModule_GetDict(m);
    v <span style="color:#f92672">=</span> PyRun_StringFlags(command, Py_file_input, d, d, flags);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

PyObject <span style="color:#f92672">*</span>
<span style="color:#a6e22e">PyRun_StringFlags</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str, <span style="color:#66d9ef">int</span> start, PyObject <span style="color:#f92672">*</span>globals,
                  PyObject <span style="color:#f92672">*</span>locals, PyCompilerFlags <span style="color:#f92672">*</span>flags)
{
...
    mod <span style="color:#f92672">=</span> PyParser_ASTFromStringObject(str, filename, start, flags, arena);
    ret <span style="color:#f92672">=</span> run_mod(mod, filename, globals, locals, flags, arena);
    PyArena_Free(arena);
    <span style="color:#66d9ef">return</span> ret;</code></pre></div></p>
<h4 id="-m的方式">-m的方式</h4>
<p>另一种执行Python命令的方式是-m选项和模块名称，例如<code>python -m unittest</code>可以运行标准库中的unittest模块。实际上它就是在sys.path中去搜索名为unittest的模块然后去执行。</p>
<p>CPython是先通过一个C的API函数<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/import.c#L1409">PyImport_ImportModule()</a>来导入标准库<code>runpy</code>，它返回的是一个PyObject核心对象类型，然后需要一些特殊的方法获取它的属性再调用。例如<code>hi.upper()</code>相当于<code>hi.upper.__call__()</code>，在C中<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Objects/object.c#L831">PyObject_GetAttrString()</a>就是用来获得hi的upper属性，然后通过<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Objects/call.c#L214">PyObject_Call()</a>就是去执行__call__()。</p>
<p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// modname就是通过-m传递进来的参数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">pymain_run_module</span>(<span style="color:#66d9ef">const</span> wchar_t <span style="color:#f92672">*</span>modname, <span style="color:#66d9ef">int</span> set_argv0)
{
    PyObject <span style="color:#f92672">*</span>module, <span style="color:#f92672">*</span>runpy, <span style="color:#f92672">*</span>runmodule, <span style="color:#f92672">*</span>runargs, <span style="color:#f92672">*</span>result;
    runpy <span style="color:#f92672">=</span> PyImport_ImportModule(<span style="color:#e6db74">&#34;runpy&#34;</span>);
 ...
    runmodule <span style="color:#f92672">=</span> PyObject_GetAttrString(runpy, <span style="color:#e6db74">&#34;_run_module_as_main&#34;</span>);
 ...
    module <span style="color:#f92672">=</span> PyUnicode_FromWideChar(modname, wcslen(modname));
 ...
    runargs <span style="color:#f92672">=</span> Py_BuildValue(<span style="color:#e6db74">&#34;(Oi)&#34;</span>, module, set_argv0);
 ...
    result <span style="color:#f92672">=</span> PyObject_Call(runmodule, runargs, NULL);
 ...
    <span style="color:#66d9ef">if</span> (result <span style="color:#f92672">==</span> NULL) {
        <span style="color:#66d9ef">return</span> pymain_exit_err_print();
    }
    Py_DECREF(result);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}</code></pre></div>
这段代码说明<code>python -m &lt;module&gt;</code>本质上是<code>python -m runpy &lt;module&gt;</code>，module只是参数，runpy对其进行了一层包装。runpy是用纯python写的位于<code>Lib/runpy.py</code>，它的目的是抽象在不同操作系统上定位和执行模块的过程，具体干这些事:</p>
<ul>
<li>调用用户提供的模块的<code>__import__()</code>方法</li>
<li>设置该模块的名字空间为<code>__main__</code></li>
<li>在<code>__main__</code>的名字空间下执行该模块</li>
</ul>
<p>runpy模块同样也可以用来执行某个目录或者zip文件。</p>
<h4 id="file模式">file模式</h4>
<p>如果是<code>python test.py</code>这种方式，CPython会打开一个文件句柄，然后传递给<code>Python/pythonrun.c</code>中的<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/pythonrun.c#L372">PyRun_SimpleFileExFlags()</a>方法:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">PyRun_SimpleFileExFlags</span>(FILE <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>filename, <span style="color:#66d9ef">int</span> closeit,
                        PyCompilerFlags <span style="color:#f92672">*</span>flags)
{
 ...
    m <span style="color:#f92672">=</span> PyImport_AddModule(<span style="color:#e6db74">&#34;__main__&#34;</span>);
 ...
    <span style="color:#75715e">// 如果是pyc文件，则调用run_pyc_file()
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (maybe_pyc_file(fp, filename, ext, closeit)) {
 ...
        v <span style="color:#f92672">=</span> run_pyc_file(pyc_fp, filename, d, d, flags);
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// .py和stdin模式都运行PyRun_FileExFlags()
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (strcmp(filename, <span style="color:#e6db74">&#34;&lt;stdin&gt;&#34;</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span>
            set_main_loader(d, filename, <span style="color:#e6db74">&#34;SourceFileLoader&#34;</span>) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
            fprintf(stderr, <span style="color:#e6db74">&#34;python: failed to set __main__.__loader__</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
            ret <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">goto</span> done;
        }
        v <span style="color:#f92672">=</span> PyRun_FileExFlags(fp, filename, Py_file_input, d, d,
                              closeit, flags);
    }
 ...
    <span style="color:#66d9ef">return</span> ret;
}</code></pre></div></p>
<p>而<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/pythonrun.c#L1032">PyRun_FileExFlags()</a>和前文介绍的通过-c输入的PyRun_SimpleStringFlags()作用类似，都是去创建AST返回mod然后运行mod:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">PyObject <span style="color:#f92672">*</span>
<span style="color:#a6e22e">PyRun_FileExFlags</span>(FILE <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>filename_str, <span style="color:#66d9ef">int</span> start, PyObject <span style="color:#f92672">*</span>globals,
                  PyObject <span style="color:#f92672">*</span>locals, <span style="color:#66d9ef">int</span> closeit, PyCompilerFlags <span style="color:#f92672">*</span>flags)
{
 ...
    mod <span style="color:#f92672">=</span> PyParser_ASTFromFileObject(fp, filename, NULL, start, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>,
                                     flags, NULL, arena);
 ...
    ret <span style="color:#f92672">=</span> run_mod(mod, filename, globals, locals, flags, arena);
}</code></pre></div></p>
<p><a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/pythonrun.c#L1125">run_mod()</a>负责把模块发送给AST编译为一个代码对象，即文章开头提到过的存储字节码以及保存在.pyc文件中的对象:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> PyObject <span style="color:#f92672">*</span>
<span style="color:#a6e22e">run_mod</span>(mod_ty mod, PyObject <span style="color:#f92672">*</span>filename, PyObject <span style="color:#f92672">*</span>globals, PyObject <span style="color:#f92672">*</span>locals,
            PyCompilerFlags <span style="color:#f92672">*</span>flags, PyArena <span style="color:#f92672">*</span>arena)
{
    PyCodeObject <span style="color:#f92672">*</span>co;
    PyObject <span style="color:#f92672">*</span>v;
    co <span style="color:#f92672">=</span> PyAST_CompileObject(mod, filename, flags, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, arena);
    v <span style="color:#f92672">=</span> run_eval_code_obj(co, globals, locals);
    <span style="color:#66d9ef">return</span> v;
}</code></pre></div>
之后的run_eval_code_obj()就属于执行逻辑了，后文中再描述。</p>
<p><a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/pythonrun.c#L1145">run_pyc_file()</a>可以理解为省略了创建AST的过程，而是通过marshal把pyc文件中的内容复制到内存并将其转换为特定的数据结构。硬盘上的pyc文件就是CPython编译器缓存已编译代码的方式，因此无需每次调用脚本时再编译一次:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> PyObject <span style="color:#f92672">*</span>
<span style="color:#a6e22e">run_pyc_file</span>(FILE <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>filename, PyObject <span style="color:#f92672">*</span>globals,
             PyObject <span style="color:#f92672">*</span>locals, PyCompilerFlags <span style="color:#f92672">*</span>flags)
{
    PyCodeObject <span style="color:#f92672">*</span>co;
    PyObject <span style="color:#f92672">*</span>v;
  ...
    v <span style="color:#f92672">=</span> PyMarshal_ReadLastObjectFromFile(fp);
  ...
    co <span style="color:#f92672">=</span> (PyCodeObject <span style="color:#f92672">*</span>)v;
    v <span style="color:#f92672">=</span> run_eval_code_obj(co, globals, locals);
    <span style="color:#66d9ef">return</span> v;
}</code></pre></div></p>
<h3 id="语义解析">语义解析</h3>
<p>在前文中我们了解到在执行时会先去创建AST，那么这步具体是怎么做的呢:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">mod_ty
<span style="color:#a6e22e">PyParser_ASTFromFileObject</span>(FILE <span style="color:#f92672">*</span>fp, PyObject <span style="color:#f92672">*</span>filename, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> enc,
                           <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ps1,
                           <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ps2, PyCompilerFlags <span style="color:#f92672">*</span>flags, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>errcode,
                           PyArena <span style="color:#f92672">*</span>arena)
{
    ...
    node <span style="color:#f92672">*</span>n <span style="color:#f92672">=</span> PyParser_ParseFileObject(fp, filename, enc,
                                       <span style="color:#f92672">&amp;</span>_PyParser_Grammar,
                                       start, ps1, ps2, <span style="color:#f92672">&amp;</span>err, <span style="color:#f92672">&amp;</span>iflags);
    ...
    <span style="color:#66d9ef">if</span> (n) {
        flags<span style="color:#f92672">-&gt;</span>cf_flags <span style="color:#f92672">|=</span> iflags <span style="color:#f92672">&amp;</span> PyCF_MASK;
        mod <span style="color:#f92672">=</span> PyAST_FromNodeObject(n, flags, filename, arena);
        PyNode_Free(n);
    ...
    <span style="color:#66d9ef">return</span> mod;
}</code></pre></div>
在<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/ast.c#L772">PyParser_ASTFromFileObject()</a>方法中，会将文件句柄、编译器标志、以及内存块对象打包给<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Parser/parsetok.c#L163">PyParser_ParseFileObject()</a>转换为一个node对象:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">node <span style="color:#f92672">*</span>
<span style="color:#a6e22e">PyParser_ParseFileObject</span>(FILE <span style="color:#f92672">*</span>fp, PyObject <span style="color:#f92672">*</span>filename,
                         <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>enc, grammar <span style="color:#f92672">*</span>g, <span style="color:#66d9ef">int</span> start,
                         <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ps1, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ps2,
                         perrdetail <span style="color:#f92672">*</span>err_ret, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>flags)
{
    <span style="color:#66d9ef">struct</span> tok_state <span style="color:#f92672">*</span>tok;
...
    <span style="color:#66d9ef">if</span> ((tok <span style="color:#f92672">=</span> PyTokenizer_FromFile(fp, enc, ps1, ps2)) <span style="color:#f92672">==</span> NULL) {
        err_ret<span style="color:#f92672">-&gt;</span>error <span style="color:#f92672">=</span> E_NOMEM;
        <span style="color:#66d9ef">return</span> NULL;
    }
...
    <span style="color:#66d9ef">return</span> parsetok(tok, g, start, err_ret, flags);
}</code></pre></div>
该方法把两项重要的任务组合了起来，一是使用<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Parser/tokenizer.h#L78">PyTokenizer_FromFile()</a>实例化一个tok_state，tok_state也只是一个数据结构(容器)，存储由tokenizer生成的临时数据；二是使用<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Parser/parsetok.c#L232">parsetok()</a>将token转换为一个具体的解析树(节点列表)。</p>
<p>在parsetok()中，将循环调用<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Parser/tokenizer.c#L1110">tok_get()</a>方法，该方法像是一个迭代器，不断获取解析树的下一个token，parsetok()在根据不同token设置tok_state中相关的值。它也是CPython中最复杂的方法之一，因为要兼容各种各样的边缘情况、数十年的历史原因、新的语言特性等等原因。我们来看其中一种简单的解析，如何把每行结尾变为token<code>NEWLINE</code>的:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">tok_get</span>(<span style="color:#66d9ef">struct</span> tok_state <span style="color:#f92672">*</span>tok, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>p_start, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>p_end)
{
...
    <span style="color:#75715e">/* Newline */</span>
    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\n&#39;</span>) {
        tok<span style="color:#f92672">-&gt;</span>atbol <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (blankline <span style="color:#f92672">||</span> tok<span style="color:#f92672">-&gt;</span>level <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
            <span style="color:#66d9ef">goto</span> nextline;
        }
        <span style="color:#f92672">*</span>p_start <span style="color:#f92672">=</span> tok<span style="color:#f92672">-&gt;</span>start;
        <span style="color:#f92672">*</span>p_end <span style="color:#f92672">=</span> tok<span style="color:#f92672">-&gt;</span>cur <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">/* Leave &#39;\n&#39; out of the string */</span>
        tok<span style="color:#f92672">-&gt;</span>cont_line <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">if</span> (tok<span style="color:#f92672">-&gt;</span>async_def) {
            <span style="color:#75715e">/* We&#39;re somewhere inside an &#39;async def&#39; function, and
</span><span style="color:#75715e">               we&#39;ve encountered a NEWLINE after its signature. */</span>
            tok<span style="color:#f92672">-&gt;</span>async_def_nl <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        }
        <span style="color:#66d9ef">return</span> NEWLINE;
    }
...
}</code></pre></div>
parsetok()返回的是一个node节点类型:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _node {
    <span style="color:#66d9ef">short</span>               n_type;
    <span style="color:#66d9ef">char</span>                <span style="color:#f92672">*</span>n_str;
    <span style="color:#66d9ef">int</span>                 n_lineno;
    <span style="color:#66d9ef">int</span>                 n_col_offset;
    <span style="color:#66d9ef">int</span>                 n_nchildren;
    <span style="color:#66d9ef">struct</span> _node        <span style="color:#f92672">*</span>n_child;
    <span style="color:#66d9ef">int</span>                 n_end_lineno;
    <span style="color:#66d9ef">int</span>                 n_end_col_offset;
} node;</code></pre></div>
这些个节点组成的树我们叫CST，每个节点包含了语法、tokenID、符号，但这个树不能用于编译器做出快速决策，编译器需要更高一级抽象即AST，我们可以通过内部的API观察到CST的输出结果:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> symbol
<span style="color:#f92672">import</span> token
<span style="color:#f92672">import</span> parser

<span style="color:#75715e"># 为了输出结果的可读性，做了一层处理</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lex</span>(expression):
    symbols <span style="color:#f92672">=</span> {v: k <span style="color:#66d9ef">for</span> k, v <span style="color:#f92672">in</span> symbol<span style="color:#f92672">.</span>__dict__<span style="color:#f92672">.</span>items() <span style="color:#66d9ef">if</span> isinstance(v, int)}
    tokens <span style="color:#f92672">=</span> {v: k <span style="color:#66d9ef">for</span> k, v <span style="color:#f92672">in</span> token<span style="color:#f92672">.</span>__dict__<span style="color:#f92672">.</span>items() <span style="color:#66d9ef">if</span> isinstance(v, int)}
    lexicon <span style="color:#f92672">=</span> {<span style="color:#f92672">**</span>symbols, <span style="color:#f92672">**</span>tokens}
    st <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span>expr(expression)
    st_list <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span>st2list(st)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">replace</span>(l: list):
        r <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> l:
            <span style="color:#66d9ef">if</span> isinstance(i, list):
                r<span style="color:#f92672">.</span>append(replace(i))
            <span style="color:#66d9ef">else</span>:
                <span style="color:#66d9ef">if</span> i <span style="color:#f92672">in</span> lexicon:
                    r<span style="color:#f92672">.</span>append(lexicon[i])
                <span style="color:#66d9ef">else</span>:
                    r<span style="color:#f92672">.</span>append(i)
        <span style="color:#66d9ef">return</span> r

    <span style="color:#66d9ef">return</span> replace(st_list)

<span style="color:#75715e"># 小写的就是符号，大写的就是token</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> pprint(lex(<span style="color:#e6db74">&#39;a + 1&#39;</span>))
[<span style="color:#e6db74">&#39;eval_input&#39;</span>,
 [<span style="color:#e6db74">&#39;testlist&#39;</span>,
  [<span style="color:#e6db74">&#39;test&#39;</span>,
   [<span style="color:#e6db74">&#39;or_test&#39;</span>,
    [<span style="color:#e6db74">&#39;and_test&#39;</span>,
     [<span style="color:#e6db74">&#39;not_test&#39;</span>,
      [<span style="color:#e6db74">&#39;comparison&#39;</span>,
       [<span style="color:#e6db74">&#39;expr&#39;</span>,
        [<span style="color:#e6db74">&#39;xor_expr&#39;</span>,
         [<span style="color:#e6db74">&#39;and_expr&#39;</span>,
          [<span style="color:#e6db74">&#39;shift_expr&#39;</span>,
           [<span style="color:#e6db74">&#39;arith_expr&#39;</span>,
            [<span style="color:#e6db74">&#39;term&#39;</span>,
             [<span style="color:#e6db74">&#39;factor&#39;</span>, [<span style="color:#e6db74">&#39;power&#39;</span>, [<span style="color:#e6db74">&#39;atom_expr&#39;</span>, [<span style="color:#e6db74">&#39;atom&#39;</span>, [<span style="color:#e6db74">&#39;NAME&#39;</span>, <span style="color:#e6db74">&#39;a&#39;</span>]]]]]],
            [<span style="color:#e6db74">&#39;PLUS&#39;</span>, <span style="color:#e6db74">&#39;+&#39;</span>],
            [<span style="color:#e6db74">&#39;term&#39;</span>,
             [<span style="color:#e6db74">&#39;factor&#39;</span>,
              [<span style="color:#e6db74">&#39;power&#39;</span>, [<span style="color:#e6db74">&#39;atom_expr&#39;</span>, [<span style="color:#e6db74">&#39;atom&#39;</span>, [<span style="color:#e6db74">&#39;NUMBER&#39;</span>, <span style="color:#e6db74">&#39;1&#39;</span>]]]]]]]]]]]]]]]]],
 [<span style="color:#e6db74">&#39;NEWLINE&#39;</span>, <span style="color:#e6db74">&#39;&#39;</span>],
 [<span style="color:#e6db74">&#39;ENDMARKER&#39;</span>, <span style="color:#e6db74">&#39;&#39;</span>]]</code></pre></div></p>
<h3 id="ast">AST</h3>
<p>CPython的下一个阶段就是将CST转换为能够执行的、更有逻辑的东西，也就是AST(Abstract Syntax Trees，抽象语法树)。虽然这一步是解释器内联生成，我们也有其他办法能方便的观察到，例如使用<code>instaviz</code>库，它能在一个网页中展示AST以及每个节点的属性:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">import</span> instaviz
<span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">example</span>():
       a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
       b <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
       <span style="color:#66d9ef">return</span> b
<span style="color:#f92672">&gt;&gt;&gt;</span> instaviz<span style="color:#f92672">.</span>show(example)</code></pre></div>
我们能看到这样的界面:
<img src="./images/instaviz_web.png" alt="instaviz_web" /></p>
<p>然后可以点击AST中的节点:
<img src="./images/instaviz_node.png" alt="instaviz_node" />
例如如果点击图中的Assign节点，它代表的是<code>b=a+1</code>这一行，右侧会展示出这个节点的属性，它有两个属性，一个是targets，代表变量名称，它有时可能是一个列表，因为解包操作就会有多个变量；另一个是value，代表变量的值，在这里就是<code>a+1</code>这个表达式。如果我们再点击BinOp节点，就可以看到它的3个属性，left表示运算符左边是什么，op表示运算符，right表示运算符右边。</p>
<p>用C语言编译AST并不是一件容易的事，所以实际上真正的编译模块有5000行代码，在<code>Python/ast.c</code>中。</p>
<p>具体到核心代码流程来说，之前通过PyParser_ParseFileObject()得到的CST对象node，接着传入<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/ast.c#L772">PyAST_FromNodeObject()</a>，并附带文件名、编译flag和PyArena。得到函数返回的mod_ty，是一个容器结构，属于Python5种模块类型之一:Module、Interactive、Expression、FunctionType、Suite。在<code>Include/Python-ast.h</code>中能看到每种类型需要的字段:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">enum</span> _mod_kind {Module_kind<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, Interactive_kind<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, Expression_kind<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>,
                 FunctionType_kind<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>, Suite_kind<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>};
<span style="color:#66d9ef">struct</span> _mod {
    <span style="color:#66d9ef">enum</span> _mod_kind kind;
    <span style="color:#66d9ef">union</span> {
        <span style="color:#66d9ef">struct</span> {
            asdl_seq <span style="color:#f92672">*</span>body;
            asdl_seq <span style="color:#f92672">*</span>type_ignores;
        } Module;

        <span style="color:#66d9ef">struct</span> {
            asdl_seq <span style="color:#f92672">*</span>body;
        } Interactive;

        <span style="color:#66d9ef">struct</span> {
            expr_ty body;
        } Expression;

        <span style="color:#66d9ef">struct</span> {
            asdl_seq <span style="color:#f92672">*</span>argtypes;
            expr_ty returns;
        } FunctionType;

        <span style="color:#66d9ef">struct</span> {
            asdl_seq <span style="color:#f92672">*</span>body;
        } Suite;

    } v;
};</code></pre></div>
除了模块类型，其他的AST类型都列在<code>Parser/Python.asdl</code>中，包括statement、expression、operators、comprehensions等等。在该文件中我们能看到类型字段的定义也是用在这里的:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f92672">--</span> ASDL<span style="color:#960050;background-color:#1e0010">&#39;</span>s <span style="color:#ae81ff">5</span> builtin types are:
<span style="color:#f92672">--</span> identifier, <span style="color:#66d9ef">int</span>, string, object, constant

module Python
{
    mod <span style="color:#f92672">=</span> Module(stmt<span style="color:#f92672">*</span> body, type_ignore <span style="color:#f92672">*</span>type_ignores)
        <span style="color:#f92672">|</span> Interactive(stmt<span style="color:#f92672">*</span> body)
        <span style="color:#f92672">|</span> Expression(expr body)
        <span style="color:#f92672">|</span> FunctionType(expr<span style="color:#f92672">*</span> argtypes, expr returns)</code></pre></div></p>
<p>接着，PyAST_FromNodeObject()使用TYPE(n)确定首个CST节点的类型来执行不同的逻辑，如果是文件输入，返回的结果就是Module，eval_input就是Expression，总之是Module, Interactive, Expression, FunctionType中的一种:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">mod_ty
<span style="color:#a6e22e">PyAST_FromNodeObject</span>(<span style="color:#66d9ef">const</span> node <span style="color:#f92672">*</span>n, PyCompilerFlags <span style="color:#f92672">*</span>flags,
                     PyObject <span style="color:#f92672">*</span>filename, PyArena <span style="color:#f92672">*</span>arena)
{
    ...
    <span style="color:#66d9ef">switch</span> (TYPE(n)) {
        <span style="color:#66d9ef">case</span> file_input:
            stmts <span style="color:#f92672">=</span> _Py_asdl_seq_new(num_stmts(n), arena);
            <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NCH(n) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
                ch <span style="color:#f92672">=</span> CHILD(n, i);
                <span style="color:#66d9ef">if</span> (TYPE(ch) <span style="color:#f92672">==</span> NEWLINE)
                    <span style="color:#66d9ef">continue</span>;
                num <span style="color:#f92672">=</span> num_stmts(ch);
                <span style="color:#66d9ef">if</span> (num <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
                    s <span style="color:#f92672">=</span> ast_for_stmt(<span style="color:#f92672">&amp;</span>c, ch);
                }
                <span style="color:#66d9ef">else</span> {
                    ch <span style="color:#f92672">=</span> CHILD(ch, <span style="color:#ae81ff">0</span>);
                    REQ(ch, simple_stmt);
                    <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> num; j<span style="color:#f92672">++</span>) {
                        s <span style="color:#f92672">=</span> ast_for_stmt(<span style="color:#f92672">&amp;</span>c, CHILD(ch, j <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>));
                    }
                }
            }
            <span style="color:#75715e">/* Type ignores are stored under the ENDMARKER in file_input. */</span>
            ...
            res <span style="color:#f92672">=</span> Module(stmts, type_ignores, arena);
            <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">case</span> eval_input: {
            expr_ty testlist_ast;
            testlist_ast <span style="color:#f92672">=</span> ast_for_testlist(<span style="color:#f92672">&amp;</span>c, CHILD(n, <span style="color:#ae81ff">0</span>));
            res <span style="color:#f92672">=</span> Expression(testlist_ast, arena);
            <span style="color:#66d9ef">break</span>;
        }
        <span style="color:#66d9ef">case</span> single_input:
            ...
            <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">case</span> func_type_input:
            ...
        ...
    <span style="color:#66d9ef">return</span> res;
}</code></pre></div></p>
<p>遍历孩子节点并创建相应的AST语句节点逻辑在<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/ast.c#L4512">ast_for_stmt()</a>中，该函数内还需要再根据不同的语句类型调用不同的函数创建节点，都是类似于ast_for_*()，例如<code>2**4</code>这样的语句最终能找到ast_for_power()这样的方法。</p>
<h3 id="编译">编译</h3>
<p>现在解释器有了AST，也就有了每个操作、函数、类和名字空间所需要的属性，下一步就是把AST编译为CPU能够理解的东西，这就是编译。编译可以分为两个部分:一是遍历树并创建一个控制流图(control-flow-graph)，用来表示逻辑执行的顺序；另外就是将控制流图中的节点转换为较小的可执行语句，称为字节码。</p>
<p><a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/compile.c#L312">PyAST_CompileObject()</a>函数是编译器部分的主要入口，它以Python模块作为主要参数，同解释器进程早期创建过的文件名称、全局变量、局部变量以及PyArena一起打包传入。然后先创建一个全局的编译器状态结构体，用来存储一些属性、编译标识、栈等等:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f92672">&lt;!--</span> cpython<span style="color:#f92672">/</span>Python<span style="color:#f92672">/</span>compile.c <span style="color:#f92672">--&gt;</span>
<span style="color:#66d9ef">struct</span> compiler {
    PyObject <span style="color:#f92672">*</span>c_filename;
    <span style="color:#66d9ef">struct</span> symtable <span style="color:#f92672">*</span>c_st;
    PyFutureFeatures <span style="color:#f92672">*</span>c_future; <span style="color:#75715e">/* pointer to module&#39;s __future__ */</span>
    PyCompilerFlags <span style="color:#f92672">*</span>c_flags;
    <span style="color:#66d9ef">int</span> c_optimize;              <span style="color:#75715e">/* optimization level */</span>
    <span style="color:#66d9ef">int</span> c_interactive;           <span style="color:#75715e">/* true if in interactive mode */</span>
    <span style="color:#66d9ef">int</span> c_nestlevel;
    <span style="color:#66d9ef">int</span> c_do_not_emit_bytecode;  
    PyObject <span style="color:#f92672">*</span>c_const_cache;     <span style="color:#75715e">/* Python dict holding all constants, including names tuple */</span>
    <span style="color:#66d9ef">struct</span> compiler_unit <span style="color:#f92672">*</span>u; <span style="color:#75715e">/* compiler state for current block */</span>
    PyObject <span style="color:#f92672">*</span>c_stack;           <span style="color:#75715e">/* Python list holding compiler_unit ptrs */</span>
    PyArena <span style="color:#f92672">*</span>c_arena;            <span style="color:#75715e">/* pointer to memory allocation arena */</span>
};</code></pre></div>
接着有11个主要步骤:</p>
<ol>
<li>如果模块不存在<code>__doc__</code>则创建一个新的</li>
<li>如果模块不存在<code>__annotations__</code>则创建一个新的</li>
<li>设置全局编译器状态中的文件名为传入的文件名</li>
<li>将编译器的内存区域设置为解释器使用的那个</li>
<li>将模块中所有的<code>__future__</code>标识复制至全局编译器状态中</li>
<li>合并命令行或环境变量中提供的运行时标识</li>
<li>启用编译器中所有的<code>__future__</code></li>
<li>设置编译的优化级别为参数提供的，或者是默认的</li>
<li>根据模块对象构建符号表</li>
<li>运行编译器，返回代码对象</li>
<li>编译器释放编译过程中所分配的所有内存</li>
</ol>
<p>核心代码:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">PyCodeObject <span style="color:#f92672">*</span>
<span style="color:#a6e22e">PyAST_CompileObject</span>(mod_ty mod, PyObject <span style="color:#f92672">*</span>filename, PyCompilerFlags <span style="color:#f92672">*</span>flags,
                   <span style="color:#66d9ef">int</span> optimize, PyArena <span style="color:#f92672">*</span>arena)
{
    <span style="color:#66d9ef">struct</span> compiler c;
    PyCodeObject <span style="color:#f92672">*</span>co <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>__doc__) {
        __doc__ <span style="color:#f92672">=</span> PyUnicode_InternFromString(<span style="color:#e6db74">&#34;__doc__&#34;</span>);
    }
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>__annotations__) {
        __annotations__ <span style="color:#f92672">=</span> PyUnicode_InternFromString(<span style="color:#e6db74">&#34;__annotations__&#34;</span>);
    }
    c.c_filename <span style="color:#f92672">=</span> filename;
    c.c_arena <span style="color:#f92672">=</span> arena;
    c.c_future <span style="color:#f92672">=</span> PyFuture_FromASTObject(mod, filename);
    merged <span style="color:#f92672">=</span> c.c_future<span style="color:#f92672">-&gt;</span>ff_features <span style="color:#f92672">|</span> flags<span style="color:#f92672">-&gt;</span>cf_flags;
    c.c_future<span style="color:#f92672">-&gt;</span>ff_features <span style="color:#f92672">=</span> merged;
    flags<span style="color:#f92672">-&gt;</span>cf_flags <span style="color:#f92672">=</span> merged;
    c.c_flags <span style="color:#f92672">=</span> flags;
    c.c_optimize <span style="color:#f92672">=</span> (optimize <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">?</span> config<span style="color:#f92672">-&gt;</span>optimization_level : optimize;
    c.c_nestlevel <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    c.c_do_not_emit_bytecode <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    co <span style="color:#f92672">=</span> compiler_mod(<span style="color:#f92672">&amp;</span>c, mod);
 finally:
    compiler_free(<span style="color:#f92672">&amp;</span>c);
    <span style="color:#66d9ef">return</span> co;
}</code></pre></div></p>
<h4 id="future标识和编译标识">Future标识和编译标识</h4>
<p>编译器运行前，有两种标识可以切换编译器内部的功能。</p>
<p>第一种是通过命令行或环境变量设置的解释器状态，例如命令行执行时添加<code>-O</code>标志(也可以通过设置环境变量PYTHONOPTIMIZE=1达到同样效果)，则所有的断言语句都会被编译器忽略掉，这些断言语句往往是调试时才需要。</p>
<p>另一种是实际的源代码中加入future语句，例如<code>from __future__ import annotations</code>，它是Python3.7新加入的，因为使用type hints时可能类型还没有被创建，该语句可以让类型注解延迟求值。</p>
<h4 id="符号表">符号表</h4>
<p>符号表为编译器提供了一个查找引用全局变量、局部变量等的作用域，它的结构是这样的:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> symtable {
    PyObject <span style="color:#f92672">*</span>st_filename;          <span style="color:#75715e">/* name of file being compiled, decoded from the filesystem encoding */</span>
    <span style="color:#66d9ef">struct</span> _symtable_entry <span style="color:#f92672">*</span>st_cur; <span style="color:#75715e">/* current symbol table entry */</span>
    <span style="color:#66d9ef">struct</span> _symtable_entry <span style="color:#f92672">*</span>st_top; <span style="color:#75715e">/* symbol table entry for module */</span>
    PyObject <span style="color:#f92672">*</span>st_blocks;            <span style="color:#75715e">/* dict: map AST node addresses to symbol table entries */</span>
    PyObject <span style="color:#f92672">*</span>st_stack;             <span style="color:#75715e">/* list: stack of namespace info */</span>
    PyObject <span style="color:#f92672">*</span>st_global;            <span style="color:#75715e">/* borrowed ref to st_top-&gt;ste_symbols */</span>
    <span style="color:#66d9ef">int</span> st_nblocks;                 <span style="color:#75715e">/* number of blocks used. kept for consistency with the corresponding compiler structure */</span>
    PyObject <span style="color:#f92672">*</span>st_private;           <span style="color:#75715e">/* name of current class or NULL */</span>
    PyFutureFeatures <span style="color:#f92672">*</span>st_future;    <span style="color:#75715e">/* module&#39;s future features that affect the symbol table */</span>
    <span style="color:#66d9ef">int</span> recursion_depth;            <span style="color:#75715e">/* current recursion depth */</span>
    <span style="color:#66d9ef">int</span> recursion_limit;            <span style="color:#75715e">/* recursion limit */</span>
};</code></pre></div>
其中的一些API通过Python的标准库symtable模块可以调用:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">import</span> symtable
<span style="color:#f92672">&gt;&gt;&gt;</span> s <span style="color:#f92672">=</span> symtable<span style="color:#f92672">.</span>symtable(<span style="color:#e6db74">&#39;b + 1&#39;</span>, filename<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;test.py&#39;</span>, compile_type<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;eval&#39;</span>)
<span style="color:#f92672">&gt;&gt;&gt;</span> [symbol<span style="color:#f92672">.</span>__dict__ <span style="color:#66d9ef">for</span> symbol <span style="color:#f92672">in</span> s<span style="color:#f92672">.</span>get_symbols()]
[{<span style="color:#e6db74">&#39;_Symbol__name&#39;</span>: <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;_Symbol__flags&#39;</span>: <span style="color:#ae81ff">6160</span>, <span style="color:#e6db74">&#39;_Symbol__scope&#39;</span>: <span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;_Symbol__namespaces&#39;</span>: ()}]</code></pre></div>
核心的C代码在<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/symtable.c#L262">PySymtable_BuildObject()</a>函数中，它也是依据传入的mod_ty类型的不同使用不同的访问函数，有<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/symtable.c#L1176">symtable_visit_stmt()</a>、symtable_visit_expr()等，这些访问函数里面也是一个巨长的switch语句对应着定义在Parser/Python.asdl中的每种语句类型以及各自的逻辑。例如对于一个函数定义，它需要做的特殊处理有:检测递归深度超过限制则引发异常、将函数名称加入到局部变量中、解析顺序参数和关键字参数的默认值、解析参数和返回值的类型注释、解析函数的装饰器等等。</p>
<h4 id="核心编译过程">核心编译过程</h4>
<p>现在PyAST_CompileObject()有了一个编译器状态、一个符号表、一个模块形式的AST，真正的编译才开始。这个阶段的目标是将state、symtable、AST转化为CFG，以及捕获逻辑和代码异常并抛出。</p>
<p>我们可以通过Python提供的内置函数compile()完成编译过程，传入的是表达式则mode选择eval，传入类、方法、模块等mode要选择exec，它返回的是一个代码对象:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">In [<span style="color:#ae81ff">1</span>]: compile(<span style="color:#e6db74">&#34;a+1&#34;</span>, <span style="color:#e6db74">&#34;a.py&#34;</span>, mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;eval&#34;</span>)                     
Out[<span style="color:#ae81ff">1</span>]: <span style="color:#f92672">&lt;</span>code object <span style="color:#f92672">&lt;</span>module<span style="color:#f92672">&gt;</span> at <span style="color:#ae81ff">0x1120e58a0</span>, file <span style="color:#e6db74">&#34;a.py&#34;</span>, line <span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>
In [<span style="color:#ae81ff">2</span>]: _<span style="color:#f92672">.</span>co_code                      
Out[<span style="color:#ae81ff">2</span>]: <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;e</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">d</span><span style="color:#ae81ff">\x00\x17\x00</span><span style="color:#e6db74">S</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;</span></code></pre></div></p>
<p>怎样得到这个代码对象的，实际就是<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/compile.c#L1782">compiler_mod()</a>:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> PyCodeObject <span style="color:#f92672">*</span>
<span style="color:#a6e22e">compiler_mod</span>(<span style="color:#66d9ef">struct</span> compiler <span style="color:#f92672">*</span>c, mod_ty mod)
{
    PyCodeObject <span style="color:#f92672">*</span>co;
    ...
    <span style="color:#66d9ef">switch</span> (mod<span style="color:#f92672">-&gt;</span>kind) {
    <span style="color:#66d9ef">case</span> Module_kind:
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>compiler_body(c, mod<span style="color:#f92672">-&gt;</span>v.Module.body)) {
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
        }
        <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> Interactive_kind:
        ...
    <span style="color:#66d9ef">case</span> Expression_kind:
        ...
    <span style="color:#66d9ef">case</span> Suite_kind:
        ...
    ...
    co <span style="color:#f92672">=</span> assemble(c, addNone);
    <span style="color:#66d9ef">return</span> co;
}</code></pre></div></p>
<p><a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/compile.c#L1743">compiler_body()</a>循环访问模块中的每条语句，和symtable的工作方式类似:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">compiler_body</span>(<span style="color:#66d9ef">struct</span> compiler <span style="color:#f92672">*</span>c, asdl_seq <span style="color:#f92672">*</span>stmts)
{
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    stmt_ty st;
    PyObject <span style="color:#f92672">*</span>docstring;
    ...
    <span style="color:#66d9ef">for</span> (; i <span style="color:#f92672">&lt;</span> asdl_seq_LEN(stmts); i<span style="color:#f92672">++</span>)
        VISIT(c, stmt, (stmt_ty)asdl_seq_GET(stmts, i));
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
}</code></pre></div>
<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Include/asdl.h#L32">asdl_seq_GET()</a>查看每个AST节点的类型得到语句的类型，然后通过宏，VISIT调用compiler_visit_*函数:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define VISIT(C, TYPE, V) {\
</span><span style="color:#75715e">    if (!compiler_visit_ ## TYPE((C), (V))) \
</span><span style="color:#75715e">        return 0; \
</span><span style="color:#75715e">}</span></code></pre></div>
对于语句类型来说，就是到<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/compile.c#L3310">compiler_visit_stmt()</a>函数，然后具体每条语句也有自己的编译函数:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">compiler_visit_stmt</span>(<span style="color:#66d9ef">struct</span> compiler <span style="color:#f92672">*</span>c, stmt_ty s)
{
    Py_ssize_t i, n;

    <span style="color:#75715e">/* Always assign a lineno to the next instruction for a stmt. */</span>
    c<span style="color:#f92672">-&gt;</span>u<span style="color:#f92672">-&gt;</span>u_lineno <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>lineno;
    c<span style="color:#f92672">-&gt;</span>u<span style="color:#f92672">-&gt;</span>u_col_offset <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>col_offset;
    c<span style="color:#f92672">-&gt;</span>u<span style="color:#f92672">-&gt;</span>u_lineno_set <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">switch</span> (s<span style="color:#f92672">-&gt;</span>kind) {
    <span style="color:#66d9ef">case</span> FunctionDef_kind:
        <span style="color:#66d9ef">return</span> compiler_function(c, s, <span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">case</span> ClassDef_kind:
        <span style="color:#66d9ef">return</span> compiler_class(c, s);
    ...
    <span style="color:#66d9ef">case</span> For_kind:
        <span style="color:#66d9ef">return</span> compiler_for(c, s);
    ...
    }

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
}</code></pre></div></p>
<p>我们以for语句为例:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> iterable:
    <span style="color:#75715e"># block</span>
<span style="color:#66d9ef">else</span>:  <span style="color:#75715e"># optional if iterable is False</span>
    <span style="color:#75715e"># block</span></code></pre></div>
对于一个For类型的语句，它会调用compiler_for()。所有的语句和表达式类型都有相应的compiler_*()函数，大多数类型直接在其中创建字节码，也有些比较复杂的语句类型还会调用其他函数。许多语句都可能会有子句，for循环在赋值和迭代时也可能遇到复杂的表达式。</p>
<h3 id="终止">终止</h3>
<p>执行完之后，结束之前还要进行一系列的清理操作。
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f92672">&lt;!--</span> cpython<span style="color:#f92672">/</span>Python<span style="color:#f92672">/</span>pylifecycle.c <span style="color:#f92672">--&gt;</span>
<span style="color:#66d9ef">int</span> Py_FinalizeEx(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#75715e">// 等待前台线程结束
</span><span style="color:#75715e"></span>    wait_for_thread_shutdown();

    <span style="color:#75715e">/* Get current thread state and interpreter pointer */</span>
    tstate <span style="color:#f92672">=</span> PyThreadState_GET();
    interp <span style="color:#f92672">=</span> tstate<span style="color:#f92672">-&gt;</span>interp;

    <span style="color:#75715e">// 调用 atexit 注册的退出函数
</span><span style="color:#75715e"></span>    call_py_exitfuncs(interp);

    <span style="color:#75715e">/* Flush sys.stdout and sys.stderr */</span>
    <span style="color:#66d9ef">if</span> (flush_std_files() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
        status <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }

    <span style="color:#75715e">/* Disable signal handling */</span>
    PyOS_FiniInterrupts();

    <span style="color:#75715e">// 垃圾回收，执行析构方法
</span><span style="color:#75715e"></span>    _PyGC_CollectIfEnabled();

    <span style="color:#75715e">// 释放导入的模块
</span><span style="color:#75715e"></span>    PyImport_Cleanup();

    <span style="color:#75715e">// 执行相关结束函数
</span><span style="color:#75715e"></span>    _PyTraceMalloc_Fini();
    _PyImport_Fini();
    _PyType_Fini();
    _PyFaulthandler_Fini();
    _PyExc_Fini();

    <span style="color:#75715e">// 执行内置类型的结束函数
</span><span style="color:#75715e"></span>    PyMethod_Fini();
    PyFrame_Fini();
    PyCFunction_Fini();
    PyTuple_Fini();
    PyList_Fini();
    PySet_Fini();
    PyBytes_Fini();
    PyByteArray_Fini();
    PyLong_Fini();
    PyFloat_Fini();
    PyDict_Fini();
    PySlice_Fini();
    _PyGC_Fini();
    _Py_HashRandomization_Fini();
    _PyArg_Fini();
    PyAsyncGen_Fini();
    _PyContext_Fini();

    <span style="color:#75715e">/* Cleanup Unicode implementation */</span>
    _PyUnicode_Fini();

    PyGrammar_RemoveAccelerators(<span style="color:#f92672">&amp;</span>_PyParser_Grammar);

    <span style="color:#75715e">/* Cleanup auto-thread-state */</span>
    _PyGILState_Fini();

    <span style="color:#75715e">/* Delete current thread. After this, many C API calls become crashy. */</span>
    PyThreadState_Swap(NULL);
    <span style="color:#75715e">// 清理解释器和主线程状态
</span><span style="color:#75715e"></span>    PyInterpreterState_Delete(interp);

    call_ll_exitfuncs();

    _PyRuntime_Finalize();

    <span style="color:#66d9ef">return</span> status;
}</code></pre></div></p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex justify-between">



  <div>
    
    <a class="flex align-center" href="https://github.com/hjlarry/hjlarry.github.io/commit/6a8e6f321bed04644121d045a8035261ef90e03e" title='最后修改者 hjlarry | July 7, 2020' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>July 7, 2020</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/hjlarry/hjlarry.github.io/edit/master/content/docs/python/interpreter/_index.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>编辑本页</span>
    </a>
  </div>

</div>

 
        <br>
<div style="text-align: center;font-size:xx-small;">
    Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> | Theme by <a
        href="https://github.com/alex-shpak/hugo-book" target="_blank">hugo-book</a>
</div>
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#字节码">字节码</a></li>
    <li><a href="#gil">GIL</a></li>
    <li><a href="#执行过程">执行过程</a>
      <ul>
        <li><a href="#编码规范">编码规范</a></li>
        <li><a href="#执行方式">执行方式</a></li>
        <li><a href="#建立运行时环境">建立运行时环境</a></li>
        <li><a href="#通过输入运行">通过输入运行</a></li>
        <li><a href="#语义解析">语义解析</a></li>
        <li><a href="#ast">AST</a></li>
        <li><a href="#编译">编译</a></li>
        <li><a href="#终止">终止</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












