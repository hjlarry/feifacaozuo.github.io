<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="CPython解释器#编码规范#像PEP8一样，CPython也有自己的一套编码规范，为PEP7，有一些命名规范可以帮助我们更好的阅读源码:
 使用Py前缀的方法为公共方法，但不会用于静态方法。Py_前缀是为Py_FatalError这样的全局服务性函数保留的，对于特殊的类型(比如某类对象的API)会使用更长的前缀，例如PyString_都是字符串类的方法 公共函数和变量使用驼峰加上下划线，例如PyObject_GetAttr, Py_BuildValue, PyExc_TypeError等 偶尔有一些内部的函数，却需要对加载器可见，我们使用_Py前缀，例如_PyObject_Dump 宏使用驼峰前缀加大写，例如PyString_AS_STRING, Py_PRINT_RAW等  执行方式#程序入口#Python的执行方式有五种:
 使用python -c执行单条语句 使用python -m执行某个模块 通常使用的运行某个文件 使用shell的管道连接，将stdin的内容作为python的输入 使用交互式命令行环境(REPL)  通过这三个文件，我们能观察到一个整体的执行过程:
 Programs/python.c，一个简单的最初的程序入口 Modules/main.c，把整个执行过程的抽象打包再一起，包含加载环境信息、执行代码和清理内存 Python/initconfig.c，从系统中加载环境变量等信息，以及命令行中的参数等  &lt;!-- cpython/Programs/python.c --&gt; int main(int argc, char **argv) {  // unix平台是_Py_UnixMain，windows平台是Py_Main  return _Py_UnixMain(argc, argv); } 然后是选择执行模式: &lt;!-- cpython/Modules/main.c --&gt; int _Py_UnixMain(int argc, char **argv) {  return pymain_main(&amp;pymain); }  static int pymain_main(_PyMain *pymain) {  pymain_init(pymain);  int res = pymain_cmdline(pymain);  if (res &lt; 0) {  _Py_FatalInitError(pymain-&gt;err);  }  if (res == 1) {  goto done;  }  pymain_init_stdio(pymain);  // 初始化  pymain-&gt;err = _Py_InitializeCore(&amp;pymain-&gt;config);  // 执行逻辑  pymain_run_python(pymain);  if (Py_FinalizeEx() &lt; 0) {  pymain-&gt;status = 120;  } done:  // 退出清理  pymain_free(pymain);  return pymain-&gt;status; }  static void pymain_run_python(_PyMain *pymain) {  PyCompilerFlags cf = {.">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="CPython解释器" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/docs/python/interpreter/" />

<title>CPython解释器 | Home</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css" >
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/cn.search.min.dcaf7fea7db359f8fd7a4b37bdf1a9f765580260566390cc959292e2dcc5a5d9.js" ></script>
<link rel="alternate" type="application/rss+xml" href="/docs/python/interpreter/index.xml" title="Home" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" /><span>Home</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  <ul>
<li><strong>计算机基础</strong>
<ul>
<li><a href="/docs/sicp/hardware/">硬件</a></li>
<li><a href="/docs/sicp/software/">软件</a></li>
<li><a href="/docs/sicp/program/">程序</a></li>
<li><a href="/docs/sicp/asm/">汇编</a></li>
</ul>
</li>
<li><strong>GO语言</strong>
<ul>
<li><a href="/docs/go/map/">字典</a></li>
<li><a href="/docs/go/closure/">闭包</a></li>
<li><a href="/docs/go/defer/">延迟调用</a></li>
<li><a href="/docs/go/goroutine/">并发调度</a></li>
<li><a href="/docs/go/alloc/">内存分配</a></li>
<li><a href="/docs/go/gc/">垃圾回收</a></li>
<li><a href="/docs/go/lock/">锁</a></li>
</ul>
</li>
<li><strong>Python语言</strong>
<ul>
<li><a href="/docs/python/memory/">内存管理</a></li>
<li><a href="/docs/python/interpreter/"class=active>解释器</a></li>
<li><a href="/docs/python/tools/">技巧工具</a></li>
</ul>
</li>
<li><strong>Mysql</strong>
<ul>
<li><a href="/docs/mysql/query/">查询</a></li>
<li><a href="/docs/mysql/theory/">原理</a></li>
</ul>
</li>
<li><strong>其他</strong>
<ul>
<li><a href="/docs/other/git/">git</a></li>
<li><a href="/docs/other/docker/">docker</a></li>
<li><a href="/docs/other/raft/">raft</a></li>
<li><a href="/docs/other/shell/">shell</a></li>
<li><a href="/docs/other/oop/">面向对象</a></li>
<li><a href="/docs/other/protocol/">网络协议</a></li>
<li><a href="/docs/other/tools/">系统工具</a></li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>CPython解释器</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#编码规范">编码规范</a></li>
    <li><a href="#执行方式">执行方式</a>
      <ul>
        <li><a href="#程序入口">程序入口</a></li>
        <li><a href="#运行时环境">运行时环境</a></li>
        <li><a href="#-c的方式">-c的方式</a></li>
        <li><a href="#-m的方式">-m的方式</a></li>
        <li><a href="#file的方式">file的方式</a></li>
      </ul>
    </li>
    <li><a href="#编译">编译</a>
      <ul>
        <li><a href="#语义解析">语义解析</a></li>
        <li><a href="#ast">AST</a></li>
        <li><a href="#编译过程">编译过程</a></li>
        <li><a href="#汇编器">汇编器</a></li>
        <li><a href="#创建代码对象">创建代码对象</a></li>
        <li><a href="#字节码">字节码</a></li>
      </ul>
    </li>
    <li><a href="#执行">执行</a>
      <ul>
        <li><a href="#构建frame">构建frame</a></li>
        <li><a href="#执行frame">执行frame</a></li>
        <li><a href="#值栈">值栈</a></li>
      </ul>
    </li>
    <li><a href="#cpython中的对象">CPython中的对象</a>
      <ul>
        <li><a href="#基础对象">基础对象</a></li>
        <li><a href="#布尔和整数">布尔和整数</a></li>
        <li><a href="#生成器类型">生成器类型</a></li>
      </ul>
    </li>
    <li><a href="#标准库">标准库</a></li>
    <li><a href="#gil">GIL</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="cpython解释器">
  CPython解释器
  <a class="anchor" href="#cpython%e8%a7%a3%e9%87%8a%e5%99%a8">#</a>
</h1>
<h2 id="编码规范">
  编码规范
  <a class="anchor" href="#%e7%bc%96%e7%a0%81%e8%a7%84%e8%8c%83">#</a>
</h2>
<p>像<code>PEP8</code>一样，CPython也有自己的一套编码规范，为<a href="https://www.python.org/dev/peps/pep-0007/">PEP7</a>，有一些命名规范可以帮助我们更好的阅读源码:</p>
<ul>
<li>使用<code>Py</code>前缀的方法为公共方法，但不会用于静态方法。<code>Py_</code>前缀是为<code>Py_FatalError</code>这样的全局服务性函数保留的，对于特殊的类型(比如某类对象的API)会使用更长的前缀，例如<code>PyString_</code>都是字符串类的方法</li>
<li>公共函数和变量使用驼峰加上下划线，例如PyObject_GetAttr, Py_BuildValue, PyExc_TypeError等</li>
<li>偶尔有一些内部的函数，却需要对加载器可见，我们使用<code>_Py</code>前缀，例如_PyObject_Dump</li>
<li>宏使用驼峰前缀加大写，例如PyString_AS_STRING, Py_PRINT_RAW等</li>
</ul>
<h2 id="执行方式">
  执行方式
  <a class="anchor" href="#%e6%89%a7%e8%a1%8c%e6%96%b9%e5%bc%8f">#</a>
</h2>
<h3 id="程序入口">
  程序入口
  <a class="anchor" href="#%e7%a8%8b%e5%ba%8f%e5%85%a5%e5%8f%a3">#</a>
</h3>
<p>Python的执行方式有五种:</p>
<ul>
<li>使用<code>python -c</code>执行单条语句</li>
<li>使用<code>python -m</code>执行某个模块</li>
<li>通常使用的运行某个文件</li>
<li>使用shell的管道连接，将<code>stdin</code>的内容作为python的输入</li>
<li>使用交互式命令行环境(REPL)</li>
</ul>
<p>通过这三个文件，我们能观察到一个整体的执行过程:</p>
<ol>
<li>Programs/python.c，一个简单的最初的程序入口</li>
<li>Modules/main.c，把整个执行过程的抽象打包再一起，包含加载环境信息、执行代码和清理内存</li>
<li>Python/initconfig.c，从系统中加载环境变量等信息，以及命令行中的参数等</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">&lt;!--</span> cpython<span style="color:#f92672">/</span>Programs<span style="color:#f92672">/</span>python.c <span style="color:#f92672">--&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> main(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// unix平台是_Py_UnixMain，windows平台是Py_Main
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> _Py_UnixMain(argc, argv);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>然后是选择执行模式:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">&lt;!--</span> cpython<span style="color:#f92672">/</span>Modules<span style="color:#f92672">/</span>main.c <span style="color:#f92672">--&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> _Py_UnixMain(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> pymain_main(<span style="color:#f92672">&amp;</span>pymain);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> pymain_main(_PyMain <span style="color:#f92672">*</span>pymain)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    pymain_init(pymain);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> pymain_cmdline(pymain);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (res <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        _Py_FatalInitError(pymain<span style="color:#f92672">-&gt;</span>err);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (res <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> done;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    pymain_init_stdio(pymain);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    pymain<span style="color:#f92672">-&gt;</span>err <span style="color:#f92672">=</span> _Py_InitializeCore(<span style="color:#f92672">&amp;</span>pymain<span style="color:#f92672">-&gt;</span>config);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 执行逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    pymain_run_python(pymain);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Py_FinalizeEx() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        pymain<span style="color:#f92672">-&gt;</span>status <span style="color:#f92672">=</span> <span style="color:#ae81ff">120</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>done:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 退出清理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    pymain_free(pymain);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> pymain<span style="color:#f92672">-&gt;</span>status;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> pymain_run_python(_PyMain <span style="color:#f92672">*</span>pymain)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    PyCompilerFlags cf <span style="color:#f92672">=</span> {.cf_flags <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>    pymain_header(pymain);
</span></span><span style="display:flex;"><span>    pymain_import_readline(pymain);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 执行模式选择
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (pymain<span style="color:#f92672">-&gt;</span>command) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 命令行模式 -c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pymain<span style="color:#f92672">-&gt;</span>status <span style="color:#f92672">=</span> pymain_run_command(pymain<span style="color:#f92672">-&gt;</span>command, <span style="color:#f92672">&amp;</span>cf);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (pymain<span style="color:#f92672">-&gt;</span>module) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 模块模式 -m
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pymain<span style="color:#f92672">-&gt;</span>status <span style="color:#f92672">=</span> (pymain_run_module(pymain<span style="color:#f92672">-&gt;</span>module, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 入口文件模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pymain_run_filename(pymain, <span style="color:#f92672">&amp;</span>cf);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    pymain_repl(pymain, <span style="color:#f92672">&amp;</span>cf);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<p>这个流程图能清晰的表达出上述代码:</p>
<p><img src="./images/exe_process.png" alt="" /></p>
<h3 id="运行时环境">
  运行时环境
  <a class="anchor" href="#%e8%bf%90%e8%a1%8c%e6%97%b6%e7%8e%af%e5%a2%83">#</a>
</h3>
<p>通过上图，我们可以看到无论执行任何python代码，运行时首先会建立相关环境。这个环境在<code>Include/cpython/initconfig.h</code>中定义为<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Include/cpython/initconfig.h#L407">PyConfig</a>，该结构体中的数据包括:</p>
<ul>
<li>运行模式的标记，比如debug或optimized模式</li>
<li>执行的模式，比如是以文件的方式、或者模块的方式、stdin的方式</li>
<li>通过<code>-X &lt;option&gt;</code>附加的拓展选项</li>
<li>运行时设置的环境变量</li>
</ul>
<p>这些值，我们也可以在运行时中查看到:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>[ubuntu] <span style="color:#f92672">/</span>tmp<span style="color:#f92672">/</span>missing<span style="color:#f92672">/</span>tt <span style="color:#960050;background-color:#1e0010">$</span> python3 <span style="color:#f92672">-</span>X dev <span style="color:#f92672">-</span>q <span style="color:#f92672">-</span>v
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> sys<span style="color:#f92672">.</span>flags
</span></span><span style="display:flex;"><span>sys<span style="color:#f92672">.</span>flags(debug<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, inspect<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, interactive<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, optimize<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, dont_write_bytecode<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, no_user_site<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, no_site<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, ignore_environment<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, verbose<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, bytes_warning<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, quiet<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, hash_randomization<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, isolated<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> sys<span style="color:#f92672">.</span>_xoptions
</span></span><span style="display:flex;"><span>{<span style="color:#e6db74">&#39;dev&#39;</span>: <span style="color:#66d9ef">True</span>}</span></span></code></pre></div></p>
<h3 id="-c的方式">
  -c的方式
  <a class="anchor" href="#-c%e7%9a%84%e6%96%b9%e5%bc%8f">#</a>
</h3>
<p>例如<code>python -c &quot;print('hi')&quot;</code>，它的运行流程如图所示:</p>
<p><img src="./images/pymain_run_command.png" alt="pymain_run_command" /></p>
<p><a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Modules/main.c#L240">pymain_run_command()</a>的核心逻辑如下:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 首个参数就是-c传递的指令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// wchar_t*类型通常是CPython中用于存储Unicode数据的低级存储类型，因为该类型的大小也可以存储UTF8字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pymain_run_command</span>(wchar_t <span style="color:#f92672">*</span>command, PyCompilerFlags <span style="color:#f92672">*</span>cf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>unicode, <span style="color:#f92672">*</span>bytes;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 转换为PyUnicode对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    unicode <span style="color:#f92672">=</span> PyUnicode_FromWideChar(command, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 对unicode进行utf8编码得到一个python字节对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bytes <span style="color:#f92672">=</span> PyUnicode_AsUTF8String(unicode);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 重新解码为字符串丢去执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ret <span style="color:#f92672">=</span> PyRun_SimpleStringFlags(PyBytes_AsString(bytes), cf);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<p>而<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/pythonrun.c#L453">PyRun_SimpleStringFlags()</a>的目的是创建一个Python模块<code>__main__</code>，和一个字典，再将命令一起打包调用<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/pythonrun.c#L1008">PyRun_StringFlags()</a>，这个函数将创建一个假的文件名，接着就是调用Python解析器创建AST并返回模块mod了:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PyRun_SimpleStringFlags</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>command, PyCompilerFlags <span style="color:#f92672">*</span>flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>m, <span style="color:#f92672">*</span>d, <span style="color:#f92672">*</span>v;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 建立入口模块
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    m <span style="color:#f92672">=</span> PyImport_AddModule(<span style="color:#e6db74">&#34;__main__&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建字典，用于globals()和locals()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    d <span style="color:#f92672">=</span> PyModule_GetDict(m);
</span></span><span style="display:flex;"><span>    v <span style="color:#f92672">=</span> PyRun_StringFlags(command, Py_file_input, d, d, flags);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PyObject <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PyRun_StringFlags</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str, <span style="color:#66d9ef">int</span> start, PyObject <span style="color:#f92672">*</span>globals,
</span></span><span style="display:flex;"><span>                  PyObject <span style="color:#f92672">*</span>locals, PyCompilerFlags <span style="color:#f92672">*</span>flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    mod <span style="color:#f92672">=</span> PyParser_ASTFromStringObject(str, filename, start, flags, arena);
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> run_mod(mod, filename, globals, locals, flags, arena);
</span></span><span style="display:flex;"><span>    PyArena_Free(arena);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;</span></span></code></pre></div></p>
<h3 id="-m的方式">
  -m的方式
  <a class="anchor" href="#-m%e7%9a%84%e6%96%b9%e5%bc%8f">#</a>
</h3>
<p>另一种执行Python命令的方式是-m选项和模块名称，例如<code>python -m unittest</code>可以运行标准库中的unittest模块。实际上它就是在sys.path中去搜索名为unittest的模块然后去执行。</p>
<p>CPython是先通过一个C的API函数<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/import.c#L1409">PyImport_ImportModule()</a>来导入标准库<code>runpy</code>，它返回的是一个PyObject核心对象类型，然后需要一些特殊的方法获取它的属性再调用。例如<code>hi.upper()</code>相当于<code>hi.upper.__call__()</code>，在C中<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Objects/object.c#L831">PyObject_GetAttrString()</a>就是用来获得hi的upper属性，然后通过<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Objects/call.c#L214">PyObject_Call()</a>就是去执行__call__()。</p>
<p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// modname就是通过-m传递进来的参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pymain_run_module</span>(<span style="color:#66d9ef">const</span> wchar_t <span style="color:#f92672">*</span>modname, <span style="color:#66d9ef">int</span> set_argv0)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>module, <span style="color:#f92672">*</span>runpy, <span style="color:#f92672">*</span>runmodule, <span style="color:#f92672">*</span>runargs, <span style="color:#f92672">*</span>result;
</span></span><span style="display:flex;"><span>    runpy <span style="color:#f92672">=</span> PyImport_ImportModule(<span style="color:#e6db74">&#34;runpy&#34;</span>);
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>    runmodule <span style="color:#f92672">=</span> PyObject_GetAttrString(runpy, <span style="color:#e6db74">&#34;_run_module_as_main&#34;</span>);
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>    module <span style="color:#f92672">=</span> PyUnicode_FromWideChar(modname, wcslen(modname));
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>    runargs <span style="color:#f92672">=</span> Py_BuildValue(<span style="color:#e6db74">&#34;(Oi)&#34;</span>, module, set_argv0);
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> PyObject_Call(runmodule, runargs, NULL);
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (result <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> pymain_exit_err_print();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Py_DECREF(result);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
这段代码说明<code>python -m &lt;module&gt;</code>本质上是<code>python -m runpy &lt;module&gt;</code>，module只是参数，runpy对其进行了一层包装。runpy是用纯python写的位于<code>Lib/runpy.py</code>，它的目的是抽象在不同操作系统上定位和执行模块的过程，具体干这些事:</p>
<ul>
<li>调用用户提供的模块的<code>__import__()</code>方法</li>
<li>设置该模块的名字空间为<code>__main__</code></li>
<li>在<code>__main__</code>的名字空间下执行该模块</li>
</ul>
<p>runpy模块同样也可以用来执行某个目录或者zip文件。</p>
<h3 id="file的方式">
  file的方式
  <a class="anchor" href="#file%e7%9a%84%e6%96%b9%e5%bc%8f">#</a>
</h3>
<p>如果是<code>python test.py</code>这种方式，CPython会打开一个文件句柄，然后传递给<code>Python/pythonrun.c</code>中的<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/pythonrun.c#L372">PyRun_SimpleFileExFlags()</a>方法:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PyRun_SimpleFileExFlags</span>(FILE <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>filename, <span style="color:#66d9ef">int</span> closeit,
</span></span><span style="display:flex;"><span>                        PyCompilerFlags <span style="color:#f92672">*</span>flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>    m <span style="color:#f92672">=</span> PyImport_AddModule(<span style="color:#e6db74">&#34;__main__&#34;</span>);
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果是pyc文件，则调用run_pyc_file()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (maybe_pyc_file(fp, filename, ext, closeit)) {
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>        v <span style="color:#f92672">=</span> run_pyc_file(pyc_fp, filename, d, d, flags);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// .py和stdin模式都运行PyRun_FileExFlags()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (strcmp(filename, <span style="color:#e6db74">&#34;&lt;stdin&gt;&#34;</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>            set_main_loader(d, filename, <span style="color:#e6db74">&#34;SourceFileLoader&#34;</span>) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            fprintf(stderr, <span style="color:#e6db74">&#34;python: failed to set __main__.__loader__</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>            ret <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">goto</span> done;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        v <span style="color:#f92672">=</span> PyRun_FileExFlags(fp, filename, Py_file_input, d, d,
</span></span><span style="display:flex;"><span>                              closeit, flags);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<p>而<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/pythonrun.c#L1032">PyRun_FileExFlags()</a>和前文介绍的通过-c输入的PyRun_SimpleStringFlags()作用类似，都是去创建AST返回mod然后运行mod:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>PyObject <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PyRun_FileExFlags</span>(FILE <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>filename_str, <span style="color:#66d9ef">int</span> start, PyObject <span style="color:#f92672">*</span>globals,
</span></span><span style="display:flex;"><span>                  PyObject <span style="color:#f92672">*</span>locals, <span style="color:#66d9ef">int</span> closeit, PyCompilerFlags <span style="color:#f92672">*</span>flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>    mod <span style="color:#f92672">=</span> PyParser_ASTFromFileObject(fp, filename, NULL, start, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>                                     flags, NULL, arena);
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> run_mod(mod, filename, globals, locals, flags, arena);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<p><a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/pythonrun.c#L1125">run_mod()</a>负责把模块发送给AST编译为一个代码对象，即文章开头提到过的存储字节码以及保存在.pyc文件中的对象:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> PyObject <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">run_mod</span>(mod_ty mod, PyObject <span style="color:#f92672">*</span>filename, PyObject <span style="color:#f92672">*</span>globals, PyObject <span style="color:#f92672">*</span>locals,
</span></span><span style="display:flex;"><span>            PyCompilerFlags <span style="color:#f92672">*</span>flags, PyArena <span style="color:#f92672">*</span>arena)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    PyCodeObject <span style="color:#f92672">*</span>co;
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>v;
</span></span><span style="display:flex;"><span>    co <span style="color:#f92672">=</span> PyAST_CompileObject(mod, filename, flags, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, arena);
</span></span><span style="display:flex;"><span>    v <span style="color:#f92672">=</span> run_eval_code_obj(co, globals, locals);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> v;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
之后的run_eval_code_obj()就属于执行逻辑了，后文中再描述。</p>
<p><a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/pythonrun.c#L1145">run_pyc_file()</a>可以理解为省略了创建AST的过程，而是通过marshal把pyc文件中的内容复制到内存并将其转换为特定的数据结构。硬盘上的pyc文件就是CPython编译器缓存已编译代码的方式，因此无需每次调用脚本时再编译一次:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> PyObject <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">run_pyc_file</span>(FILE <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>filename, PyObject <span style="color:#f92672">*</span>globals,
</span></span><span style="display:flex;"><span>             PyObject <span style="color:#f92672">*</span>locals, PyCompilerFlags <span style="color:#f92672">*</span>flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    PyCodeObject <span style="color:#f92672">*</span>co;
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>v;
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>    v <span style="color:#f92672">=</span> PyMarshal_ReadLastObjectFromFile(fp);
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>    co <span style="color:#f92672">=</span> (PyCodeObject <span style="color:#f92672">*</span>)v;
</span></span><span style="display:flex;"><span>    v <span style="color:#f92672">=</span> run_eval_code_obj(co, globals, locals);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> v;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<h2 id="编译">
  编译
  <a class="anchor" href="#%e7%bc%96%e8%af%91">#</a>
</h2>
<h3 id="语义解析">
  语义解析
  <a class="anchor" href="#%e8%af%ad%e4%b9%89%e8%a7%a3%e6%9e%90">#</a>
</h3>
<p>在前文中我们了解到在执行时会先去创建AST，那么这步具体是怎么做的呢:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>mod_ty
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PyParser_ASTFromFileObject</span>(FILE <span style="color:#f92672">*</span>fp, PyObject <span style="color:#f92672">*</span>filename, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> enc,
</span></span><span style="display:flex;"><span>                           <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ps1,
</span></span><span style="display:flex;"><span>                           <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ps2, PyCompilerFlags <span style="color:#f92672">*</span>flags, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>errcode,
</span></span><span style="display:flex;"><span>                           PyArena <span style="color:#f92672">*</span>arena)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">*</span>n <span style="color:#f92672">=</span> PyParser_ParseFileObject(fp, filename, enc,
</span></span><span style="display:flex;"><span>                                       <span style="color:#f92672">&amp;</span>_PyParser_Grammar,
</span></span><span style="display:flex;"><span>                                       start, ps1, ps2, <span style="color:#f92672">&amp;</span>err, <span style="color:#f92672">&amp;</span>iflags);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n) {
</span></span><span style="display:flex;"><span>        flags<span style="color:#f92672">-&gt;</span>cf_flags <span style="color:#f92672">|=</span> iflags <span style="color:#f92672">&amp;</span> PyCF_MASK;
</span></span><span style="display:flex;"><span>        mod <span style="color:#f92672">=</span> PyAST_FromNodeObject(n, flags, filename, arena);
</span></span><span style="display:flex;"><span>        PyNode_Free(n);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> mod;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
在<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/ast.c#L772">PyParser_ASTFromFileObject()</a>方法中，会将文件句柄、编译器标志、以及内存块对象打包给<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Parser/parsetok.c#L163">PyParser_ParseFileObject()</a>转换为一个node对象:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>node <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PyParser_ParseFileObject</span>(FILE <span style="color:#f92672">*</span>fp, PyObject <span style="color:#f92672">*</span>filename,
</span></span><span style="display:flex;"><span>                         <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>enc, grammar <span style="color:#f92672">*</span>g, <span style="color:#66d9ef">int</span> start,
</span></span><span style="display:flex;"><span>                         <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ps1, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ps2,
</span></span><span style="display:flex;"><span>                         perrdetail <span style="color:#f92672">*</span>err_ret, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> tok_state <span style="color:#f92672">*</span>tok;
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((tok <span style="color:#f92672">=</span> PyTokenizer_FromFile(fp, enc, ps1, ps2)) <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        err_ret<span style="color:#f92672">-&gt;</span>error <span style="color:#f92672">=</span> E_NOMEM;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> parsetok(tok, g, start, err_ret, flags);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
该方法把两项重要的任务组合了起来，一是使用<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Parser/tokenizer.h#L78">PyTokenizer_FromFile()</a>实例化一个tok_state，tok_state也只是一个数据结构(容器)，存储由tokenizer生成的临时数据；二是使用<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Parser/parsetok.c#L232">parsetok()</a>将token转换为一个具体的解析树(节点列表)。</p>
<p>在parsetok()中，将循环调用<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Parser/tokenizer.c#L1110">tok_get()</a>方法，该方法像是一个迭代器，不断获取解析树的下一个token，parsetok()在根据不同token设置tok_state中相关的值。它也是CPython中最复杂的方法之一，因为要兼容各种各样的边缘情况、数十年的历史原因、新的语言特性等等原因。我们来看其中一种简单的解析，如何把每行结尾变为token<code>NEWLINE</code>的:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">tok_get</span>(<span style="color:#66d9ef">struct</span> tok_state <span style="color:#f92672">*</span>tok, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>p_start, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>p_end)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Newline */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\n&#39;</span>) {
</span></span><span style="display:flex;"><span>        tok<span style="color:#f92672">-&gt;</span>atbol <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (blankline <span style="color:#f92672">||</span> tok<span style="color:#f92672">-&gt;</span>level <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">goto</span> nextline;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>p_start <span style="color:#f92672">=</span> tok<span style="color:#f92672">-&gt;</span>start;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>p_end <span style="color:#f92672">=</span> tok<span style="color:#f92672">-&gt;</span>cur <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">/* Leave &#39;\n&#39; out of the string */</span>
</span></span><span style="display:flex;"><span>        tok<span style="color:#f92672">-&gt;</span>cont_line <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (tok<span style="color:#f92672">-&gt;</span>async_def) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/* We&#39;re somewhere inside an &#39;async def&#39; function, and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">               we&#39;ve encountered a NEWLINE after its signature. */</span>
</span></span><span style="display:flex;"><span>            tok<span style="color:#f92672">-&gt;</span>async_def_nl <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NEWLINE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
parsetok()返回的是一个node节点类型:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _node {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">short</span>               n_type;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span>                <span style="color:#f92672">*</span>n_str;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span>                 n_lineno;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span>                 n_col_offset;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span>                 n_nchildren;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _node        <span style="color:#f92672">*</span>n_child;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span>                 n_end_lineno;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span>                 n_end_col_offset;
</span></span><span style="display:flex;"><span>} node;</span></span></code></pre></div>
这些个节点组成的树我们叫CST，每个节点包含了语法、tokenID、符号，但这个树不能用于编译器做出快速决策，编译器需要更高一级抽象即AST，我们可以通过内部的API观察到CST的输出结果:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> symbol
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> token
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> parser
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 为了输出结果的可读性，做了一层处理</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lex</span>(expression):
</span></span><span style="display:flex;"><span>    symbols <span style="color:#f92672">=</span> {v: k <span style="color:#66d9ef">for</span> k, v <span style="color:#f92672">in</span> symbol<span style="color:#f92672">.</span>__dict__<span style="color:#f92672">.</span>items() <span style="color:#66d9ef">if</span> isinstance(v, int)}
</span></span><span style="display:flex;"><span>    tokens <span style="color:#f92672">=</span> {v: k <span style="color:#66d9ef">for</span> k, v <span style="color:#f92672">in</span> token<span style="color:#f92672">.</span>__dict__<span style="color:#f92672">.</span>items() <span style="color:#66d9ef">if</span> isinstance(v, int)}
</span></span><span style="display:flex;"><span>    lexicon <span style="color:#f92672">=</span> {<span style="color:#f92672">**</span>symbols, <span style="color:#f92672">**</span>tokens}
</span></span><span style="display:flex;"><span>    st <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span>expr(expression)
</span></span><span style="display:flex;"><span>    st_list <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span>st2list(st)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">replace</span>(l: list):
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> l:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> isinstance(i, list):
</span></span><span style="display:flex;"><span>                r<span style="color:#f92672">.</span>append(replace(i))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> i <span style="color:#f92672">in</span> lexicon:
</span></span><span style="display:flex;"><span>                    r<span style="color:#f92672">.</span>append(lexicon[i])
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    r<span style="color:#f92672">.</span>append(i)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> r
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> replace(st_list)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 小写的就是符号，大写的就是token</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> pprint(lex(<span style="color:#e6db74">&#39;a + 1&#39;</span>))
</span></span><span style="display:flex;"><span>[<span style="color:#e6db74">&#39;eval_input&#39;</span>,
</span></span><span style="display:flex;"><span> [<span style="color:#e6db74">&#39;testlist&#39;</span>,
</span></span><span style="display:flex;"><span>  [<span style="color:#e6db74">&#39;test&#39;</span>,
</span></span><span style="display:flex;"><span>   [<span style="color:#e6db74">&#39;or_test&#39;</span>,
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#39;and_test&#39;</span>,
</span></span><span style="display:flex;"><span>     [<span style="color:#e6db74">&#39;not_test&#39;</span>,
</span></span><span style="display:flex;"><span>      [<span style="color:#e6db74">&#39;comparison&#39;</span>,
</span></span><span style="display:flex;"><span>       [<span style="color:#e6db74">&#39;expr&#39;</span>,
</span></span><span style="display:flex;"><span>        [<span style="color:#e6db74">&#39;xor_expr&#39;</span>,
</span></span><span style="display:flex;"><span>         [<span style="color:#e6db74">&#39;and_expr&#39;</span>,
</span></span><span style="display:flex;"><span>          [<span style="color:#e6db74">&#39;shift_expr&#39;</span>,
</span></span><span style="display:flex;"><span>           [<span style="color:#e6db74">&#39;arith_expr&#39;</span>,
</span></span><span style="display:flex;"><span>            [<span style="color:#e6db74">&#39;term&#39;</span>,
</span></span><span style="display:flex;"><span>             [<span style="color:#e6db74">&#39;factor&#39;</span>, [<span style="color:#e6db74">&#39;power&#39;</span>, [<span style="color:#e6db74">&#39;atom_expr&#39;</span>, [<span style="color:#e6db74">&#39;atom&#39;</span>, [<span style="color:#e6db74">&#39;NAME&#39;</span>, <span style="color:#e6db74">&#39;a&#39;</span>]]]]]],
</span></span><span style="display:flex;"><span>            [<span style="color:#e6db74">&#39;PLUS&#39;</span>, <span style="color:#e6db74">&#39;+&#39;</span>],
</span></span><span style="display:flex;"><span>            [<span style="color:#e6db74">&#39;term&#39;</span>,
</span></span><span style="display:flex;"><span>             [<span style="color:#e6db74">&#39;factor&#39;</span>,
</span></span><span style="display:flex;"><span>              [<span style="color:#e6db74">&#39;power&#39;</span>, [<span style="color:#e6db74">&#39;atom_expr&#39;</span>, [<span style="color:#e6db74">&#39;atom&#39;</span>, [<span style="color:#e6db74">&#39;NUMBER&#39;</span>, <span style="color:#e6db74">&#39;1&#39;</span>]]]]]]]]]]]]]]]]],
</span></span><span style="display:flex;"><span> [<span style="color:#e6db74">&#39;NEWLINE&#39;</span>, <span style="color:#e6db74">&#39;&#39;</span>],
</span></span><span style="display:flex;"><span> [<span style="color:#e6db74">&#39;ENDMARKER&#39;</span>, <span style="color:#e6db74">&#39;&#39;</span>]]</span></span></code></pre></div></p>
<h3 id="ast">
  AST
  <a class="anchor" href="#ast">#</a>
</h3>
<p>CPython的下一个阶段就是将CST转换为能够执行的、更有逻辑的东西，也就是AST(Abstract Syntax Trees，抽象语法树)。虽然这一步是解释器内联生成，我们也有其他办法能方便的观察到，例如使用<code>instaviz</code>库，它能在一个网页中展示AST以及每个节点的属性:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">import</span> instaviz
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">example</span>():
</span></span><span style="display:flex;"><span>       a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>       b <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">return</span> b
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> instaviz<span style="color:#f92672">.</span>show(example)</span></span></code></pre></div>
我们能看到这样的界面:
<img src="./images/instaviz_web.png" alt="instaviz_web" /></p>
<p>然后可以点击AST中的节点:
<img src="./images/instaviz_node.png" alt="instaviz_node" />
例如如果点击图中的Assign节点，它代表的是<code>b=a+1</code>这一行，右侧会展示出这个节点的属性，它有两个属性，一个是targets，代表变量名称，它有时可能是一个列表，因为解包操作就会有多个变量；另一个是value，代表变量的值，在这里就是<code>a+1</code>这个表达式。如果我们再点击BinOp节点，就可以看到它的3个属性，left表示运算符左边是什么，op表示运算符，right表示运算符右边。</p>
<p>用C语言编译AST并不是一件容易的事，所以实际上真正的编译模块有5000行代码，在<code>Python/ast.c</code>中。</p>
<p>具体到核心代码流程来说，之前通过PyParser_ParseFileObject()得到的CST对象node，接着传入<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/ast.c#L772">PyAST_FromNodeObject()</a>，并附带文件名、编译flag和PyArena。得到函数返回的mod_ty，是一个容器结构，属于Python5种模块类型之一:Module、Interactive、Expression、FunctionType、Suite。在<code>Include/Python-ast.h</code>中能看到每种类型需要的字段:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> _mod_kind {Module_kind<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, Interactive_kind<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, Expression_kind<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>                 FunctionType_kind<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>, Suite_kind<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> _mod {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> _mod_kind kind;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>            asdl_seq <span style="color:#f92672">*</span>body;
</span></span><span style="display:flex;"><span>            asdl_seq <span style="color:#f92672">*</span>type_ignores;
</span></span><span style="display:flex;"><span>        } Module;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>            asdl_seq <span style="color:#f92672">*</span>body;
</span></span><span style="display:flex;"><span>        } Interactive;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>            expr_ty body;
</span></span><span style="display:flex;"><span>        } Expression;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>            asdl_seq <span style="color:#f92672">*</span>argtypes;
</span></span><span style="display:flex;"><span>            expr_ty returns;
</span></span><span style="display:flex;"><span>        } FunctionType;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>            asdl_seq <span style="color:#f92672">*</span>body;
</span></span><span style="display:flex;"><span>        } Suite;
</span></span><span style="display:flex;"><span>    } v;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
除了模块类型，其他的AST类型都列在<code>Parser/Python.asdl</code>中，包括statement、expression、operators、comprehensions等等。在该文件中我们能看到类型字段的定义也是用在这里的:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">--</span> ASDL<span style="color:#960050;background-color:#1e0010">&#39;</span>s <span style="color:#ae81ff">5</span> builtin types are:
</span></span><span style="display:flex;"><span><span style="color:#f92672">--</span> identifier, <span style="color:#66d9ef">int</span>, string, object, constant
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>module Python
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    mod <span style="color:#f92672">=</span> Module(stmt<span style="color:#f92672">*</span> body, type_ignore <span style="color:#f92672">*</span>type_ignores)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">|</span> Interactive(stmt<span style="color:#f92672">*</span> body)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">|</span> Expression(expr body)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">|</span> FunctionType(expr<span style="color:#f92672">*</span> argtypes, expr returns)</span></span></code></pre></div></p>
<p>接着，PyAST_FromNodeObject()使用TYPE(n)确定首个CST节点的类型来执行不同的逻辑，如果是文件输入，返回的结果就是Module，eval_input就是Expression，总之是Module, Interactive, Expression, FunctionType中的一种:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>mod_ty
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PyAST_FromNodeObject</span>(<span style="color:#66d9ef">const</span> node <span style="color:#f92672">*</span>n, PyCompilerFlags <span style="color:#f92672">*</span>flags,
</span></span><span style="display:flex;"><span>                     PyObject <span style="color:#f92672">*</span>filename, PyArena <span style="color:#f92672">*</span>arena)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (TYPE(n)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> file_input:
</span></span><span style="display:flex;"><span>            stmts <span style="color:#f92672">=</span> _Py_asdl_seq_new(num_stmts(n), arena);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NCH(n) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                ch <span style="color:#f92672">=</span> CHILD(n, i);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (TYPE(ch) <span style="color:#f92672">==</span> NEWLINE)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                num <span style="color:#f92672">=</span> num_stmts(ch);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (num <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>                    s <span style="color:#f92672">=</span> ast_for_stmt(<span style="color:#f92672">&amp;</span>c, ch);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    ch <span style="color:#f92672">=</span> CHILD(ch, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>                    REQ(ch, simple_stmt);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> num; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                        s <span style="color:#f92672">=</span> ast_for_stmt(<span style="color:#f92672">&amp;</span>c, CHILD(ch, j <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/* Type ignores are stored under the ENDMARKER in file_input. */</span>
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> Module(stmts, type_ignores, arena);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> eval_input: {
</span></span><span style="display:flex;"><span>            expr_ty testlist_ast;
</span></span><span style="display:flex;"><span>            testlist_ast <span style="color:#f92672">=</span> ast_for_testlist(<span style="color:#f92672">&amp;</span>c, CHILD(n, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> Expression(testlist_ast, arena);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> single_input:
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> func_type_input:
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<p>遍历孩子节点并创建相应的AST语句节点逻辑在<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/ast.c#L4512">ast_for_stmt()</a>中，该函数内还需要再根据不同的语句类型调用不同的函数创建节点，都是类似于ast_for_*()，例如<code>2**4</code>这样的语句最终能找到ast_for_power()这样的方法。</p>
<h3 id="编译过程">
  编译过程
  <a class="anchor" href="#%e7%bc%96%e8%af%91%e8%bf%87%e7%a8%8b">#</a>
</h3>
<p>现在解释器有了AST，也就有了每个操作、函数、类和名字空间所需要的属性，下一步就是把AST编译为CPU能够理解的东西，这就是编译。编译可以分为两个部分:一是遍历树并创建一个控制流图(control-flow-graph)，用来表示逻辑执行的顺序；另外就是将控制流图中的节点转换为较小的可执行语句，称为字节码。</p>
<p><a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/compile.c#L312">PyAST_CompileObject()</a>函数是编译器部分的主要入口，它以Python模块作为主要参数，同解释器进程早期创建过的文件名称、全局变量、局部变量以及PyArena一起打包传入。然后先创建一个全局的编译器状态结构体，用来存储一些属性、编译标识、栈等等:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">&lt;!--</span> cpython<span style="color:#f92672">/</span>Python<span style="color:#f92672">/</span>compile.c <span style="color:#f92672">--&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> compiler {
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>c_filename;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> symtable <span style="color:#f92672">*</span>c_st;
</span></span><span style="display:flex;"><span>    PyFutureFeatures <span style="color:#f92672">*</span>c_future; <span style="color:#75715e">/* pointer to module&#39;s __future__ */</span>
</span></span><span style="display:flex;"><span>    PyCompilerFlags <span style="color:#f92672">*</span>c_flags;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> c_optimize;              <span style="color:#75715e">/* optimization level */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> c_interactive;           <span style="color:#75715e">/* true if in interactive mode */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> c_nestlevel;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> c_do_not_emit_bytecode;  
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>c_const_cache;     <span style="color:#75715e">/* Python dict holding all constants, including names tuple */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> compiler_unit <span style="color:#f92672">*</span>u; <span style="color:#75715e">/* compiler state for current block */</span>
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>c_stack;           <span style="color:#75715e">/* Python list holding compiler_unit ptrs */</span>
</span></span><span style="display:flex;"><span>    PyArena <span style="color:#f92672">*</span>c_arena;            <span style="color:#75715e">/* pointer to memory allocation arena */</span>
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
接着有11个主要步骤:</p>
<ol>
<li>如果模块不存在<code>__doc__</code>则创建一个新的</li>
<li>如果模块不存在<code>__annotations__</code>则创建一个新的</li>
<li>设置全局编译器状态中的文件名为传入的文件名</li>
<li>将编译器的内存区域设置为解释器使用的那个</li>
<li>将模块中所有的<code>__future__</code>标识复制至全局编译器状态中</li>
<li>合并命令行或环境变量中提供的运行时标识</li>
<li>启用编译器中所有的<code>__future__</code></li>
<li>设置编译的优化级别为参数提供的，或者是默认的</li>
<li>根据模块对象构建符号表</li>
<li>运行编译器，返回代码对象</li>
<li>编译器释放编译过程中所分配的所有内存</li>
</ol>
<p>核心代码:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>PyCodeObject <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PyAST_CompileObject</span>(mod_ty mod, PyObject <span style="color:#f92672">*</span>filename, PyCompilerFlags <span style="color:#f92672">*</span>flags,
</span></span><span style="display:flex;"><span>                   <span style="color:#66d9ef">int</span> optimize, PyArena <span style="color:#f92672">*</span>arena)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> compiler c;
</span></span><span style="display:flex;"><span>    PyCodeObject <span style="color:#f92672">*</span>co <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>__doc__) {
</span></span><span style="display:flex;"><span>        __doc__ <span style="color:#f92672">=</span> PyUnicode_InternFromString(<span style="color:#e6db74">&#34;__doc__&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>__annotations__) {
</span></span><span style="display:flex;"><span>        __annotations__ <span style="color:#f92672">=</span> PyUnicode_InternFromString(<span style="color:#e6db74">&#34;__annotations__&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    c.c_filename <span style="color:#f92672">=</span> filename;
</span></span><span style="display:flex;"><span>    c.c_arena <span style="color:#f92672">=</span> arena;
</span></span><span style="display:flex;"><span>    c.c_future <span style="color:#f92672">=</span> PyFuture_FromASTObject(mod, filename);
</span></span><span style="display:flex;"><span>    merged <span style="color:#f92672">=</span> c.c_future<span style="color:#f92672">-&gt;</span>ff_features <span style="color:#f92672">|</span> flags<span style="color:#f92672">-&gt;</span>cf_flags;
</span></span><span style="display:flex;"><span>    c.c_future<span style="color:#f92672">-&gt;</span>ff_features <span style="color:#f92672">=</span> merged;
</span></span><span style="display:flex;"><span>    flags<span style="color:#f92672">-&gt;</span>cf_flags <span style="color:#f92672">=</span> merged;
</span></span><span style="display:flex;"><span>    c.c_flags <span style="color:#f92672">=</span> flags;
</span></span><span style="display:flex;"><span>    c.c_optimize <span style="color:#f92672">=</span> (optimize <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">?</span> config<span style="color:#f92672">-&gt;</span>optimization_level : optimize;
</span></span><span style="display:flex;"><span>    c.c_nestlevel <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    c.c_do_not_emit_bytecode <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    co <span style="color:#f92672">=</span> compiler_mod(<span style="color:#f92672">&amp;</span>c, mod);
</span></span><span style="display:flex;"><span> finally:
</span></span><span style="display:flex;"><span>    compiler_free(<span style="color:#f92672">&amp;</span>c);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> co;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<h4 id="future标识和编译标识">
  Future标识和编译标识
  <a class="anchor" href="#future%e6%a0%87%e8%af%86%e5%92%8c%e7%bc%96%e8%af%91%e6%a0%87%e8%af%86">#</a>
</h4>
<p>编译器运行前，有两种标识可以切换编译器内部的功能。</p>
<p>第一种是通过命令行或环境变量设置的解释器状态，例如命令行执行时添加<code>-O</code>标志(也可以通过设置环境变量PYTHONOPTIMIZE=1达到同样效果)，则所有的断言语句都会被编译器忽略掉，这些断言语句往往是调试时才需要。</p>
<p>另一种是实际的源代码中加入future语句，例如<code>from __future__ import annotations</code>，它是Python3.7新加入的，因为使用type hints时可能类型还没有被创建，该语句可以让类型注解延迟求值。</p>
<h4 id="符号表">
  符号表
  <a class="anchor" href="#%e7%ac%a6%e5%8f%b7%e8%a1%a8">#</a>
</h4>
<p>符号表为编译器提供了一个查找引用全局变量、局部变量等的作用域，它的结构是这样的:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> symtable {
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>st_filename;          <span style="color:#75715e">/* name of file being compiled, decoded from the filesystem encoding */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _symtable_entry <span style="color:#f92672">*</span>st_cur; <span style="color:#75715e">/* current symbol table entry */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _symtable_entry <span style="color:#f92672">*</span>st_top; <span style="color:#75715e">/* symbol table entry for module */</span>
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>st_blocks;            <span style="color:#75715e">/* dict: map AST node addresses to symbol table entries */</span>
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>st_stack;             <span style="color:#75715e">/* list: stack of namespace info */</span>
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>st_global;            <span style="color:#75715e">/* borrowed ref to st_top-&gt;ste_symbols */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> st_nblocks;                 <span style="color:#75715e">/* number of blocks used. kept for consistency with the corresponding compiler structure */</span>
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>st_private;           <span style="color:#75715e">/* name of current class or NULL */</span>
</span></span><span style="display:flex;"><span>    PyFutureFeatures <span style="color:#f92672">*</span>st_future;    <span style="color:#75715e">/* module&#39;s future features that affect the symbol table */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> recursion_depth;            <span style="color:#75715e">/* current recursion depth */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> recursion_limit;            <span style="color:#75715e">/* recursion limit */</span>
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
其中的一些API通过Python的标准库symtable模块可以调用:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">import</span> symtable
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> s <span style="color:#f92672">=</span> symtable<span style="color:#f92672">.</span>symtable(<span style="color:#e6db74">&#39;b + 1&#39;</span>, filename<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;test.py&#39;</span>, compile_type<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;eval&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> [symbol<span style="color:#f92672">.</span>__dict__ <span style="color:#66d9ef">for</span> symbol <span style="color:#f92672">in</span> s<span style="color:#f92672">.</span>get_symbols()]
</span></span><span style="display:flex;"><span>[{<span style="color:#e6db74">&#39;_Symbol__name&#39;</span>: <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;_Symbol__flags&#39;</span>: <span style="color:#ae81ff">6160</span>, <span style="color:#e6db74">&#39;_Symbol__scope&#39;</span>: <span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;_Symbol__namespaces&#39;</span>: ()}]</span></span></code></pre></div>
核心的C代码在<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/symtable.c#L262">PySymtable_BuildObject()</a>函数中，它也是依据传入的mod_ty类型的不同使用不同的访问函数，有<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/symtable.c#L1176">symtable_visit_stmt()</a>、symtable_visit_expr()等，这些访问函数里面也是一个巨长的switch语句对应着定义在Parser/Python.asdl中的每种语句类型以及各自的逻辑。例如对于一个函数定义，它需要做的特殊处理有:检测递归深度超过限制则引发异常、将函数名称加入到局部变量中、解析顺序参数和关键字参数的默认值、解析参数和返回值的类型注释、解析函数的装饰器等等。</p>
<h4 id="核心编译过程">
  核心编译过程
  <a class="anchor" href="#%e6%a0%b8%e5%bf%83%e7%bc%96%e8%af%91%e8%bf%87%e7%a8%8b">#</a>
</h4>
<p>现在PyAST_CompileObject()有了一个编译器状态、一个符号表、一个模块形式的AST，真正的编译才开始。这个阶段的目标是将state、symtable、AST转化为CFG，以及捕获逻辑和代码异常并抛出。</p>
<p>我们可以通过Python提供的内置函数compile()完成编译过程，传入的是表达式则mode选择eval，传入类、方法、模块等mode要选择exec，它返回的是一个代码对象:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#ae81ff">1</span>]: compile(<span style="color:#e6db74">&#34;a+1&#34;</span>, <span style="color:#e6db74">&#34;a.py&#34;</span>, mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;eval&#34;</span>)                     
</span></span><span style="display:flex;"><span>Out[<span style="color:#ae81ff">1</span>]: <span style="color:#f92672">&lt;</span>code object <span style="color:#f92672">&lt;</span>module<span style="color:#f92672">&gt;</span> at <span style="color:#ae81ff">0x1120e58a0</span>, file <span style="color:#e6db74">&#34;a.py&#34;</span>, line <span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>In [<span style="color:#ae81ff">2</span>]: _<span style="color:#f92672">.</span>co_code                      
</span></span><span style="display:flex;"><span>Out[<span style="color:#ae81ff">2</span>]: <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;e</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">d</span><span style="color:#ae81ff">\x00\x17\x00</span><span style="color:#e6db74">S</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;</span></span></span></code></pre></div></p>
<p>怎样得到这个代码对象的，实际就是<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/compile.c#L1782">compiler_mod()</a>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> PyCodeObject <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">compiler_mod</span>(<span style="color:#66d9ef">struct</span> compiler <span style="color:#f92672">*</span>c, mod_ty mod)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    PyCodeObject <span style="color:#f92672">*</span>co;
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (mod<span style="color:#f92672">-&gt;</span>kind) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> Module_kind:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>compiler_body(c, mod<span style="color:#f92672">-&gt;</span>v.Module.body)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> Interactive_kind:
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> Expression_kind:
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> Suite_kind:
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    co <span style="color:#f92672">=</span> assemble(c, addNone);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> co;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<p><a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/compile.c#L1743">compiler_body()</a>循环访问模块中的每条语句，和symtable的工作方式类似:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">compiler_body</span>(<span style="color:#66d9ef">struct</span> compiler <span style="color:#f92672">*</span>c, asdl_seq <span style="color:#f92672">*</span>stmts)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    stmt_ty st;
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>docstring;
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (; i <span style="color:#f92672">&lt;</span> asdl_seq_LEN(stmts); i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        VISIT(c, stmt, (stmt_ty)asdl_seq_GET(stmts, i));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Include/asdl.h#L32">asdl_seq_GET()</a>查看每个AST节点的类型得到语句的类型，然后通过宏，VISIT调用compiler_visit_*函数:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define VISIT(C, TYPE, V) {\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    if (!compiler_visit_ ## TYPE((C), (V))) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        return 0; \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}</span></span></span></code></pre></div>
对于语句类型来说，就是到<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/compile.c#L3310">compiler_visit_stmt()</a>函数，然后具体每条语句也有自己的编译函数:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">compiler_visit_stmt</span>(<span style="color:#66d9ef">struct</span> compiler <span style="color:#f92672">*</span>c, stmt_ty s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Py_ssize_t i, n;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Always assign a lineno to the next instruction for a stmt. */</span>
</span></span><span style="display:flex;"><span>    c<span style="color:#f92672">-&gt;</span>u<span style="color:#f92672">-&gt;</span>u_lineno <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>lineno;
</span></span><span style="display:flex;"><span>    c<span style="color:#f92672">-&gt;</span>u<span style="color:#f92672">-&gt;</span>u_col_offset <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>col_offset;
</span></span><span style="display:flex;"><span>    c<span style="color:#f92672">-&gt;</span>u<span style="color:#f92672">-&gt;</span>u_lineno_set <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (s<span style="color:#f92672">-&gt;</span>kind) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> FunctionDef_kind:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> compiler_function(c, s, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> ClassDef_kind:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> compiler_class(c, s);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> For_kind:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> compiler_for(c, s);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<p>我们以for语句为例:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> iterable:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># block</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:  <span style="color:#75715e"># optional if iterable is False</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># block</span></span></span></code></pre></div>
对于一个For类型的语句，它会调用compiler_for()。所有的语句和表达式类型都有相应的compiler_*()函数，大多数类型直接在其中创建字节码，也有些比较复杂的语句类型还会调用其他函数。许多语句都可能会有子句，for循环在赋值和迭代时也可能遇到复杂的表达式。compiler_for()将blocks发送给编译器状态，这些blocks包含指令(指令对应着opcode)，参数，目标block(如果是跳转指令)，以及行号:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> basicblock_ {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> basicblock_ <span style="color:#f92672">*</span>b_list; <span style="color:#75715e">//指向编译器状态的block列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> b_iused;                <span style="color:#75715e">// 已经使用的指令数组的容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> b_ialloc;               <span style="color:#75715e">// 分配给指令数组的容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> instr <span style="color:#f92672">*</span>b_instr;      <span style="color:#75715e">// 指向指令数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> basicblock_ <span style="color:#f92672">*</span>b_next; <span style="color:#75715e">// 指向下一个block
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> b_seen : <span style="color:#ae81ff">1</span>;        <span style="color:#75715e">// 当编译器深度优先遍历时，是否已看到该block
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> b_return : <span style="color:#ae81ff">1</span>;      <span style="color:#75715e">// 如果该block有返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> b_startdepth;           <span style="color:#75715e">// 该block的栈深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> b_offset;               <span style="color:#75715e">// 汇编程序的指令偏移量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} basicblock;</span></span></code></pre></div>
对于For类型语句的解析，编译器进行了15步操作:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">compiler_for</span>(<span style="color:#66d9ef">struct</span> compiler <span style="color:#f92672">*</span>c, stmt_ty s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    basicblock <span style="color:#f92672">*</span>start, <span style="color:#f92672">*</span>cleanup, <span style="color:#f92672">*</span>end;
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> compiler_new_block(c);                       <span style="color:#75715e">// 1.创建start代码块，分配内存并创建一个basicblock指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cleanup <span style="color:#f92672">=</span> compiler_new_block(c);                     <span style="color:#75715e">// 2.创建cleanup代码块
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    end <span style="color:#f92672">=</span> compiler_new_block(c);                         <span style="color:#75715e">// 3.创建end代码块
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (start <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> end <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> cleanup <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>compiler_push_fblock(c, FOR_LOOP, start, end))  <span style="color:#75715e">// 4.将frame block压栈，类型是FOR_LOOP，入口block是start，退出block是end
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    VISIT(c, expr, s<span style="color:#f92672">-&gt;</span>v.For.iter);                       <span style="color:#75715e">// 5.访问迭代器表达式，该表达式对迭代器添加操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ADDOP(c, GET_ITER);                                  <span style="color:#75715e">// 6.将GET_ITER操作添加到编译器状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    compiler_use_next_block(c, start);                   <span style="color:#75715e">// 7.切回start块
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ADDOP_JREL(c, FOR_ITER, cleanup);                    <span style="color:#75715e">// 8.调用compiler_addop_j()使用cleanup块的参数添加FOR_ITER操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    VISIT(c, expr, s<span style="color:#f92672">-&gt;</span>v.For.target);                     <span style="color:#75715e">// 9.访问目标并将特殊代码(如元组解包)添加至start块
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    VISIT_SEQ(c, stmt, s<span style="color:#f92672">-&gt;</span>v.For.body);                   <span style="color:#75715e">// 10.访问for循环主体中的每条语句
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ADDOP_JABS(c, JUMP_ABSOLUTE, start);                 <span style="color:#75715e">// 11.调用compiler_addop_j()添加JUMP_ABSOLUTE操作，为了循环体执行完跳回循环开始的地方
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    compiler_use_next_block(c, cleanup);                 <span style="color:#75715e">// 12.移至cleanup块
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    compiler_pop_fblock(c, FOR_LOOP, start);             <span style="color:#75715e">// 13.将FOR_LOOP这个frame block弹出栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    VISIT_SEQ(c, stmt, s<span style="color:#f92672">-&gt;</span>v.For.orelse);                 <span style="color:#75715e">// 14.访问for循环的else中的语句部分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    compiler_use_next_block(c, end);                     <span style="color:#75715e">// 15.使用end block
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<p>当这一步执行完，编译器就有了一组frame block，其中的每一个都包含一组指令以及指向下一个block的指针。</p>
<h3 id="汇编器">
  汇编器
  <a class="anchor" href="#%e6%b1%87%e7%bc%96%e5%99%a8">#</a>
</h3>
<p>通过编译器状态，汇编器对block进行深度优先搜索，并把它们的指令合并为一个字节码序列。核心方法<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/compile.c#L5971">assemble()</a>的主要任务有:</p>
<ul>
<li>计算出有多少个block，以便于分配内存</li>
<li>确保所有最后的block都返回None，这也是每个方法都返回None不管它有没有return语句的原因</li>
<li>解决所有的标记为相对跳转语句的偏移量</li>
<li>调用dfs()方法去深度优先搜索执行block</li>
<li>把所有的指令提交给编译器</li>
<li>调用makecode()方法并传入编译器状态，用来生成PyCodeObject</li>
</ul>
<p><a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/compile.c#L5397">dfs()</a>方法是通过每一个block的b_next指针进行深度优先遍历的，遍历过的会标记该block的b_seen，然后按相反的顺序把它们添加至汇编器的**a_postorder列表中。</p>
<h3 id="创建代码对象">
  创建代码对象
  <a class="anchor" href="#%e5%88%9b%e5%bb%ba%e4%bb%a3%e7%a0%81%e5%af%b9%e8%b1%a1">#</a>
</h3>
<p><a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/compile.c#L5854">makecode()</a>方法通过编译器状态、一些汇编器的属性，然后调用<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Objects/codeobject.c#L246">PyCode_New()</a>把它们放在一个PyCodeObject中:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> PyCodeObject <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">makecode</span>(<span style="color:#66d9ef">struct</span> compiler <span style="color:#f92672">*</span>c, <span style="color:#66d9ef">struct</span> assembler <span style="color:#f92672">*</span>a)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    consts <span style="color:#f92672">=</span> consts_dict_keys_inorder(c<span style="color:#f92672">-&gt;</span>u<span style="color:#f92672">-&gt;</span>u_consts);
</span></span><span style="display:flex;"><span>    names <span style="color:#f92672">=</span> dict_keys_inorder(c<span style="color:#f92672">-&gt;</span>u<span style="color:#f92672">-&gt;</span>u_names, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    varnames <span style="color:#f92672">=</span> dict_keys_inorder(c<span style="color:#f92672">-&gt;</span>u<span style="color:#f92672">-&gt;</span>u_varnames, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    cellvars <span style="color:#f92672">=</span> dict_keys_inorder(c<span style="color:#f92672">-&gt;</span>u<span style="color:#f92672">-&gt;</span>u_cellvars, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    freevars <span style="color:#f92672">=</span> dict_keys_inorder(c<span style="color:#f92672">-&gt;</span>u<span style="color:#f92672">-&gt;</span>u_freevars, PyTuple_GET_SIZE(cellvars));
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    flags <span style="color:#f92672">=</span> compute_code_flags(c);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (flags <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> error;
</span></span><span style="display:flex;"><span>    bytecode <span style="color:#f92672">=</span> PyCode_Optimize(a<span style="color:#f92672">-&gt;</span>a_bytecode, consts, names, a<span style="color:#f92672">-&gt;</span>a_lnotab);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    co <span style="color:#f92672">=</span> PyCode_NewWithPosOnlyArgs(posonlyargcount<span style="color:#f92672">+</span>posorkeywordargcount,
</span></span><span style="display:flex;"><span>                                   posonlyargcount, kwonlyargcount, nlocals_int, 
</span></span><span style="display:flex;"><span>                                   maxdepth, flags, bytecode, consts, names,
</span></span><span style="display:flex;"><span>                                   varnames, freevars, cellvars, c<span style="color:#f92672">-&gt;</span>c_filename,
</span></span><span style="display:flex;"><span>                                   c<span style="color:#f92672">-&gt;</span>u<span style="color:#f92672">-&gt;</span>u_name, c<span style="color:#f92672">-&gt;</span>u<span style="color:#f92672">-&gt;</span>u_firstlineno, a<span style="color:#f92672">-&gt;</span>a_lnotab);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> co;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
变量名称、常量等都是code对象的属性，此外<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/peephole.c#L230">PyCode_Optimize()</a>方法还对字节码进行了一定程度的优化，这个优化器叫窥孔优化器，被放在一个专门的<code>Python/peephole.c</code>中，它会仔细检查每条指令，并在合适的情况下将部分指令替换为其他指令。例如其中有一项优化叫常量展开，它能把语句<code>a = 1 + 5</code>优化为<code>a = 6</code>。</p>
<h3 id="字节码">
  字节码
  <a class="anchor" href="#%e5%ad%97%e8%8a%82%e7%a0%81">#</a>
</h3>
<p>字节码被存储在代码对象(即<code>__code__</code>)的<code>co_code</code>中，以一个函数为例:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add</span>(x, y):                                                                                          
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>     z <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> y
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>     <span style="color:#66d9ef">return</span> z
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">.</span>join(str(b) <span style="color:#66d9ef">for</span> b <span style="color:#f92672">in</span> add<span style="color:#f92672">.</span>__code__<span style="color:#f92672">.</span>co_code)
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;124 0 124 1 23 0 125 2 124 2 83 0&#39;</span></span></span></code></pre></div>
字节码中每两个数字为一组，第一个为指令，第二个为参数，指令对应的二进制数可以在CPython源码中找到:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">&lt;!--</span> cpython<span style="color:#f92672">/</span>Include<span style="color:#f92672">/</span>opcode.h <span style="color:#f92672">--&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define BINARY_ADD               23
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define RETURN_VALUE             83
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define LOAD_FAST               124
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define STORE_FAST              125</span></span></span></code></pre></div>
这就可以和dis的输出结果对应起来:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> dis<span style="color:#f92672">.</span>dis(add)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">!</span><span style="color:#f92672">--</span> 源码行    偏移量 指令           参数(目标对象)  <span style="color:#f92672">--&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">2</span>           <span style="color:#ae81ff">0</span> LOAD_FAST                <span style="color:#ae81ff">0</span> (x)
</span></span><span style="display:flex;"><span>              <span style="color:#ae81ff">2</span> LOAD_FAST                <span style="color:#ae81ff">1</span> (y)
</span></span><span style="display:flex;"><span>              <span style="color:#ae81ff">4</span> BINARY_ADD
</span></span><span style="display:flex;"><span>              <span style="color:#ae81ff">6</span> STORE_FAST               <span style="color:#ae81ff">2</span> (z)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">3</span>           <span style="color:#ae81ff">8</span> LOAD_FAST                <span style="color:#ae81ff">2</span> (z)
</span></span><span style="display:flex;"><span>             <span style="color:#ae81ff">10</span> RETURN_VALUE</span></span></code></pre></div>
指令所对应的源码行这个信息其实保存在代码对象的两个相关属性中，<code>co_firstlineno</code>用来存储该段代码起始的行号，<code>co_lnotab</code>由每两个数字一组组成，前一个为字节码偏移的位置，后一个为相对前一组行号的增量。每条字节码指令代表的意义可通过官方文档<a href="https://docs.python.org/3/library/dis.html">此处</a>查询到。</p>
<h2 id="执行">
  执行
  <a class="anchor" href="#%e6%89%a7%e8%a1%8c">#</a>
</h2>
<p>执行的入口是在<code>Python/pythonrun.c</code>的<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/pythonrun.c#L1094">run_eval_code_obj()</a>函数中，它需要一个code对象，不管是从.pyc文件中来的还是一步步编译来的。然后该函数将globals、locals、PyArena和编译好的PyCodeObject传给<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/ceval.c#L716">PyEval_EvalCode()</a>。</p>
<p>PyEval_EvalCode()是执行一个code对象的公共API，它会在执行栈的顶部构建一个执行frame。一个frame对象的结构像这样:</p>
<p><img src="./images/PyFrameObject.png" alt="PyFrameObject" /></p>
<h3 id="构建frame">
  构建frame
  <a class="anchor" href="#%e6%9e%84%e5%bb%baframe">#</a>
</h3>
<p>构建第一个执行frame需要很多步，都在<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/ceval.c#L4045">_PyEval_EvalCodeWithName()</a>方法中。它的3个参数通过PyEval_EvalCode()传入，即:</p>
<ul>
<li>_co，PyCodeObject对象</li>
<li>globals，PyDict对象，存储变量名及它们的值</li>
<li>locals，PyDict对象，存储变量名及它们的值</li>
</ul>
<p>其他参数都是可选的:</p>
<ul>
<li>args，PyTuple对象，顺序存储了位置参数</li>
<li>argcount，位置参数的个数</li>
<li>kwnames，列表，关键字参数的名称</li>
<li>kwargs，列表，关键字参数的值</li>
<li>kwcount，关键字参数的个数</li>
<li>defs，列表，位置参数的默认值</li>
<li>defcount，位置参数的默认值的个数</li>
<li>kwdefs，字典，存储关键字参数的默认值</li>
<li>closure，闭包，之后合并到code对象的co_freevars字段</li>
<li>name，创建生成器、协程时使用</li>
<li>qualname，创建生成器、协程时使用</li>
</ul>
<p>其具体的步骤可分为:</p>
<ol>
<li>构建线程状态，在执行一个frame之前，首先需要在线程中引用它。CPython可以在一个解释器中随时运行多个线程，这些线程通过链表放在解释器状态中。线程结构称为<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Include/pystate.h#L23">PyThreadState</a>，在整个ceval.c中有很多地方引用它。</li>
<li>构建frames</li>
<li>将关键字参数转换为一个字典。如果函数的定义中包含<code>**kwargs</code>形式的关键字参数，则创建一个新的字典，并将<code>kwargs</code>作为变量名指向该字典</li>
<li>将位置参数转换为变量。如果函数的定义中包含位置参数，需要将它们设为本地局部变量。</li>
<li>打包位置参数至<code>*args</code>，如果函数的定义中包含有<code>*args</code>，则创建一个元组，并将<code>args</code>作为局部变量名指向它</li>
<li>载入关键字参数</li>
<li>添加缺失的位置参数</li>
<li>添加缺失的关键字参数</li>
<li>闭包中的变量名称添加到code对象的自由变量列表中</li>
<li>创建生成器、协程以及异步生成器</li>
</ol>
<p>最终，该函数调用PyEval_EvalFrameEx()去执行这个新创建的frame。</p>
<h3 id="执行frame">
  执行frame
  <a class="anchor" href="#%e6%89%a7%e8%a1%8cframe">#</a>
</h3>
<p>在之前的编译器和AST小节中，我们知道了code对象包含了一个待执行的二进制编码的字节码，以及变量列表和符号表。局部变量和全局变量都是运行时根据函数、模块或者代码块的调用方式决定的，这些信息通过_PyEval_EvalCodeWithName()添加到frame中。此外，frame还有一些其他用途，例如协程装饰器，它可以动态生成一个frame并把目标作为变量。</p>
<p>frame在<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/ceval.c#L745">_PyEval_EvalFrameDefault()</a>内的3000多行代码的主循环中执行。这个函数是整个CPython的核心，它包含了数十年的变化，即使是一行代码的改变也可能对整个CPython的性能产生重大影响。</p>
<p>我们可以在Python3.7以上的版本中通过在当前线程启用追踪来跟踪每一步frame的执行，例如如下代码可以打印每一步反汇编的opcode，调用了哪个code对象，执行至第几行，返回值是什么:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> dis
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> traceback
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> io
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">trace</span>(frame, event, args):
</span></span><span style="display:flex;"><span>   frame<span style="color:#f92672">.</span>f_trace_opcodes <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>   stack <span style="color:#f92672">=</span> traceback<span style="color:#f92672">.</span>extract_stack(frame)
</span></span><span style="display:flex;"><span>   pad <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;   &#34;</span><span style="color:#f92672">*</span>len(stack) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;|&#34;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> event <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;opcode&#39;</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">with</span> io<span style="color:#f92672">.</span>StringIO() <span style="color:#66d9ef">as</span> out:
</span></span><span style="display:flex;"><span>         dis<span style="color:#f92672">.</span>disco(frame<span style="color:#f92672">.</span>f_code, frame<span style="color:#f92672">.</span>f_lasti, file<span style="color:#f92672">=</span>out)
</span></span><span style="display:flex;"><span>         lines <span style="color:#f92672">=</span> out<span style="color:#f92672">.</span>getvalue()<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>         [print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>pad<span style="color:#e6db74">}{</span>l<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>) <span style="color:#66d9ef">for</span> l <span style="color:#f92672">in</span> lines]
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">elif</span> event <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;call&#39;</span>:
</span></span><span style="display:flex;"><span>      print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>pad<span style="color:#e6db74">}</span><span style="color:#e6db74">Calling </span><span style="color:#e6db74">{</span>frame<span style="color:#f92672">.</span>f_code<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">elif</span> event <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;return&#39;</span>:
</span></span><span style="display:flex;"><span>      print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>pad<span style="color:#e6db74">}</span><span style="color:#e6db74">Returning </span><span style="color:#e6db74">{</span>args<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">elif</span> event <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;line&#39;</span>:
</span></span><span style="display:flex;"><span>      print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>pad<span style="color:#e6db74">}</span><span style="color:#e6db74">Changing line to </span><span style="color:#e6db74">{</span>frame<span style="color:#f92672">.</span>f_lineno<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>      print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>pad<span style="color:#e6db74">}{</span>frame<span style="color:#e6db74">}</span><span style="color:#e6db74"> (</span><span style="color:#e6db74">{</span>event<span style="color:#e6db74">}</span><span style="color:#e6db74"> - </span><span style="color:#e6db74">{</span>args<span style="color:#e6db74">}</span><span style="color:#e6db74">)&#34;</span>)
</span></span><span style="display:flex;"><span>   print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>pad<span style="color:#e6db74">}</span><span style="color:#e6db74">----------------------------------&#34;</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> trace
</span></span><span style="display:flex;"><span>sys<span style="color:#f92672">.</span>settrace(trace)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Run some code for a demo</span>
</span></span><span style="display:flex;"><span>eval(<span style="color:#e6db74">&#39;&#34;-&#34;.join([letter for letter in &#34;hello&#34;])&#39;</span>)</span></span></code></pre></div></p>
<h3 id="值栈">
  值栈
  <a class="anchor" href="#%e5%80%bc%e6%a0%88">#</a>
</h3>
<p>在核心执行循环逻辑内，一个存储值的栈被创建，它存储了一组指针指向PyObject实例。例如，我们可以压栈:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>PyObject <span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> PyLong_FromLong(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>PyObject <span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> PyLong_FromLong(<span style="color:#ae81ff">20</span>);
</span></span><span style="display:flex;"><span>PUSH(a);
</span></span><span style="display:flex;"><span>PUSH(b);</span></span></code></pre></div>
运行前后如图:
<img src="./images/value_stack.png" alt="" />
有很多字节操作码opcode是直接操作栈的，例如PUSH()、POP()、PEEK()、DUP_TOP()、ROT_TWO()等。所有的opcode都会对栈有一个影响，这被定义在<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/compile.c#L878">stack_effect()</a>方法中。</p>
<h4 id="举例向list中添加一个元素">
  举例:向list中添加一个元素
  <a class="anchor" href="#%e4%b8%be%e4%be%8b%e5%90%91list%e4%b8%ad%e6%b7%bb%e5%8a%a0%e4%b8%80%e4%b8%aa%e5%85%83%e7%b4%a0">#</a>
</h4>
<p>在Python中，我们通过append()方法添加元素:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>my_list <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>my_list<span style="color:#f92672">.</span>append(obj)</span></span></code></pre></div>
在CPython中，这个操作对应着两个操作。LOAD_FAST将对象obj从frame的局部变量列表中加载到值栈的顶部，然后LIST_APPEND操作添加这个对象至list中。我们先来看LOAD_FAST:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> ... 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> TARGET(LOAD_FAST)<span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 变量的指针都存储在fastlocals区域，它是PyFrame的f_localsplus的拷贝。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// oparg是fastlocals数组的索引，也就是查找局部变量是不需要根据变量名称来查找的。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        PyObject <span style="color:#f92672">*</span>value <span style="color:#f92672">=</span> GETLOCAL(oparg);                 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (value <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            format_exc_check_arg(
</span></span><span style="display:flex;"><span>                PyExc_UnboundLocalError,
</span></span><span style="display:flex;"><span>                UNBOUNDLOCAL_ERROR_MSG,
</span></span><span style="display:flex;"><span>                PyTuple_GetItem(co<span style="color:#f92672">-&gt;</span>co_varnames, oparg));
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果变量不存在，则引发未绑定局部变量的错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">goto</span> error;                                    
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 增加value(这里就是obj)的引用计数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Py_INCREF(value);  
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 把obj的指针压入值栈                               
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        PUSH(value);      
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果启用了trace，则循环再次遍历(带着所有的tracing)；如果没启用，则跳回循环顶部执行下一条指令                                 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        FAST_DISPATCH();                                   
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> ...</span></span></code></pre></div>
接着，LIST_APPEND是通过POP()获取到元素obj的指针，PEEK(oparg)获取到my_list的指针，然后使用CPython列表的C的API即PyList_Append()将元素添加进去的:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> TARGET(LIST_APPEND)<span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>            PyObject <span style="color:#f92672">*</span>v <span style="color:#f92672">=</span> POP();
</span></span><span style="display:flex;"><span>            PyObject <span style="color:#f92672">*</span>list <span style="color:#f92672">=</span> PEEK(oparg);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> err;
</span></span><span style="display:flex;"><span>            err <span style="color:#f92672">=</span> PyList_Append(list, v);
</span></span><span style="display:flex;"><span>            Py_DECREF(v);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (err <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">goto</span> error;
</span></span><span style="display:flex;"><span>            PREDICT(JUMP_ABSOLUTE);
</span></span><span style="display:flex;"><span>            DISPATCH();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span> ...</span></span></code></pre></div>
其后的PREDICT(JUMP_ABSOLUTE)属于一种预测手段，它会猜下一个opcode可能是JUMP_ABSOLUTE，这样CPU就可以直接跳转过去而不需要重新跑一遍主循环了。</p>
<h4 id="调用追踪">
  调用追踪
  <a class="anchor" href="#%e8%b0%83%e7%94%a8%e8%bf%bd%e8%b8%aa">#</a>
</h4>
<p>有一些指令例如CALL_FUNCTION、CALL_METHOD，它们的参数opcode实际上是另一个已经编译好的函数。那么另一个frame就会压入当前线程的执行栈帧中，主循环会先把这个新的函数运行完以后在运行原函数。每次新的frame创建时，它会有一个f_back属性就是指向当前的frame。</p>
<p>例如有这样一段python代码:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">function2</span>():
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">RuntimeError</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">function1</span>():
</span></span><span style="display:flex;"><span>  function2()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>  function1()</span></span></code></pre></div>
它运行后:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ ./python.exe example_stack.py
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Traceback <span style="color:#f92672">(</span>most recent call last<span style="color:#f92672">)</span>:
</span></span><span style="display:flex;"><span>  File <span style="color:#e6db74">&#34;example_stack.py&#34;</span>, line 8, in &lt;module&gt;
</span></span><span style="display:flex;"><span>    function1<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>  File <span style="color:#e6db74">&#34;example_stack.py&#34;</span>, line 5, in function1
</span></span><span style="display:flex;"><span>    function2<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>  File <span style="color:#e6db74">&#34;example_stack.py&#34;</span>, line 2, in function2
</span></span><span style="display:flex;"><span>    raise RuntimeError
</span></span><span style="display:flex;"><span>RuntimeError</span></span></code></pre></div>
这些调用追踪信息，实际上可以通过标准库traceback的walk_stack()函数得到:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">walk_stack</span>(f):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;Walk a stack yielding the frame and line number for each frame.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    This will follow f.f_back from the given frame. If no frame is given, the
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    current stack is used. Usually used with StackSummary.extract.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> f <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        f <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>_getframe()<span style="color:#f92672">.</span>f_back<span style="color:#f92672">.</span>f_back
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> f <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">yield</span> f, f<span style="color:#f92672">.</span>f_lineno
</span></span><span style="display:flex;"><span>        f <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>f_back</span></span></code></pre></div>
它先通过Python的API即sys._getframe()得到当前的frame，然后找它的f_back.f_back是为了跳过其本身walk_stack()函数和其父亲print_trace()函数。</p>
<p>用图形来表达这个调用追踪关系就是:
<img src="./images/stackframe.png" alt="" /></p>
<h2 id="cpython中的对象">
  CPython中的对象
  <a class="anchor" href="#cpython%e4%b8%ad%e7%9a%84%e5%af%b9%e8%b1%a1">#</a>
</h2>
<p>在Python里所有的对象继承自<code>object</code>，但在C里，由于C没有面向对象的特性，我们看到的都是对<code>PyObject*</code>的引用，PyObject实际上是一个Python对象内存起始处的数据结构。</p>
<h3 id="基础对象">
  基础对象
  <a class="anchor" href="#%e5%9f%ba%e7%a1%80%e5%af%b9%e8%b1%a1">#</a>
</h3>
<p>一个Python对象可以认为是由两部分组成的:</p>
<ol>
<li>核心数据模型，带有指向其已编译的方法的指针</li>
<li>包含自定义属性和方法的字典</li>
</ol>
<p>核心数据模型是在PyTypeObject中定义的，而它们的方法是在如下位置定义的:</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Objects/object.c</td>
<td>内置类型</td>
</tr>
<tr>
<td>Objects/boolobject.c</td>
<td>bool</td>
</tr>
<tr>
<td>Objects/bytearrayobject.c</td>
<td>byte[]</td>
</tr>
<tr>
<td>Objects/bytesobjects.c</td>
<td>bytes</td>
</tr>
<tr>
<td>Objects/classobject.c</td>
<td>元编程的抽象类</td>
</tr>
<tr>
<td>Objects/complexobject.c</td>
<td>复数</td>
</tr>
<tr>
<td>Objects/iterobject.c</td>
<td>迭代器</td>
</tr>
<tr>
<td>Objects/listobject.c</td>
<td>列表</td>
</tr>
<tr>
<td>Objects/longobject.c</td>
<td>长整数</td>
</tr>
<tr>
<td>Objects/memoryobject.c</td>
<td>基础内存类型</td>
</tr>
<tr>
<td>Objects/methodobject.c</td>
<td>类方法</td>
</tr>
<tr>
<td>Objects/moduleobject.c</td>
<td>模块</td>
</tr>
<tr>
<td>Objects/namespaceobject.c</td>
<td>名字空间</td>
</tr>
<tr>
<td>Objects/odictobject.c</td>
<td>有序字典</td>
</tr>
<tr>
<td>Objects/rangeobject.c</td>
<td>range生成器</td>
</tr>
<tr>
<td>Objects/setobject.c</td>
<td>set</td>
</tr>
<tr>
<td>Objects/sliceobject.c</td>
<td>切片</td>
</tr>
<tr>
<td>Objects/structseq.c</td>
<td>struct.Struct二进制</td>
</tr>
<tr>
<td>Objects/tupleobject.c</td>
<td>元组</td>
</tr>
<tr>
<td>Objects/typeobject.c</td>
<td>type类</td>
</tr>
<tr>
<td>Objects/unicodeobject.c</td>
<td>str</td>
</tr>
<tr>
<td>Objects/weakrefobject.c</td>
<td>弱引用</td>
</tr>
</tbody>
</table>
<h3 id="布尔和整数">
  布尔和整数
  <a class="anchor" href="#%e5%b8%83%e5%b0%94%e5%92%8c%e6%95%b4%e6%95%b0">#</a>
</h3>
<p>布尔类是内置类型中最直接的实现，它继承自long，并在解释器中创建了常量Py_True和Py_False。在Objects/boolobject.c中我们可以看到帮助函数通过数字来创建布尔类型的实例:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>PyObject <span style="color:#f92672">*</span><span style="color:#a6e22e">PyBool_FromLong</span>(<span style="color:#66d9ef">long</span> ok)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>result;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ok)
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> Py_True;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> Py_False;
</span></span><span style="display:flex;"><span>    Py_INCREF(result);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
此外，也实现了一些and、xor、or之类的帮助函数，但加法、减法、除法是没有从继承的long中实现的。</p>
<p>检测<code>a and b</code>的结果是先检测a和b是否为布尔值，然后检查它们是否有对Py_True的引用，都不是的话则把它们强制转化为数字进行数字之间的and操作:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> PyObject <span style="color:#f92672">*</span><span style="color:#a6e22e">bool_and</span>(PyObject <span style="color:#f92672">*</span>a, PyObject <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>PyBool_Check(a) <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>PyBool_Check(b))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> PyLong_Type.tp_as_number<span style="color:#f92672">-&gt;</span>nb_and(a, b);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> PyBool_FromLong((a <span style="color:#f92672">==</span> Py_True) <span style="color:#f92672">&amp;</span> (b <span style="color:#f92672">==</span> Py_True));
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<p>long类型会复杂一些，因为它需要更大的内存。Python3已经舍弃掉了Python2中对int类型的支持，而是都使用long类型，而long又非常特殊，因为它可以存储的是一个变长整数。它的结构由一个PyObject的头部和一个数字的列表组成，数字列表一开始设置为只有1个数字，但初始化之后会调用 <a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Objects/longobject.c#L262">_PyLong_New()</a>方法重新分配内存，并调整为一个更大的长度:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> _longobject {
</span></span><span style="display:flex;"><span>    PyObject_VAR_HEAD
</span></span><span style="display:flex;"><span>    digit ob_digit[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></p>
<p>要将C语言的long类型转换为Python中的long类型，需要先将C中的long转换为一个数字列表，分配Python中long需要的内存，然后去设置每个数字:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>PyObject <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PyLong_FromLong</span>(<span style="color:#66d9ef">long</span> ival)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    PyLongObject <span style="color:#f92672">*</span>v;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> abs_ival;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> t;  <span style="color:#75715e">/* unsigned so &gt;&gt; doesn&#39;t propagate sign bit */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ndigits <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sign;
</span></span><span style="display:flex;"><span>    CHECK_SMALL_INT(ival);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 对于一个位的整数可以快速处理不需分配内存 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(abs_ival <span style="color:#f92672">&gt;&gt;</span> PyLong_SHIFT)) {
</span></span><span style="display:flex;"><span>        v <span style="color:#f92672">=</span> _PyLong_New(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (v) {
</span></span><span style="display:flex;"><span>            Py_SIZE(v) <span style="color:#f92672">=</span> sign;
</span></span><span style="display:flex;"><span>            v<span style="color:#f92672">-&gt;</span>ob_digit[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> Py_SAFE_DOWNCAST(
</span></span><span style="display:flex;"><span>                abs_ival, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>, digit);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (PyObject<span style="color:#f92672">*</span>)v;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 对于大一些的数，先循环确定有多少位 */</span>
</span></span><span style="display:flex;"><span>    t <span style="color:#f92672">=</span> abs_ival;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (t) {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">++</span>ndigits;
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">&gt;&gt;=</span> PyLong_SHIFT;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    v <span style="color:#f92672">=</span> _PyLong_New(ndigits);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (v <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        digit <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> v<span style="color:#f92672">-&gt;</span>ob_digit;
</span></span><span style="display:flex;"><span>        Py_SIZE(v) <span style="color:#f92672">=</span> ndigits<span style="color:#f92672">*</span>sign;
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">=</span> abs_ival;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (t) {
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">*</span>p<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> Py_SAFE_DOWNCAST(
</span></span><span style="display:flex;"><span>                t <span style="color:#f92672">&amp;</span> PyLong_MASK, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>, digit);
</span></span><span style="display:flex;"><span>            t <span style="color:#f92672">&gt;&gt;=</span> PyLong_SHIFT;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (PyObject <span style="color:#f92672">*</span>)v;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
此外，将双精度浮点数转换为Python中的long以及Unicode进行转换都在<code>longobject.c</code>中有相应的方法。</p>
<h3 id="生成器类型">
  生成器类型
  <a class="anchor" href="#%e7%94%9f%e6%88%90%e5%99%a8%e7%b1%bb%e5%9e%8b">#</a>
</h3>
<p>Python中的生成器是指使用yield，通过连续的调用以生成更多的值。通常用于较大的数据块中来起到节约内存、提升效率的作用。如:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">example</span>():
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>   lst <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>   <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> lst:
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>     <span style="color:#66d9ef">yield</span> i
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> gen <span style="color:#f92672">=</span> example()
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> gen
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>generator object example at <span style="color:#ae81ff">0x100bcc480</span><span style="color:#f92672">&gt;</span></span></span></code></pre></div>
我们深入探索生成器对象，发现它有一些gi_开头的属性:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> dir(gen)
</span></span><span style="display:flex;"><span>[ <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">&#39;close&#39;</span>, 
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">&#39;gi_code&#39;</span>, 
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">&#39;gi_frame&#39;</span>, 
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">&#39;gi_running&#39;</span>, 
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">&#39;gi_yieldfrom&#39;</span>, 
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">&#39;send&#39;</span>, 
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">&#39;throw&#39;</span>]</span></span></code></pre></div>
在CPython中，生成器类型有三种，定义在<code>Include/genobject.h</code>的PyGenObject类型中，即Generator objects、Coroutine objects和Async generator objects。它们共享一些字段并且也有相似的行为逻辑:
<img src="./images/generators.png" alt="" />
我们以PyGenObject为例看看这些字段的用途:</p>
<ul>
<li>gi_frame，链接至一个PyFrameObject对象，这是生成器如何记住上次执行的本地变量的关键</li>
<li>gi_running，设置为0或1来判断当前生成器是否在执行</li>
<li>gi_code，链接至一个PyCodeObject对象，它持有编译好的方法便于之后再次调用</li>
<li>gi_weakreflist，链接至生成器函数内部的弱引用列表</li>
<li>gi_name，生成器的名称</li>
<li>gi_qualname，生成器的限定名称</li>
<li>gi_exc_state，是一个存储异常的元组，存储生成器调用过程中的异常</li>
</ul>
<p>当我们每次在Python中调用生成器的__next__方法时，其背后的gi_code字段会在一个新的frame中执行，并将返回值push到值栈中。它本质上调用的是<a href="https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Objects/genobject.c#L153">gen_send_ex()</a>方法，这个方法将生成器对象转换为下一个产生结果的函数，它和之前通过代码对象构造frame有很多类似之处:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> PyObject <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">gen_send_ex</span>(PyGenObject <span style="color:#f92672">*</span>gen, PyObject <span style="color:#f92672">*</span>arg, <span style="color:#66d9ef">int</span> exc, <span style="color:#66d9ef">int</span> closing)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 拿到当前执行线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PyThreadState <span style="color:#f92672">*</span>tstate <span style="color:#f92672">=</span> _PyThreadState_GET();       
</span></span><span style="display:flex;"><span>    PyFrameObject <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> gen<span style="color:#f92672">-&gt;</span>gi_frame;                   
</span></span><span style="display:flex;"><span>    PyObject <span style="color:#f92672">*</span>result;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果生成器正在执行过程中再次调用生成器会报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (gen<span style="color:#f92672">-&gt;</span>gi_running) {     
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;generator already executing&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (PyCoro_CheckExact(gen)) {
</span></span><span style="display:flex;"><span>            msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;coroutine already executing&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (PyAsyncGen_CheckExact(gen)) {
</span></span><span style="display:flex;"><span>            msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;async generator already executing&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        PyErr_SetString(PyExc_ValueError, msg);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 生成器迭代完的情况，对不同的生成器做不同的处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (f <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> f<span style="color:#f92672">-&gt;</span>f_stacktop <span style="color:#f92672">==</span> NULL) { 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (PyCoro_CheckExact(gen) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>closing) {
</span></span><span style="display:flex;"><span>            PyErr_SetString(
</span></span><span style="display:flex;"><span>                PyExc_RuntimeError,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;cannot reuse already awaited coroutine&#34;</span>); <span style="color:#75715e">// 4a.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (arg <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>exc) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (PyAsyncGen_CheckExact(gen)) {
</span></span><span style="display:flex;"><span>                PyErr_SetNone(PyExc_StopAsyncIteration); <span style="color:#75715e">// 4b.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                PyErr_SetNone(PyExc_StopIteration);      <span style="color:#75715e">// 4c.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 检查帧的最后一条指令如果是-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (f<span style="color:#f92672">-&gt;</span>f_lasti <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 此时不能把非None的值作为参数传入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (arg <span style="color:#f92672">&amp;&amp;</span> arg <span style="color:#f92672">!=</span> Py_None) { 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;can&#39;t send non-None value to a &#34;</span>
</span></span><span style="display:flex;"><span>                              <span style="color:#e6db74">&#34;just-started generator&#34;</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (PyCoro_CheckExact(gen)) {
</span></span><span style="display:flex;"><span>                msg <span style="color:#f92672">=</span> NON_INIT_CORO_MSG;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (PyAsyncGen_CheckExact(gen)) {
</span></span><span style="display:flex;"><span>                msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;can&#39;t send non-None value to a &#34;</span>
</span></span><span style="display:flex;"><span>                      <span style="color:#e6db74">&#34;just-started async generator&#34;</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            PyErr_SetString(PyExc_TypeError, msg);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> { 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 这是第一次被调用，允许使用参数，参数的值被push到值栈中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        result <span style="color:#f92672">=</span> arg <span style="color:#f92672">?</span> arg : Py_None;
</span></span><span style="display:flex;"><span>        Py_INCREF(result);
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>(f<span style="color:#f92672">-&gt;</span>f_stacktop<span style="color:#f92672">++</span>) <span style="color:#f92672">=</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Py_XINCREF(tstate<span style="color:#f92672">-&gt;</span>frame);
</span></span><span style="display:flex;"><span>    assert(f<span style="color:#f92672">-&gt;</span>f_back <span style="color:#f92672">==</span> NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// f_back是用于发送返回值的调用方，在这里把它设置为线程中的当前帧，也就是返回值被发送给调用者而不是生成器的创建者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    f<span style="color:#f92672">-&gt;</span>f_back <span style="color:#f92672">=</span> tstate<span style="color:#f92672">-&gt;</span>frame;                          
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 把生成器标记为正在运行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    gen<span style="color:#f92672">-&gt;</span>gi_running <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;            
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 生成器的异常信息中的最后一个异常，从线程状态中的最后一个异常复制                    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    gen<span style="color:#f92672">-&gt;</span>gi_exc_state.previous_item <span style="color:#f92672">=</span> tstate<span style="color:#f92672">-&gt;</span>exc_info; 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 线程状态的异常信息设为生成器异常信息的地址，便于调用者在生成器执行过程中的debug
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    tstate<span style="color:#f92672">-&gt;</span>exc_info <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>gen<span style="color:#f92672">-&gt;</span>gi_exc_state; 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 生成器内部的那个frame放到CPython的主循环中去执行             
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    result <span style="color:#f92672">=</span> PyEval_EvalFrameEx(f, exc); 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 把线程状态的最后一个异常重置为调用frame之前的值               
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    tstate<span style="color:#f92672">-&gt;</span>exc_info <span style="color:#f92672">=</span> gen<span style="color:#f92672">-&gt;</span>gi_exc_state.previous_item; 
</span></span><span style="display:flex;"><span>    gen<span style="color:#f92672">-&gt;</span>gi_exc_state.previous_item <span style="color:#f92672">=</span> NULL;    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 把生成器标记为不在运行         
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    gen<span style="color:#f92672">-&gt;</span>gi_running <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;                                
</span></span><span style="display:flex;"><span>    assert(f<span style="color:#f92672">-&gt;</span>f_back <span style="color:#f92672">==</span> tstate<span style="color:#f92672">-&gt;</span>frame);
</span></span><span style="display:flex;"><span>    Py_CLEAR(f<span style="color:#f92672">-&gt;</span>f_back);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//  没有返回值时，对于生成器应该引发StopIteration，异步生成器应该引发StopAsyncIteration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (result <span style="color:#f92672">&amp;&amp;</span> f<span style="color:#f92672">-&gt;</span>f_stacktop <span style="color:#f92672">==</span> NULL) {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (result <span style="color:#f92672">==</span> Py_None) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (PyAsyncGen_CheckExact(gen)) {
</span></span><span style="display:flex;"><span>                PyErr_SetNone(PyExc_StopAsyncIteration);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                PyErr_SetNone(PyExc_StopIteration);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/* Async generators cannot return anything but None */</span>
</span></span><span style="display:flex;"><span>            assert(<span style="color:#f92672">!</span>PyAsyncGen_CheckExact(gen));
</span></span><span style="display:flex;"><span>            _PyGen_SetStopIterationValue(result);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Py_CLEAR(result);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果这是一个协程或异步生成器但引发了StopIteration，则是不允许的，引发RuntimeError
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>result <span style="color:#f92672">&amp;&amp;</span> PyErr_ExceptionMatches(PyExc_StopIteration)) { 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;generator raised StopIteration&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (PyCoro_CheckExact(gen)) {
</span></span><span style="display:flex;"><span>            msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;coroutine raised StopIteration&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> PyAsyncGen_CheckExact(gen) {
</span></span><span style="display:flex;"><span>            msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;async generator raised StopIteration&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        _PyErr_FormatFromCause(PyExc_RuntimeError, <span style="color:#e6db74">&#34;%s&#34;</span>, msg);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果这是一个异步生成器但引发了StopAsyncIteration，则也是不允许的，引发RuntimeError
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>result <span style="color:#f92672">&amp;&amp;</span> PyAsyncGen_CheckExact(gen) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>             PyErr_ExceptionMatches(PyExc_StopAsyncIteration))  
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* code in `gen` raised a StopAsyncIteration error:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">           raise a RuntimeError.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;async generator raised StopAsyncIteration&#34;</span>;
</span></span><span style="display:flex;"><span>        _PyErr_FormatFromCause(PyExc_RuntimeError, <span style="color:#e6db74">&#34;%s&#34;</span>, msg);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 最终，结果返回给调用__next__()方法者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> result; 
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></p>
<p>综上，生成器是一种强大的语法，通过yield关键字触发整个流程，创建唯一对象，将已编译的代码对象复制为其属性，设置frame并为其存储局部变量列表。这一切对用户看起来很神奇，但其底层并不复杂。</p>
<h2 id="标准库">
  标准库
  <a class="anchor" href="#%e6%a0%87%e5%87%86%e5%ba%93">#</a>
</h2>
<p>Python被称为&quot;内置电池&quot;的语言，主要在于其强大的标准库涵盖了各个方面。在CPython中，主要包含两类标准库模块，即用纯Python编写的实用程序，以及使用C写的、Python只是做了一层包装的程序。</p>
<p>使用纯Python写的模块都放在Lib目录下，当我们安装一个Python的发行版时，标准库模块会从Lib文件夹复制到发行版的文件夹中。这些模块往往没有什么特别的，有的甚至只有几十行，只是为了开发者的方便而设计。</p>
<p>其余的模块要么是用C写的，要么是用Python和C结合起来写的。它们Python的部分仍然在Lib目录下，而C的部分在Modules目录下。但是有两个例外，其一是sys模块在Python/sysmodule.c中，还有是__builtins__模块在Python/bltinmodule.c中。</p>
<p>我们能在Python中直接使用的print()、chr()、format()等方法就是在bltinmodule.c中，因为解释器实例化的时候就通过import * from __builtins__导入了这些方法。sys模块也是因为专用于解释器和CPython内部的，才放在那个位置。</p>
<p>当我们输入<code>print(&quot;hello&quot;)</code>时，在CPython中发生了如下步骤:</p>
<ol>
<li>参数hello是一个字符串常量被编译器转换为PyUnicodeObject</li>
<li>内置的builtin_print()使用该参数执行，此例中kwnames为NULL</li>
<li>变量file被设为PyId_stdout，系统的stdout处理器</li>
<li>把每一个参数发送给file</li>
<li>把<code>\n</code>发送给file</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> PyObject <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">builtin_print</span>(PyObject <span style="color:#f92672">*</span>self, PyObject <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>args, Py_ssize_t nargs, PyObject <span style="color:#f92672">*</span>kwnames)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (file <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> file <span style="color:#f92672">==</span> Py_None) {
</span></span><span style="display:flex;"><span>        file <span style="color:#f92672">=</span> _PySys_GetObjectId(<span style="color:#f92672">&amp;</span>PyId_stdout);
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nargs; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (sep <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>                err <span style="color:#f92672">=</span> PyFile_WriteString(<span style="color:#e6db74">&#34; &#34;</span>, file);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                err <span style="color:#f92672">=</span> PyFile_WriteObject(sep, file,
</span></span><span style="display:flex;"><span>                                         Py_PRINT_RAW);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (err)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        err <span style="color:#f92672">=</span> PyFile_WriteObject(args[i], file, Py_PRINT_RAW);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (err)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (end <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        err <span style="color:#f92672">=</span> PyFile_WriteString(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, file);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        err <span style="color:#f92672">=</span> PyFile_WriteObject(end, file, Py_PRINT_RAW);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    Py_RETURN_NONE;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>用C来编写某些标准库是因为需要使用一些操作系统的功能，而不同的操作系统的接口可能是不一样的，CPython需要把它们抽象为统一的API接口供用户使用:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#ifdef HAVE_SYS_TIMES_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/times.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>...
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef MS_WINDOWS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define WIN32_LEAN_AND_MEAN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;pythread.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* MS_WINDOWS */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>...</span></span></code></pre></div></p>
<h2 id="gil">
  GIL
  <a class="anchor" href="#gil">#</a>
</h2>
<p>全局解释器锁机制使得解释器在同一时刻仅有一个线程可以被调度执行，某个线程若想要执行，就先要拿到GIL，但在每个Python进程中，只有一个GIL。它的存在使得解释器本身的实现更简单一些，更容易实现对象的安全访问，便于进行内存管理和编写扩展。但在多核环境下无法实现并行，对于以多线程为基础的并发应用就是一个灾难。</p>
<p>对于IO密集型任务，线程是在发生阻塞时主动释放GIL的，让其他线程得以执行。而对于CPU密集型任务，采取超时策略。</p>
<p>当GIL被其他线程占用时，等待线程会阻塞一段时间。如果超时（默认为0.005秒）后，依然无法获取锁，则发出请求。这种请求设计的很轻巧，就是一个全局条件变量设置。正在执行的线程在解释循环内会检查该标记，然后释放锁，切换线程执行，其自身进入等待状态。属于典型的协作机制。相关源码:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">&lt;!--</span> cpython<span style="color:#f92672">/</span>Python<span style="color:#f92672">/</span>ceval.c <span style="color:#f92672">--&gt;</span>
</span></span><span style="display:flex;"><span>main_loop:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (;;) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (_Py_atomic_load_relaxed(eval_breaker)) {
</span></span><span style="display:flex;"><span>            opcode <span style="color:#f92672">=</span> _Py_OPCODE(<span style="color:#f92672">*</span>next_instr);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (_Py_atomic_load_relaxed(<span style="color:#f92672">&amp;</span>ceval<span style="color:#f92672">-&gt;</span>gil_drop_request)) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">/* Give another thread a chance */</span>
</span></span><span style="display:flex;"><span>                drop_gil(ceval, tstate);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">/* Other threads may run now */</span>
</span></span><span style="display:flex;"><span>                take_gil(ceval, tstate);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">/* Check if we should make a quick exit. */</span>
</span></span><span style="display:flex;"><span>                exit_thread_if_finalizing(tstate);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (_PyThreadState_Swap(<span style="color:#f92672">&amp;</span>runtime<span style="color:#f92672">-&gt;</span>gilstate, tstate) <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>                    Py_FatalError(<span style="color:#e6db74">&#34;ceval: orphan tstate&#34;</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> (opcode) {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">case</span> TARGET(NOP)<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">case</span> TARGET(LOAD_FAST)<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>          ...
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
CPython使用系统线程，且没有实现线程调度。所以，具体哪个等待线程被切换执行，由操作系统决定。甚至，发出请求和被切换执行的未必就是同一个线程。</p>
<p>对于CPU密集型任务，除了使用多进程架构绕开，也可以使用C来编写多线程的扩展也能绕开GIL限制。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/hjlarry/hjlarry.github.io/commit/a9a604fb29c677ce04a08228da6fc8efe89bf44e" title='最后修改者 hjlarry | September 7, 2020' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>September 7, 2020</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/hjlarry/hjlarry.github.io/edit/master/content/content/docs/python/interpreter/_index.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>编辑本页</span>
    </a>
  </div>


</div>



  <script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        <br>
<div style="text-align: center;font-size:xx-small;">
    Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> | Theme by <a href="https://github.com/alex-shpak/hugo-book" target="_blank">hugo-book</a>
</div>
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#编码规范">编码规范</a></li>
    <li><a href="#执行方式">执行方式</a>
      <ul>
        <li><a href="#程序入口">程序入口</a></li>
        <li><a href="#运行时环境">运行时环境</a></li>
        <li><a href="#-c的方式">-c的方式</a></li>
        <li><a href="#-m的方式">-m的方式</a></li>
        <li><a href="#file的方式">file的方式</a></li>
      </ul>
    </li>
    <li><a href="#编译">编译</a>
      <ul>
        <li><a href="#语义解析">语义解析</a></li>
        <li><a href="#ast">AST</a></li>
        <li><a href="#编译过程">编译过程</a></li>
        <li><a href="#汇编器">汇编器</a></li>
        <li><a href="#创建代码对象">创建代码对象</a></li>
        <li><a href="#字节码">字节码</a></li>
      </ul>
    </li>
    <li><a href="#执行">执行</a>
      <ul>
        <li><a href="#构建frame">构建frame</a></li>
        <li><a href="#执行frame">执行frame</a></li>
        <li><a href="#值栈">值栈</a></li>
      </ul>
    </li>
    <li><a href="#cpython中的对象">CPython中的对象</a>
      <ul>
        <li><a href="#基础对象">基础对象</a></li>
        <li><a href="#布尔和整数">布尔和整数</a></li>
        <li><a href="#生成器类型">生成器类型</a></li>
      </ul>
    </li>
    <li><a href="#标准库">标准库</a></li>
    <li><a href="#gil">GIL</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












