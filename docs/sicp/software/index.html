<!DOCTYPE html>
<html lang="cn">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="软件部分"><meta property="og:title" content="软件部分" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/docs/sicp/software/" />
<meta property="og:updated_time" content="2019-11-22T14:59:52+08:00" />
<title>软件部分 | Home</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/book.min.eddc90f1d1267cb826e7cffc53c434e50061c4bfe41146a43670842ce6cb3bf6.css" integrity="sha256-7dyQ8dEmfLgm58/8U8Q05QBhxL/kEUakNnCELObLO/Y=">


<script defer src="/cn.search.min.e84213de8510d68758f21b25e561c271477ff56e577b69426cf8f6b5ce7a28b5.js" integrity="sha256-6EIT3oUQ1odY8hsl5WHCcUd/9W5Xe2lCbPj2tc56KLU="></script>

<link rel="alternate" type="application/rss+xml" href="/docs/sicp/software/index.xml" title="Home" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="/"><img src="/logo.png" alt="Logo" /><span>Home</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    <ul>
<li><strong>计算机基础</strong>
<ul>
<li><a href="/docs/sicp/hardware/">硬件</a></li>
<li><a href="/docs/sicp/software/"class=active>软件</a></li>
<li><a href="/docs/sicp/asm/">汇编</a></li>
</ul>
</li>
<li><strong>GO语言</strong>
<ul>
<li><a href="/docs/go/map/">字典</a></li>
<li><a href="/docs/go/closure/">闭包</a></li>
<li><a href="/docs/go/defer/">延迟调用</a></li>
<li><a href="/docs/go/gc/">垃圾回收</a></li>
<li><a href="/docs/go/alloc/">内存分配</a></li>
<li><a href="/docs/go/goroutine/">并发调度</a></li>
<li><a href="/docs/go/lock/">锁</a></li>
</ul>
</li>
<li><strong>Python语言</strong>
<ul>
<li><a href="/docs/python/descriptor/">描述符</a></li>
<li><a href="/docs/python/interpreter/">解释器</a></li>
</ul>
</li>
<li><strong>Mysql</strong>
<ul>
<li><a href="/docs/mysql/query/">查询</a></li>
<li><a href="/docs/mysql/theory/">原理</a></li>
</ul>
</li>
<li><strong>其他</strong>
<ul>
<li><a href="/docs/other/git/">git</a></li>
<li><a href="/docs/other/docker/">docker</a></li>
<li><a href="/docs/other/protocol/">网络协议</a></li>
<li><a href="/docs/other/tools/">基础系统工具</a></li>
</ul>
</li>
</ul>





</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>软件部分</strong>
</header>

      
<article class="markdown"><h1 id="计算机科学基础知识之软件部分">计算机科学基础知识之软件部分</h1>
<h2 id="操作系统">操作系统</h2>
<p>它是计算机体系的内核和基石，管理计算机硬件与软件资源。分为:</p>
<ul>
<li>个人机: Windows, macOS, Linux/BSD</li>
<li>大型机: Linux, Unix</li>
<li>嵌入式: VxWorks</li>
<li>移动端: Android, Windows CE</li>
</ul>
<p>因为Unix商业版权的原因，必须完全符合UNIX标准才能称为UNIX系统，其他的BSD/Linux只能称为UNIX-like。学术上的操作系统和我们日常口中说的操作系统不太一样，我们一般说的windows严格来说属于一个操作系统产品或者说一个操作系统的发行版，它是系统本身和一些软件(浏览器、扫雷)的打包，而学术上的操作系统指的是内核和一些必要的服务。</p>
<p>现代操作系统的基本功能包括:</p>
<ul>
<li>内存管理(memory management)</li>
<li>进程管理(process management)</li>
<li>中断处理(interrupt handling)</li>
<li>文件系统(file system)</li>
<li>安全机制(protection and security)</li>
<li>进程通信(inter-process communications)</li>
<li>设备驱动(device driver)</li>
</ul>
<h2 id="内核">内核</h2>
<p>微内核就是把最核心、最基础的部分单独作为内核，其他功能围绕它处理。包括地址空间、线程处理、进程通信等。这类东西它们需要以特权模式运行，其他基础服务当做普通应用程序独立运行。</p>
<p>在内核中运行的程序使用的内存，叫内核空间，也叫内核态。其他程序运行在用户空间，也叫用户态。用户态的代码需要在内核态运行时，并不是直接放在内核态中运行的，这样安全没法保证，首先会做权限检查，通过之后相当于提交了申请，内核运行完成以后返回结果唤醒用户态的程序，这就又涉及到了上下文切换和状态保存。所以用户态和内核态的切换会消耗大量的资源。</p>
<p>微内核的优点就是内核很小，裁剪起来方便，裁剪不同的基础服务就可以形成不同的版本面向不同的用户，另外就是其中某个服务崩溃的话不会影响到内核，内核可以重启改服务。当然缺点就是由于处于不同的地址空间，基础服务和内核通信时得使用类似于IPC(Inter-Process Communication)的方式通讯，效率相对会差一些。</p>
<p>微内核的典型代表是学术上的windows和macOS，而不是Linux，早期的Linux为了性能考虑采用了宏内核。</p>
<p>宏内核也叫单一内核，把核心和基础服务放在一个地址空间内均以特权模式运行，好处就是调用一些基础服务的时候相当于函数调用，不需要通讯，性能很高。缺点就是复杂度和耦合度很高，虽然代码是模块化的，但其中某个模块崩溃都可能导致整个系统崩溃，也不方便裁剪和移植。</p>
<p><img src="./images/kernel.png" alt="kernel">
现代的操作系统往往是采用混合内核的，并不是泾渭分明的。</p>
<h2 id="系统调用">系统调用</h2>
<p>系统调用是内核对外的接口，内核态的一些内核函数。应用程序只要和硬件打交道都会涉及到系统调用，向操作系统申请并等待回复，应该尽量避免或考虑优化，比如有些场景可以使用在用户空间的带buffer的文件替代操作系统提供的文件读写API。</p>
<p>典型的系统调用汇编代码:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">global</span> <span style="color:#66d9ef">_start</span> 

<span style="color:#66d9ef">section</span> <span style="color:#66d9ef">.data</span>
    <span style="color:#a6e22e">hello</span> : <span style="color:#66d9ef">db</span> <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#66d9ef">hello</span>, <span style="color:#66d9ef">world</span>!<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">n</span><span style="color:#960050;background-color:#1e0010">`</span>
<span style="color:#a6e22e">section</span> <span style="color:#66d9ef">.text</span> 
    <span style="color:#66d9ef">_start</span>:
        <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">1</span>      <span style="color:#75715e">; system call number should be store in rax
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">rdi</span>, <span style="color:#ae81ff">1</span>      <span style="color:#75715e">; argument #1 in rdi: where to write (descriptor)?
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">rsi</span>, <span style="color:#66d9ef">hello</span>  <span style="color:#75715e">; argument #2 in rsi: where does the string start?
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">rdx</span>, <span style="color:#ae81ff">14</span>     <span style="color:#75715e">; argument #3 in rdx: how many bytes to write?
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">syscall</span>         <span style="color:#75715e">; this instruction invokes a system call
</span><span style="color:#75715e"></span>        
        <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">60</span>     <span style="color:#75715e">; &#39;exit&#39; syscall number
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">xor</span> <span style="color:#66d9ef">rdi</span>, <span style="color:#66d9ef">rdi</span>
        <span style="color:#a6e22e">syscall</span></code></pre></div>
C语言、Go语言通过标准库进行系统调用，他们的标准库中的函数也只是在汇编之上的一种包装。在汇编语言中通过在不同寄存器中放参数，执行<code>syscall</code>这样一条指令就可以进行系统调用，<code>syscall</code>是64位操作系统改进的一条指令，x86下是<code>int 0x80</code>，这种改进效率上也更高一些。</p>
<p>RAX寄存器代表系统调用的序号，相当于函数名称；RDI、RSI、RDX、R10、R8、R9，依次存放参数；再用RAX存返回值。这是系统调用的调用约定。可以通过<a href="http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">这里</a>查看到系统调用函数有哪些，分别是如何传参的。</p>
<h2 id="进程">进程</h2>
<h3 id="基础概念">基础概念</h3>
<p>程序和进程有什么区别？</p>
<p>某个程序里包含了某个进程所需要的数据，但在某个时间点，进程中的内容未必和程序中的内容是一一对应的。我们开发一个程序，不仅包括可执行的代码，还有周边的素材等等，程序运行的时候，也未必会把全部内容都载入到内存。而进程指的是程序运行时，在内存当中受操作系统管理的部分。程序就像是蓝图，我们可以是照着同一份蓝图启动多个进程。</p>
<p>进程不是执行单位，而是一个资源边界。相当于在内存这个世界里面，进程圈了一块地，这块地有很多的属性，比如虚拟地址空间、PID等，而地上的工人、流水线才是执行单位，我们称为线程。所以每个进程都有一个主线程。</p>
<ul>
<li>进程是程序的运行期实例(但不同操作系统对进程定义可能不同)</li>
<li>是系统动态执行基本单元</li>
<li>是系统资源分配单位</li>
<li>是线程的容器</li>
<li>是指令、数据及相关资源的集合</li>
<li>是程序运行过程的抽象</li>
</ul>
<h3 id="状态">状态</h3>
<ul>
<li>ready:除分配CPU外，其他准备就绪(按优先级排队调度)</li>
<li>running:占用处理器资源，正在执行</li>
<li>waiting:因IO blocking、sync等原因⽆无法继续执⾏</li>
</ul>
<h3 id="调度">调度</h3>
<p>采用抢占式调度，CPU分配时间片，时间片结束则强制性切换并保存上下文。另外一种调度模式叫协作式调度，一般是在用户空间实现的。</p>
<h2 id="线程">线程</h2>
<p>也称轻量级进程(LWP)，是进程中的实际执行单位，由程序计数器、寄存器、栈内存组成。</p>
<ul>
<li>进程拥有一到多个线程</li>
<li>线程是调度和时间片的分配单位，更多线程理论上会获得更多的CPU资源</li>
<li>线程共享进程的资源</li>
<li>同一程序的多个线程是可以在多核处理器上并行执行来提高执行吞吐率的，这个要看操作系统的调度策略</li>
</ul>
<p>协程只是在用户空间的线程里实现的一种策略，本身和线程有很大的区别。</p>
<p>内核线程和用户线程是有区别的，我们一般使用的线程都是被包装过的，很少通过系统调用来使用线程。用户线程可能是系统线程的包装体，它们是一对一关系；也可能是多个用户线程对应一个系统线程，多个用户线程分享一个时间片，这是多对一关系；还有一种可能是多对多关系，类似于Go的机制，某个时刻一个用户线程必然对应一个系统线程，但总体来看用户线程可能比系统线程更多或者更少。</p>
<h2 id="虚拟存储器">虚拟存储器</h2>
<h3 id="基础概念-1">基础概念</h3>
<p>操作系统会有一个很大的地址空间，也叫虚拟地址空间。这个空间的前面一大段是操作系统用的，之后的每个进程也都会有一个独立的很大的地址空间。这样不同的程序可以使用相同的虚拟地址，当程序在运行时访问这个地址就是访问进程内的虚拟地址，通过内存管理单元(MMU)翻译映射到一个物理地址。这样的好处就是无论在程序内的地址空间怎么折腾都不会影响到其他的程序，对编译器也更友好更方便，可以提前分配。</p>
<p>我们在编译时看到的都是虚拟地址，物理地址在运行期才能看到。虚拟地址空间未必会全部映射到主存中，也会给各个设备保留一段空间。</p>
<p>虚拟存储器可以看成硬盘保存的一个字节数组，虚拟地址空间有256TB，而实际的物理内存可能只有8GB，有这么大的虚拟地址空间就不能阻止程序去使用，不够的物理存储体我们就通过硬盘上的交换分区来弥补。也有可能物理内存加上交换分区都不够程序使用，在Linux中就会引发OOM机制。</p>
<h3 id="内存分配过程">内存分配过程</h3>
<p>假设某个程序需要内存分配器分配10MB的内存，那么操作系统会怎么做呢？首先会划分出一个虚拟地址范围，然后返回起始地址的指针。它此时没有必要通过MMU分配真实的物理内存，因为有可能这段内存后续根本没有读写发生。接下来若写入数据，也只会以页(8KB)为单位一点点的去写，每次写入的时候操作系统再去补物理内存，采用一种按需分配的机会主义原则。具体如何实现呢？当向一个虚拟地址写入数据时，就会去MMU找对应的物理地址，没有找到就说明没有建立映射关系还没有分配物理内存，就会引发一个缺页异常(page fault)，操作系统内有专门的程序把这一页补上，来实现按需分配。</p>
<p>我们通过程序可以模拟这种虚拟内存和物理内存的关系:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// gcc -g -O0 -o test test.c
</span><span style="color:#75715e"></span><span style="color:#75715e">// ./test
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">const</span> size_t length <span style="color:#f92672">=</span> <span style="color:#ae81ff">1024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span>;
    <span style="color:#66d9ef">const</span> size_t pause <span style="color:#f92672">=</span> length <span style="color:#f92672">/</span> <span style="color:#ae81ff">10</span>;

    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> malloc(length); <span style="color:#75715e">// 分配100MB内存
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>x <span style="color:#f92672">=</span> p;

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>)length; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) <span style="color:#75715e">// 循环写入数据
</span><span style="color:#75715e"></span>    {
        <span style="color:#f92672">*</span>x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        x<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">%</span> (<span style="color:#66d9ef">int</span>)pause <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#75715e">// 隔一段时间暂停一下便于观察
</span><span style="color:#75715e"></span>        {
            printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i);
            getchar();          <span style="color:#75715e">// 可以让用户在命令行中随时控制运行进度
</span><span style="color:#75715e"></span>        }
    }
    free(p);
    <span style="color:#66d9ef">return</span> EXIT_SUCCESS;
}</code></pre></div></p>
<p>观察运行结果:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac $ pidstat -r -p <span style="color:#e6db74">`</span>pidof test<span style="color:#e6db74">`</span> <span style="color:#ae81ff">1</span>
│Linux 4.9.184-linuxkit <span style="color:#f92672">(</span>cabd4e519687<span style="color:#f92672">)</span>   12/06/19        _x86_64_        <span style="color:#f92672">(</span><span style="color:#ae81ff">2</span> CPU<span style="color:#f92672">)</span>│
│11:10:18      UID       PID  minflt/s  majflt/s     VSZ     RSS   %MEM  Command
│11:10:19        <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">180</span>      0.00      0.00  <span style="color:#ae81ff">106908</span>   <span style="color:#ae81ff">21624</span>   1.06  test
│11:10:20        <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">180</span>      0.00      0.00  <span style="color:#ae81ff">106908</span>   <span style="color:#ae81ff">21624</span>   1.06  test
│11:10:21        <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">180</span>      0.00      0.00  <span style="color:#ae81ff">106908</span>   <span style="color:#ae81ff">21624</span>   1.06  test
│11:10:22        <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">180</span>   2560.00      0.00  <span style="color:#ae81ff">106908</span>   <span style="color:#ae81ff">31920</span>   1.56  test
│11:10:23        <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">180</span>      0.00      0.00  <span style="color:#ae81ff">106908</span>   <span style="color:#ae81ff">31920</span>   1.56  test
│11:10:24        <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">180</span>   2534.65      0.00  <span style="color:#ae81ff">106908</span>   <span style="color:#ae81ff">42216</span>   2.06  test
│11:10:25        <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">180</span>      0.00      0.00  <span style="color:#ae81ff">106908</span>   <span style="color:#ae81ff">42216</span>   2.06  test
│11:10:26        <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">180</span>   2560.00      0.00  <span style="color:#ae81ff">106908</span>   <span style="color:#ae81ff">52512</span>   2.57  test
│11:10:27        <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">180</span>      0.00      0.00  <span style="color:#ae81ff">106908</span>   <span style="color:#ae81ff">52512</span>   2.57  test
│11:10:28        <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">180</span>      0.00      0.00  <span style="color:#ae81ff">106908</span>   <span style="color:#ae81ff">52512</span>   2.57  test
│11:10:29        <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">180</span>      0.00      0.00  <span style="color:#ae81ff">106908</span>   <span style="color:#ae81ff">52512</span>   2.57  test
│11:10:30        <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">180</span>   2560.00      0.00  <span style="color:#ae81ff">106908</span>   <span style="color:#ae81ff">62544</span>   3.06  test</code></pre></div>
VSZ表示虚拟内存，RSS表示物理内存，可以看到随用户的控制，数据不断写入，物理内存增加。</p>
<h3 id="换入换出">换入换出</h3>
<p>假设这10MB内存已经分配下来，该程序却长时间不用，操作系统就会把这10MB内存的数据保存到硬盘的交换分区上，并对这些内存页的状态做变更，MMU的映射地址做变更，这些内存就可以去给别的程序用，这就叫换出(swap out)。下次重新激活该程序时，会把硬盘上交换分区的数据重新放回某些空闲的页并重新建立映射，这就是换入(swap in)。我们可以通过监控工具观察到系统内的换入换出情况:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~ $ dstat
You did not <span style="color:#66d9ef">select</span> any stats, using -cdngy by default.
--total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai stl| read  writ| recv  send|  in   out | int   csw
  <span style="color:#ae81ff">3</span>   <span style="color:#ae81ff">4</span>  <span style="color:#ae81ff">77</span>  <span style="color:#ae81ff">16</span>   0|  12M  101k|   <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> |   <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> |<span style="color:#ae81ff">1464</span>  <span style="color:#ae81ff">2562</span>
  <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">100</span>   <span style="color:#ae81ff">0</span>   0|   <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> |   <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> |   <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> | <span style="color:#ae81ff">175</span>   <span style="color:#ae81ff">408</span>
  <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">100</span>   <span style="color:#ae81ff">0</span>   0|   <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> |   <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> |   <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> | <span style="color:#ae81ff">148</span>   <span style="color:#ae81ff">345</span>
  <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">100</span>   <span style="color:#ae81ff">0</span>   0|   <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> |   <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> |   <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> | <span style="color:#ae81ff">143</span>   <span style="color:#ae81ff">341</span>
  
  // paging的in和out即为当前换入换出大小,int表示当前有多少中断,csw表示当前有多少上下文切换</code></pre></div>
当程序运行需要的内存大于机器的物理内存时，就可能造成频繁的换入换出，产生颠簸效应(thrashing)。</p>
<h3 id="性能相关">性能相关</h3>
<p>如果程序需要性能更高、速度要有保障，就需要向操作系统申请锁死这段内存。同时，缺页异常属于内核级别的，有一定的开销，所以为了追求性能的极致，有的C程序会先进行一个初始化操作，缺页异常仍然会有只是会提前，在执行具体的算法时就会更高效不受缺页异常的影响，而一些高级语言可能会由于编译器的优化使得提前初始化写入被优化忽略掉。</p>
<p>物理内存分配还采用了写入时复制(copy-on-write)的机制，即A若引用一块内存，那么复制A到B的时候并不会复制这块内存，只有当去写入A或B的时候才会去复制这块内存，起到节约内存的目的。</p>
<p>对于服务器来讲，假设物理内存有8G，当前运行的程序只有4G，操作系统就会拿另外4G当做自己的cache用，比如缓存文件读写等，程序需要使用时再从cache里还回来。但对于桌面端用户来讲，GUI程序居多，占用内存也多，所以往往会有足够的内存来让用户载入一个程序的速度更快。服务器往往运行的程序数量和时间更长更稳定，所以不同操作系统的分配内存策略也不同。</p>
<p>某种角度上，假设所有数据都交换到硬盘上，我们可以认为所有的数据保存在硬盘上，内存上只保存活跃数据，内存可以看成是硬盘的缓存或者说L4，虚拟存储器就可以看成硬盘上一个巨大的数组。</p>
<h2 id="寄存器">寄存器</h2>
<p>由于寄存器数量很少，我们就给每个寄存器起了个名字，并分为:</p>
<ul>
<li>通用寄存器:AX,BX,CX,DX,SI,DI,SP,BP,R8-R15</li>
<li>指令寄存器:IP(也叫PC)，用于读取程序执行的下一条指令地址</li>
<li>标志寄存器:FR，用于存放处理器的状态和运算结果</li>
</ul>
<h3 id="通用寄存器">通用寄存器</h3>
<p>我们在寄存器名称前加个R，表示64位的寄存器；加个E，表示32位的；不加表示16位的；同时AH表示AX的高位；AL表示AX的地位。可以通过gdb观察到这些寄存器的值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> info registers
rax            0x66	<span style="color:#ae81ff">102</span>
rbx            0x0	<span style="color:#ae81ff">0</span>
rcx            0x22	<span style="color:#ae81ff">34</span>
rdx            0x33	<span style="color:#ae81ff">51</span>
rsi            0x22	<span style="color:#ae81ff">34</span>
rdi            0x11	<span style="color:#ae81ff">17</span>
rbp            0x7fffffffe580	0x7fffffffe580
rsp            0x7fffffffe550	0x7fffffffe550
r8             0x7ffff7dd0d80	<span style="color:#ae81ff">140737351847296</span>
r9             0x7ffff7dd0d80	<span style="color:#ae81ff">140737351847296</span>
r10            0x0	<span style="color:#ae81ff">0</span>
r11            0x0	<span style="color:#ae81ff">0</span>
r12            0x555555554540	<span style="color:#ae81ff">93824992232768</span>
r13            0x7fffffffe660	<span style="color:#ae81ff">140737488348768</span>
r14            0x0	<span style="color:#ae81ff">0</span>
r15            0x0	<span style="color:#ae81ff">0</span>
rip            0x5555555546b2	0x5555555546b2 &lt;main+68&gt;
eflags         0x206	<span style="color:#f92672">[</span> PF IF <span style="color:#f92672">]</span>
cs             0x33	<span style="color:#ae81ff">51</span>
ss             0x2b	<span style="color:#ae81ff">43</span>
ds             0x0	<span style="color:#ae81ff">0</span>
es             0x0	<span style="color:#ae81ff">0</span>
fs             0x0	<span style="color:#ae81ff">0</span>
gs             0x0	<span style="color:#ae81ff">0</span>
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> set $rbx<span style="color:#f92672">=</span>0x8070605040302010
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> p/x $ebx
$1 <span style="color:#f92672">=</span> 0x40302010
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> p/x $bx
$2 <span style="color:#f92672">=</span> 0x2010
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> p/x $bh
$3 <span style="color:#f92672">=</span> 0x20
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> p/x $bl
$4 <span style="color:#f92672">=</span> 0x10</code></pre></div>
<p>所以有了这些访问的手段，一个寄存器是可以分割为不同的部分，存储不同内容的。通用寄存器用来存什么都可以，只是由于C语言出现的早，它对各个寄存器的一些用法就成了约定俗成的惯例，例如si、di用来传参，ax保存返回值，bp、sp表示栈底、栈顶，cx用来做循环等都是惯例。</p>
<p>但指令寄存器是在硬件层面上和其他寄存器有不同，专门用来放程序执行的下一条指令的。</p>
<h3 id="标志寄存器">标志寄存器</h3>
<p>我们通过一个示例代码来观察标志寄存器的用途。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">global</span> <span style="color:#66d9ef">_start</span>

<span style="color:#a6e22e">section</span> <span style="color:#66d9ef">.data</span>
    <span style="color:#a6e22e">hello</span>   : <span style="color:#66d9ef">db</span> <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#66d9ef">hello</span>,<span style="color:#66d9ef">world</span>!<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">n</span><span style="color:#960050;background-color:#1e0010">`</span>

<span style="color:#a6e22e">section</span> <span style="color:#66d9ef">.text</span>

    _start:
        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">1</span>
        <span style="color:#a6e22e">test</span>    <span style="color:#66d9ef">rax</span>, <span style="color:#66d9ef">rax</span> <span style="color:#75715e">; 如果AX为0，则把ZF设为1，否则把ZF设为0
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">jne</span>     <span style="color:#66d9ef">.exit</span>    <span style="color:#75715e">; 如果ZF为0，则跳转至.exit标签
</span><span style="color:#75715e"></span>
    .hello:
        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">1</span>
        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">rdi</span>, <span style="color:#ae81ff">1</span>
        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">rsi</span>, <span style="color:#66d9ef">hello</span>
        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">rdx</span>, <span style="color:#ae81ff">14</span>
        <span style="color:#a6e22e">syscall</span>

    .exit:
        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">60</span>
        <span style="color:#a6e22e">xor</span>     <span style="color:#66d9ef">rdi</span>, <span style="color:#66d9ef">rdi</span>
        <span style="color:#a6e22e">syscall</span></code></pre></div>
<p>标志寄存器有很多个位，ZF就是其中的一个位。哪个指令对哪个标志位有影响，都有手册可以查到，例如test指令可以通过<a href="https://baike.baidu.com/item/test/10804276#viewPageContent">这里</a>查到，<a href="https://baike.baidu.com/item/jne">jne</a>也是。</p>
<p>接着，我们在gdb中观察:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac/assem $ nasm -g -F dwarf -f elf64 -o fr.o fr.s
<span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac/assem $ ld -o fr fr.o
<span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac/assem $ gdb fr
...
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> b <span style="color:#ae81ff">9</span>
Breakpoint <span style="color:#ae81ff">1</span> at 0x4000b0: file fr.s, line 9.
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> r
Starting program: /root/.mac/assem/fr

Breakpoint 1, _start <span style="color:#f92672">(</span><span style="color:#f92672">)</span> at fr.s:9
9	        mov     rax, <span style="color:#ae81ff">1</span>
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> display $rax
1: $rax <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> display $eflags
2: $eflags <span style="color:#f92672">=</span> <span style="color:#f92672">[</span> IF <span style="color:#f92672">]</span>
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> n
10	        test    rax, rax ; ZF<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> AX<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> <span style="color:#66d9ef">else</span> ZF<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
1: $rax <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
2: $eflags <span style="color:#f92672">=</span> <span style="color:#f92672">[</span> IF <span style="color:#f92672">]</span>
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> n
11	        jne     .exit    ; jmp <span style="color:#66d9ef">if</span> ZF<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
1: $rax <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
2: $eflags <span style="color:#f92672">=</span> <span style="color:#f92672">[</span> IF <span style="color:#f92672">]</span>
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> n
_start.exit <span style="color:#f92672">(</span><span style="color:#f92672">)</span> at fr.s:21
21	        mov     rax, <span style="color:#ae81ff">60</span></code></pre></div></p>
<p>标志寄存器中若某位有值则会出现在eflags中，按当前代码逻辑，ZF为0会直接跳转到.exit部分。然后我们在gdb中修改$rax的值，会发现跳转至.hello部分。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> n
10	        test    rax, rax ; ZF<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> AX<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> <span style="color:#66d9ef">else</span> ZF<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
1: $rax <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
2: $eflags <span style="color:#f92672">=</span> <span style="color:#f92672">[</span> IF <span style="color:#f92672">]</span>
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> set $rax<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> n
11	        jne     .exit    ; jmp <span style="color:#66d9ef">if</span> ZF<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
1: $rax <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
2: $eflags <span style="color:#f92672">=</span> <span style="color:#f92672">[</span> PF ZF IF <span style="color:#f92672">]</span>
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> n
_start.hello <span style="color:#f92672">(</span><span style="color:#f92672">)</span> at fr.s:14
14	        mov     rax, <span style="color:#ae81ff">1</span>
1: $rax <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
2: $eflags <span style="color:#f92672">=</span> <span style="color:#f92672">[</span> PF ZF IF <span style="color:#f92672">]</span></code></pre></div>
<h2 id="可执行文件">可执行文件</h2>
<p><img src="./images/elf.png" alt="ELF"></p>
<p>一个可执行程序看上去像是单个文件的数据库，我们以ELF格式的可执行文件为例，它包括头部元数据、Section header table、Program header table和各个section段。</p>
<h3 id="head">Head</h3>
<p>文件头部包含一些元数据，用于进程加载找入口地址等:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac/assem $ readelf -h hello
ELF Header:
  Magic:   7f <span style="color:#ae81ff">45</span> 4c <span style="color:#ae81ff">46</span> <span style="color:#ae81ff">02</span> <span style="color:#ae81ff">01</span> <span style="color:#ae81ff">01</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>      // 魔法数，可以快速读取出来用于预判整个文件是不是一个合法的内容
  Class:                             ELF64          // ELF文件的格式
  Data:                              2<span style="color:#960050;background-color:#1e0010">&#39;</span>s complement, little endian  // 大小端情况
  Version:                           <span style="color:#ae81ff">1</span> <span style="color:#f92672">(</span>current<span style="color:#f92672">)</span>
  OS/ABI:                            UNIX - System V    // 哪个平台使用
  ABI Version:                       <span style="color:#ae81ff">0</span>
  Type:                              EXEC <span style="color:#f92672">(</span>Executable file<span style="color:#f92672">)</span>     // 哪种类型，可执行的还是需重定位的等
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x4000b0       //入口地址
  Start of program headers:          <span style="color:#ae81ff">64</span> <span style="color:#f92672">(</span>bytes into file<span style="color:#f92672">)</span>
  Start of section headers:          <span style="color:#ae81ff">736</span> <span style="color:#f92672">(</span>bytes into file<span style="color:#f92672">)</span>
  Flags:                             0x0
  Size of this header:               <span style="color:#ae81ff">64</span> <span style="color:#f92672">(</span>bytes<span style="color:#f92672">)</span>
  Size of program headers:           <span style="color:#ae81ff">56</span> <span style="color:#f92672">(</span>bytes<span style="color:#f92672">)</span>
  Number of program headers:         <span style="color:#ae81ff">2</span>
  Size of section headers:           <span style="color:#ae81ff">64</span> <span style="color:#f92672">(</span>bytes<span style="color:#f92672">)</span>
  Number of section headers:         <span style="color:#ae81ff">8</span>
  Section header string table index: <span style="color:#ae81ff">7</span></code></pre></div>
<h3 id="section">Section</h3>
<p>头部之后紧跟着各种各样的表，我们称之为Section(段)，各个section被计入可执行文件的Section header table中，我们可以这样查看:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac/assem $ readelf -S hello
There are <span style="color:#ae81ff">8</span> section headers, starting at offset 0x2e0:
Section Headers:
  <span style="color:#f92672">[</span>Nr<span style="color:#f92672">]</span> Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  <span style="color:#f92672">[</span> 0<span style="color:#f92672">]</span>                   NULL             <span style="color:#ae81ff">0000000000000000</span>  <span style="color:#ae81ff">00000000</span>
       <span style="color:#ae81ff">0000000000000000</span>  <span style="color:#ae81ff">0000000000000000</span>           <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>
  <span style="color:#f92672">[</span> 1<span style="color:#f92672">]</span> .text             PROGBITS         00000000004000b0  000000b0
       <span style="color:#ae81ff">0000000000000025</span>  <span style="color:#ae81ff">0000000000000000</span>  AX       <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">16</span>
  <span style="color:#f92672">[</span> 2<span style="color:#f92672">]</span> .data             PROGBITS         00000000006000d8  000000d8
       000000000000000e  <span style="color:#ae81ff">0000000000000000</span>  WA       <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">4</span>
  <span style="color:#f92672">[</span> 3<span style="color:#f92672">]</span> .stab             PROGBITS         <span style="color:#ae81ff">0000000000000000</span>  000000e8
       <span style="color:#ae81ff">0000000000000084</span>  <span style="color:#ae81ff">0000000000000014</span>           <span style="color:#ae81ff">4</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">4</span>
  <span style="color:#f92672">[</span> 4<span style="color:#f92672">]</span> .stabstr          STRTAB           <span style="color:#ae81ff">0000000000000000</span>  0000016c
       <span style="color:#ae81ff">0000000000000009</span>  <span style="color:#ae81ff">0000000000000000</span>           <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">1</span>
  <span style="color:#f92672">[</span> 5<span style="color:#f92672">]</span> .symtab           SYMTAB           <span style="color:#ae81ff">0000000000000000</span>  <span style="color:#ae81ff">00000178</span>
       <span style="color:#ae81ff">0000000000000108</span>  <span style="color:#ae81ff">0000000000000018</span>           <span style="color:#ae81ff">6</span>     <span style="color:#ae81ff">7</span>     <span style="color:#ae81ff">8</span>
  <span style="color:#f92672">[</span> 6<span style="color:#f92672">]</span> .strtab           STRTAB           <span style="color:#ae81ff">0000000000000000</span>  <span style="color:#ae81ff">00000280</span>
       <span style="color:#ae81ff">0000000000000027</span>  <span style="color:#ae81ff">0000000000000000</span>           <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">1</span>
  <span style="color:#f92672">[</span> 7<span style="color:#f92672">]</span> .shstrtab         STRTAB           <span style="color:#ae81ff">0000000000000000</span>  000002a7
       <span style="color:#ae81ff">0000000000000036</span>  <span style="color:#ae81ff">0000000000000000</span>           <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">1</span>
Key to Flags:
  W <span style="color:#f92672">(</span>write<span style="color:#f92672">)</span>, A <span style="color:#f92672">(</span>alloc<span style="color:#f92672">)</span>, X <span style="color:#f92672">(</span>execute<span style="color:#f92672">)</span>, M <span style="color:#f92672">(</span>merge<span style="color:#f92672">)</span>, S <span style="color:#f92672">(</span>strings<span style="color:#f92672">)</span>, I <span style="color:#f92672">(</span>info<span style="color:#f92672">)</span>,
  L <span style="color:#f92672">(</span>link order<span style="color:#f92672">)</span>, O <span style="color:#f92672">(</span>extra OS processing required<span style="color:#f92672">)</span>, G <span style="color:#f92672">(</span>group<span style="color:#f92672">)</span>, T <span style="color:#f92672">(</span>TLS<span style="color:#f92672">)</span>,
  C <span style="color:#f92672">(</span>compressed<span style="color:#f92672">)</span>, x <span style="color:#f92672">(</span>unknown<span style="color:#f92672">)</span>, o <span style="color:#f92672">(</span>OS specific<span style="color:#f92672">)</span>, E <span style="color:#f92672">(</span>exclude<span style="color:#f92672">)</span>,
  l <span style="color:#f92672">(</span>large<span style="color:#f92672">)</span>, p <span style="color:#f92672">(</span>processor specific<span style="color:#f92672">)</span></code></pre></div>
<p>其中，<code>Address</code>表示这个section加载到进程中的虚拟内存地址，<code>Offset</code>表示这个section相对于文件头部的偏移量，有了<code>Offset</code>+<code>Size</code>进程才知道如何安排相应的虚拟地址即<code>Address</code>。<code>Flags</code>表示权限标志位，<code>A</code>表示这个section的内容需要在内存中载入，<code>X</code>表示可执行的权限，<code>W</code>表示可写入的权限。</p>
<p><code>.text</code>用于存放二进制的执行代码(指令)。我们可以看到这个段的地址恰好是文件头中的Entry point address。</p>
<p><code>.data</code>用于存放所有已经初始化过的全局变量的数据，<code>.bss</code>用于存放未初始化的全局变量数据，虽然他们在内存中都需要相应的起始地址和内存区域，但在可执行文件中没必要用一定区域去记下<code>.bss</code>中的零值。<code>.rodata</code>专门用于保存只读数据，例如字符串的字面量，在很多语言中它都是只读的。</p>
<p><code>.symtab</code>表示符号表，源码中的字面量、全局变量、函数名、类型名、文件名等会作为符号记录在该表中，会记录它们的类型、作用域和内存地址。对于程序运行来讲，符号表没有什么用，CPU不管什么符号、类型，它只需要内存地址。符号就相当于是内存地址的助记符，主要是便于我们调试和反汇编使用的。</p>
<h3 id="segment">Segment</h3>
<p>执行的时候，我们需要告诉操作系统，有哪些section需要载入为内存中的segment，这个信息被链接器放在Program header table中，操作系统的载入器以此信息来安排程序在内存中的样子，我们可以这样查看:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac/assem $ readelf -l hello
Elf file type is EXEC <span style="color:#f92672">(</span>Executable file<span style="color:#f92672">)</span>
Entry point 0x4000b0
There are <span style="color:#ae81ff">2</span> program headers, starting at offset <span style="color:#ae81ff">64</span>
Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x00000000000000d5 0x00000000000000d5  R E    0x200000
  LOAD           0x00000000000000d8 0x00000000006000d8 0x00000000006000d8
                 0x000000000000000e 0x000000000000000e  RW     0x200000
 Section to Segment mapping:
  Segment Sections...
   <span style="color:#ae81ff">00</span>     .text
   <span style="color:#ae81ff">01</span>     .data</code></pre></div>
<p>上面的section to segment mapping就表示把section中的<code>.text</code>段的内容放在内存中<code>00</code>号的segment上。在可执行文件中会把section分的很细，但在内存中可能会把一些section合并起来，忽略掉一些section，起到节约内存的目的。</p>
<h2 id="函数调用">函数调用</h2>
<p>函数本身相当于一个图纸，出了设计院它就是只读的，放在<code>.text</code>段中，线程参考图纸来执行。线程通过IP/PC寄存器知道执行到图纸的哪里，下一条指令是什么，主线程通过可执行文件的入口地址找到第一条指令。</p>
<h3 id="调用堆栈">调用堆栈</h3>
<p>那么每个CPU核心只有一个IP寄存器，线程却有很多个怎么办？实际上在同一时刻，只有一个线程绑定了一个物理寄存器，若它的时间片用完了则由操作系统保存它对应的寄存器状态在某段内存中，下次轮到它执行时再恢复寄存器的状态。那么我们可以在抽象层面上理解为每个线程都有一套自己的寄存器。同时，这种切换线程需要消耗一定的资源，用于保存和恢复状态，用于内核态和用户态的切换。</p>
<p>函数执行过程中需要在线程中保存参数、返回值、局部变量等，这块内存叫做<strong>栈</strong>(Stack)。那么如果是嵌套调用，如何保存各函数的状态呢？</p>
<p><img src="./images/func.jpg" alt=""></p>
<p>如左图所示，A函数嵌套了B函数，A要等待B执行完成之后再接着执行自己的逻辑。所以我们一般把栈内存竖着画，由底部的高位向低位分配，函数执行结束则把其对应的内存区域销毁，如右图所示。我们把每一个函数所占的格子叫<strong>栈帧</strong>(Stack Frame)，把整个A、B、C的调用层次称为<strong>调用堆栈</strong>(Call Stack)。程序出错时候我们看到一级级的错误信息就是通过调用堆栈追溯到的。</p>
<p>调用一个函数，在指令级别上还是有很大的开销的，所以有了<strong>内联</strong>(inline)的优化手段。</p>
<h3 id="调用约定">调用约定</h3>
<p>接下来的问题是A调用B的时候，如何给B传递参数，如何接收B的返回值，要么A划定区域，要么B划定区域，要么用寄存器，要么用内存，我们把这种约定称为<strong>调用约定</strong>。以Go语言为例，若A调用B，则A会把自己的栈帧一分为二，下半部分存本地局部变量，上半部分存给B用的参数和B的返回值。若A调用B、C、D等多个函数，则上半部分占用多大空间按哪个函数的参数和返回值最大来算。如此一来，栈帧的大小是在编译期就能确定的，访问栈内某块内存只需根据相对位置，基于栈顶做加法或栈底做减法即可。</p>
<p>一般会把栈顶的地址放在SP寄存器，把栈底的地址放在BP寄存器。理论上，SP或者BP使用一个就够了，每个语言都有自己的选择。Go早期只用SP，后来也引入了BP，因为很多的调试器、自动化检测工具需要使用BP确定栈底的位置。</p>
<p>如果SP/BP用来存当前正在执行的B函数的栈帧，B执行完以后如何知道调用它的A函数的栈帧有多大呢？所以在两个栈帧之间还有一段空间用来存储A的BP/SP、IP，A在调用B的时候就把自己的BP/SP写进去，把自己调用完B之后下一条要执行什么指令写进IP，这叫保存现场。B执行完以后，通过这段空间恢复现场。接着，我们看看C语言和Go语言的保存现场和恢复现场分别是怎么做的。</p>
<h4 id="go语言">Go语言</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#a6e22e">z</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">z</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0x11</span>, <span style="color:#ae81ff">0x22</span>
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>)
	println(<span style="color:#a6e22e">s</span>)
}</code></pre></div>
<p>通过<code>go build -gcflags &quot;-N -l&quot; call.go</code>接着进行gdb调试:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> b <span style="color:#ae81ff">4</span>
Breakpoint <span style="color:#ae81ff">1</span> at 0x452347: file /root/.mac/gocode/call.go, line 4.
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> r
Thread <span style="color:#ae81ff">1</span> <span style="color:#e6db74">&#34;call&#34;</span> hit Breakpoint 1, main.add <span style="color:#f92672">(</span>x<span style="color:#f92672">=</span>17, y<span style="color:#f92672">=</span>34, ~r2<span style="color:#f92672">=</span>0<span style="color:#f92672">)</span> at /root/.mac/gocode/call.go:4
4		z :<span style="color:#f92672">=</span> x + y
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> disass
Dump of assembler code <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">function</span> main.add:
   0x0000000000452330 &lt;+0&gt;:	sub    rsp,0x10
   0x0000000000452334 &lt;+4&gt;:	mov    QWORD PTR <span style="color:#f92672">[</span>rsp+0x8<span style="color:#f92672">]</span>,rbp
   0x0000000000452339 &lt;+9&gt;:	lea    rbp,<span style="color:#f92672">[</span>rsp+0x8<span style="color:#f92672">]</span>
   0x000000000045233e &lt;+14&gt;:	mov    QWORD PTR <span style="color:#f92672">[</span>rsp+0x28<span style="color:#f92672">]</span>,0x0
<span style="color:#f92672">=</span>&gt; 0x0000000000452347 &lt;+23&gt;:	mov    rax,QWORD PTR <span style="color:#f92672">[</span>rsp+0x18<span style="color:#f92672">]</span>
   0x000000000045234c &lt;+28&gt;:	add    rax,QWORD PTR <span style="color:#f92672">[</span>rsp+0x20<span style="color:#f92672">]</span>
   0x0000000000452351 &lt;+33&gt;:	mov    QWORD PTR <span style="color:#f92672">[</span>rsp<span style="color:#f92672">]</span>,rax
   0x0000000000452355 &lt;+37&gt;:	mov    QWORD PTR <span style="color:#f92672">[</span>rsp+0x28<span style="color:#f92672">]</span>,rax
   0x000000000045235a &lt;+42&gt;:	mov    rbp,QWORD PTR <span style="color:#f92672">[</span>rsp+0x8<span style="color:#f92672">]</span>
   0x000000000045235f &lt;+47&gt;:	add    rsp,0x10
   0x0000000000452363 &lt;+51&gt;:	ret
End of assembler dump.</code></pre></div></p>
<p>我们可以把它的栈帧变化情况画出来:</p>
<p><img src="./images/go_func.jpg" alt=""></p>
<h4 id="c语言">C语言</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">__attribute__</span>((noinline, optimize(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">-O0</span><span style="color:#e6db74">&#34;</span>))) add(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y)
{
    <span style="color:#66d9ef">int</span> z;
    z <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> y;
    <span style="color:#66d9ef">return</span> z;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">__attribute__</span>((noinline)) main(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#f92672">*</span>argv)
{
    <span style="color:#66d9ef">int</span> x, y, a;
    x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x11</span>;
    y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x22</span>;
    a <span style="color:#f92672">=</span> add(x, y);
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, a);
}</code></pre></div>
<p>通过<code>gcc -g -O0 -o frame frame.c</code>接着进行gdb调试:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> b <span style="color:#ae81ff">5</span>
Breakpoint <span style="color:#ae81ff">1</span> at 0x654: file frame.c, line 5.
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> r
Breakpoint 1, add <span style="color:#f92672">(</span>x<span style="color:#f92672">=</span>17, y<span style="color:#f92672">=</span>34<span style="color:#f92672">)</span> at frame.c:6
6	    z <span style="color:#f92672">=</span> x + y;
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> disass
Dump of assembler code <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">function</span> add:
   0x000055555555464a &lt;+0&gt;:	push   rbp
   0x000055555555464b &lt;+1&gt;:	mov    rbp,rsp
   0x000055555555464e &lt;+4&gt;:	mov    DWORD PTR <span style="color:#f92672">[</span>rbp-0x14<span style="color:#f92672">]</span>,edi
   0x0000555555554651 &lt;+7&gt;:	mov    DWORD PTR <span style="color:#f92672">[</span>rbp-0x18<span style="color:#f92672">]</span>,esi
<span style="color:#f92672">=</span>&gt; 0x0000555555554654 &lt;+10&gt;:	mov    edx,DWORD PTR <span style="color:#f92672">[</span>rbp-0x14<span style="color:#f92672">]</span>
   0x0000555555554657 &lt;+13&gt;:	mov    eax,DWORD PTR <span style="color:#f92672">[</span>rbp-0x18<span style="color:#f92672">]</span>
   0x000055555555465a &lt;+16&gt;:	add    eax,edx
   0x000055555555465c &lt;+18&gt;:	mov    DWORD PTR <span style="color:#f92672">[</span>rbp-0x4<span style="color:#f92672">]</span>,eax
   0x000055555555465f &lt;+21&gt;:	mov    eax,DWORD PTR <span style="color:#f92672">[</span>rbp-0x4<span style="color:#f92672">]</span>
   0x0000555555554662 &lt;+24&gt;:	pop    rbp
   0x0000555555554663 &lt;+25&gt;:	ret
End of assembler dump.</code></pre></div>
同样可以画出图来:
<img src="./images/c_func.jpg" alt=""></p>
<h4 id="比较">比较</h4>
<p>相同点是在调用CALL指令的时候，先把main函数中执行完add函数的下一条指令(在IP寄存器中)存在栈里，在调用RET指令的时候，这条指令会被自动恢复入IP寄存器。</p>
<p>不同点是C语言通过<code>push</code>和<code>pop</code>指令入栈、出栈，让栈顶SP自动随着变化。而Go语言采用了<code>sub</code>、<code>add</code>指令直接计算栈顶地址。</p>
<p>此外，在C语言中，是优先通过寄存器传递参数和返回值，经常使用SI、DI寄存器传参，使用AX寄存器存储返回值，因为C是性能优先，寄存器肯定是最快的。Go是使用栈内存传参和返回值的，这和它本身Goroutine的运行方式有关。</p>
<h3 id="栈和堆">栈和堆</h3>
<p>堆、栈既是两种数据结构，也是函数执行单位，在不同的场景有不同的概念。</p>
<p>对于栈内存来讲，它是整块的，不需要垃圾回收器参与，访问的时候只需要根据BP、SP按相对位置进行访问，所以它的效率是非常高的。而堆内存是和单个线程无关的，是共享的，就会涉及到很复杂的内存管理方式，分配的时候要找到大小和位置合适的块，释放的时候要尽可能的避免内存碎片化。所以说，编译器有责任尽可能把数据分配在栈上。但是，栈上内存是按栈帧整块释放的，某些情况下如果某个变量要在不同的栈帧中维持，它的生命周期发生了改变，这种情况这个变量的内存就要在堆上分配了，这种现象就叫<strong>逃逸</strong>。逃逸也会带来严重的性能问题。</p>
</article>

      <div class="book-footer justify-between">
  

  
  
  <div>
    
    <a class="flex align-center" href="https://github.com/hjlarry/hjlarry.github.io/commit/89f874bb4705787191d3fdf6f437de690a99db3b" title='Last modified by hjlarry | January 13, 2020' target="_blank">
      <img src="/svg/calendar.svg" alt="Calendar" />
      <span>January 13, 2020</span>
    </a>
  </div>
  
  

  
  <div>
    <a class="flex align-center" href="https://github.com/hjlarry/hjlarry.github.io/edit/master/content/docs/sicp/software/_index.md" target="_blank">
      <img src="/svg/edit.svg" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>
  

</div>

      
    </div>

    
  

  <aside class="book-toc levels-3 fixed">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#操作系统">操作系统</a></li>
    <li><a href="#内核">内核</a></li>
    <li><a href="#系统调用">系统调用</a></li>
    <li><a href="#进程">进程</a>
      <ul>
        <li><a href="#基础概念">基础概念</a></li>
        <li><a href="#状态">状态</a></li>
        <li><a href="#调度">调度</a></li>
      </ul>
    </li>
    <li><a href="#线程">线程</a></li>
    <li><a href="#虚拟存储器">虚拟存储器</a>
      <ul>
        <li><a href="#基础概念-1">基础概念</a></li>
        <li><a href="#内存分配过程">内存分配过程</a></li>
        <li><a href="#换入换出">换入换出</a></li>
        <li><a href="#性能相关">性能相关</a></li>
      </ul>
    </li>
    <li><a href="#寄存器">寄存器</a>
      <ul>
        <li><a href="#通用寄存器">通用寄存器</a></li>
        <li><a href="#标志寄存器">标志寄存器</a></li>
      </ul>
    </li>
    <li><a href="#可执行文件">可执行文件</a>
      <ul>
        <li><a href="#head">Head</a></li>
        <li><a href="#section">Section</a></li>
        <li><a href="#segment">Segment</a></li>
      </ul>
    </li>
    <li><a href="#函数调用">函数调用</a>
      <ul>
        <li><a href="#调用堆栈">调用堆栈</a></li>
        <li><a href="#调用约定">调用约定</a></li>
        <li><a href="#栈和堆">栈和堆</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </aside>



  </main>

  
</body>

</html>
