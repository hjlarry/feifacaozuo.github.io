<!DOCTYPE html>
<html lang="cn">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Asm"><meta property="og:title" content="" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://hjlarry.github.io/docs/sicp/asm/" />

<title>Asm | Home</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/book.min.0379377fb17315c9a560efd4d406aea4535c095a461b220fd9e3d2e9c05550e6.css" integrity="sha256-A3k3f7FzFcmlYO/U1AaupFNcCVpGGyIP2ePS6cBVUOY=">


<script defer src="/cn.search.min.32ca3e8d5c253b9ec6abae41ff75d6e66f8182c7f6602db96d16bd7941e925d6.js" integrity="sha256-Mso&#43;jVwlO57Gq65B/3XW5m&#43;Bgsf2YC25bRa9eUHpJdY="></script>

<link rel="alternate" type="application/rss+xml" href="https://hjlarry.github.io/docs/sicp/asm/index.xml" title="Home" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://hjlarry.github.io/"><img src="/logo.png" alt="Logo" /><span>Home</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    <ul>
<li><strong>计算机基础</strong>

<ul>
<li><a href="/docs/sicp/hardware/">硬件</a></li>
<li><a href="/docs/sicp/software/">软件</a></li>
<li><a href="/docs/sicp/asm/"class=active>汇编</a></li>
</ul></li>
<li><strong>GO语言</strong>

<ul>
<li><a href="/docs/go/map/">字典</a></li>
<li><a href="/docs/go/closure/">闭包</a></li>
<li><a href="/docs/go/defer/">延迟调用</a></li>
<li><a href="/docs/go/gc/">垃圾回收</a></li>
<li><a href="/docs/go/alloc/">内存分配</a></li>
<li><a href="/docs/go/goroutine/">并发调度</a></li>
<li><a href="/docs/go/lock/">锁</a></li>
</ul></li>
<li><strong>Python语言</strong>

<ul>
<li>描述符</li>
</ul></li>
<li><strong>Mysql</strong>

<ul>
<li><a href="/docs/mysql/query/">查询</a></li>
<li>索引</li>
<li>原理</li>
</ul></li>
<li><strong>其他</strong>

<ul>
<li><a href="/docs/other/tools/">基础系统工具</a></li>
</ul></li>
</ul>





</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>Asm</strong>
</header>

      
<article class="markdown">

<h1 id="汇编语言">汇编语言</h1>

<h2 id="基础知识">基础知识</h2>

<p>编程语言是给人看的，CPU看不懂汇编语言，CPU能看懂的只有二进制指令。早期通过纸带打孔的方式输入指令，后来逐渐发展出了助记符，也就是例如跳转、循环之类的指令，再由编译器(汇编器)把这些助记符还原为二进制的指令。所以汇编语言可以理解为机器语言的一种方言，方便人类去记忆它，汇编语言和机器语言就存在着一定程度上的一一对应的关系。</p>

<p>汇编是面向机器编程的语言，不同的硬件的指令可能是不同的，它能直接访问硬件的存储和端口，最大程度发挥出硬件的能力。它还有一些其他的使用场景，例如优化代码追求极致效率、直接调试和修改没有源码的程序、诊断恶意软件、进行逆向分析等。汇编的缺点也显而易见，对多数人而言，汇编代码难懂，不易维护，难于调试，不易移植，开发效率低。</p>

<p>汇编语言的风格分为两种，Intel的和AT&amp;T的，相当于用不同的方言描述机器语言。AT&amp;T风格主要是GNU使用的，汇编器主要是GAS/as;Intel风格主要是windows使用的，汇编器有MASM、NASM、TASM、FASM。它们的主要区别在于AT&amp;T会在寄存器名字前加%，在立即操作数前加$前缀，且源和目标操作数的顺序和Intel相反。详细区别可参考<a href="https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80#%E7%B5%84%E8%AD%AF%E9%A2%A8%E6%A0%BC">wiki</a>，以及<a href="https://developer.ibm.com/articles/l-gas-nasm/">这篇文章</a>。</p>

<p>本文使用NASM汇编器，它采用Intel语法风格，支持很多种格式，包括ELF、COFF、Mach-O、Win32、Win64等，可使用<code>nasm -hf</code>查看其所有支持的格式。</p>

<h2 id="处理过程">处理过程</h2>

<p>Hello world示例程序:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">global</span> <span style="color:#66d9ef">_start</span> 

<span style="color:#66d9ef">section</span> <span style="color:#66d9ef">.data</span>
    <span style="color:#a6e22e">hello</span> : <span style="color:#66d9ef">db</span> <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#66d9ef">hello</span>, <span style="color:#66d9ef">world</span>!<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">n</span><span style="color:#960050;background-color:#1e0010">`</span>
<span style="color:#a6e22e">section</span> <span style="color:#66d9ef">.text</span> 
    <span style="color:#66d9ef">_start</span>:
        <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">1</span>      <span style="color:#75715e">; system call number should be store in rax
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">rdi</span>, <span style="color:#ae81ff">1</span>      <span style="color:#75715e">; argument #1 in rdi: where to write (descriptor)?
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">rsi</span>, <span style="color:#66d9ef">hello</span>  <span style="color:#75715e">; argument #2 in rsi: where does the string start?
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">rdx</span>, <span style="color:#ae81ff">14</span>     <span style="color:#75715e">; argument #3 in rdx: how many bytes to write?
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">syscall</span>         <span style="color:#75715e">; this instruction invokes a system call
</span><span style="color:#75715e"></span>        
        <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">60</span>     <span style="color:#75715e">; &#39;exit&#39; syscall number
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">xor</span> <span style="color:#66d9ef">rdi</span>, <span style="color:#66d9ef">rdi</span>
        <span style="color:#a6e22e">syscall</span></code></pre></div></p>

<h3 id="编译">编译</h3>

<p>把每一个源码文件(可能是<code>.c</code>,<code>.s</code>,<code>.go</code>等格式)翻译为一个目标文件(可能是<code>.o</code>)，它和可执行文件很像，也是由一个个表构成，但问题是A文件若调用B文件的函数，A是不知道B在哪的，编译器就会把这个B的位置空下来，并把这个信息写在表中某个位置等待之后进行重定位。</p>

<p>我们使用编译语句<code>nasm -g -F dwarf -f elf64 -o hello.o hello.s</code>来编译之前的helloworld程序。其中<code>-o hello.o</code>表示输出的目标文件名称为hello.o，<code>-f elf64</code>表示目标文件的格式采取elf64的，<code>-g</code>表示要生成调试信息，<code>-F dwarf</code>用来指定生成的调试信息的格式。此外可以通过<code>-O</code>指定不同的优化级别，可能有O0、O1、O2等，<code>-E</code>表示只做预处理。</p>

<p>日常说编译的时候往往指的是编译和链接两个过程。</p>

<h3 id="链接">链接</h3>

<p>链接就是把编译后的目标文件合并在一起，通过起始地址就能计算出各个目标文件的偏移量，也就知道了编译时需要重定位的那些函数的地址，再把它填进去。</p>

<p>我们使用GNU通用的链接器来链接，也可以对比出目标文件和链接后的可执行文件的区别:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac/assem $ nasm -g -f elf64 -o hello.o hello.s
<span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac/assem $ ld -o hello hello.o

<span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac/assem $ file hello.o
hello.o: ELF <span style="color:#ae81ff">64</span>-bit LSB relocatable, x86-64, version <span style="color:#ae81ff">1</span> <span style="color:#f92672">(</span>SYSV<span style="color:#f92672">)</span>, not stripped
<span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac/assem $ file hello
hello: ELF <span style="color:#ae81ff">64</span>-bit LSB executable, x86-64, version <span style="color:#ae81ff">1</span> <span style="color:#f92672">(</span>SYSV<span style="color:#f92672">)</span>, statically linked, not stripped

<span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac/assem $ objdump -d -M intel hello.o
hello.o:     file format elf64-x86-64
Disassembly of section .text:
<span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#ae81ff">0000000000000000</span> &lt;_start&gt;:
</span>   <span style="color:#ae81ff">0</span>:	b8 <span style="color:#ae81ff">01</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>       	mov    eax,0x1
   <span style="color:#ae81ff">5</span>:	bf <span style="color:#ae81ff">01</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>       	mov    edi,0x1
<span style="display:block;width:100%;background-color:#3c3d38">   a:	<span style="color:#ae81ff">48</span> be <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> 	movabs rsi,0x0
</span>  <span style="color:#ae81ff">11</span>:	<span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>
  <span style="color:#ae81ff">14</span>:	ba 0e <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>       	mov    edx,0xe
  <span style="color:#ae81ff">19</span>:	0f <span style="color:#ae81ff">05</span>                	syscall
  1b:	b8 3c <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>       	mov    eax,0x3c
  <span style="color:#ae81ff">20</span>:	<span style="color:#ae81ff">48</span> <span style="color:#ae81ff">31</span> ff             	xor    rdi,rdi
  <span style="color:#ae81ff">23</span>:	0f <span style="color:#ae81ff">05</span>                	syscall
<span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac/assem $ objdump -d -M intel hello
hello:     file format elf64-x86-64
Disassembly of section .text:
<span style="display:block;width:100%;background-color:#3c3d38">00000000004000b0 &lt;_start&gt;:
</span>  4000b0:	b8 <span style="color:#ae81ff">01</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>       	mov    eax,0x1
  4000b5:	bf <span style="color:#ae81ff">01</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>       	mov    edi,0x1
<span style="display:block;width:100%;background-color:#3c3d38">  4000ba:	<span style="color:#ae81ff">48</span> be d8 <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">60</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> 	movabs rsi,0x6000d8
</span>  4000c1:	<span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>
  4000c4:	ba 0e <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>       	mov    edx,0xe
  4000c9:	0f <span style="color:#ae81ff">05</span>                	syscall
  4000cb:	b8 3c <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>       	mov    eax,0x3c
  4000d0:	<span style="color:#ae81ff">48</span> <span style="color:#ae81ff">31</span> ff             	xor    rdi,rdi
  4000d3:	0f <span style="color:#ae81ff">05</span>                	syscall</code></pre></div></p>

<p>通过反编译发现目标文件的起始地址_start是0，所以此时的<code>movabs rsi,0x0</code>也表示不知道hello的地址，而链接之后这些地址都有了。链接器也支持一些常见的参数，例如<code>-e</code>去指定一个非默认的入口标签，<code>-s</code>去移除所有的符号信息，<code>-S</code>仅移除调试信息。</p>

<p>我们再来看看Go的编译和链接过程:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac/gocode $ go build -x main.go
WORK<span style="color:#f92672">=</span>/tmp/go-build182029561
mkdir -p $WORK/b001/
cat &gt;$WORK/b001/importcfg <span style="color:#e6db74">&lt;&lt; &#39;EOF&#39; # internal
</span><span style="color:#e6db74"># import config
</span><span style="color:#e6db74">packagefile runtime=/usr/local/go/pkg/linux_amd64/runtime.a
</span><span style="color:#e6db74">EOF</span>
cd /root/.mac/gocode
<span style="display:block;width:100%;background-color:#3c3d38">/usr/local/go/pkg/tool/linux_amd64/compile -o $WORK/b001/_pkg_.a -trimpath <span style="color:#e6db74">&#34;</span>$WORK<span style="color:#e6db74">/b001=&gt;&#34;</span> -p main -complete -buildid dR1ZsbI6brd59SPrnOhX/dR1ZsbI6brd59SPrnOhX -goversion go1.13 -D _/root/.mac/gocode -importcfg $WORK/b001/importcfg -pack -c<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> ./main.go
</span>/usr/local/go/pkg/tool/linux_amd64/buildid -w $WORK/b001/_pkg_.a <span style="color:#75715e"># internal</span>
cp $WORK/b001/_pkg_.a /root/.cache/go-build/dd/ddfadd34424d01a7a08b5c1cad7d09610caf9d21c8372338aed2d3331c8802cd-d <span style="color:#75715e"># internal</span>
cat &gt;$WORK/b001/importcfg.link <span style="color:#e6db74">&lt;&lt; &#39;EOF&#39; # internal
</span><span style="color:#e6db74">packagefile command-line-arguments=$WORK/b001/_pkg_.a
</span><span style="color:#e6db74">packagefile runtime=/usr/local/go/pkg/linux_amd64/runtime.a
</span><span style="color:#e6db74">packagefile internal/bytealg=/usr/local/go/pkg/linux_amd64/internal/bytealg.a
</span><span style="color:#e6db74">packagefile internal/cpu=/usr/local/go/pkg/linux_amd64/internal/cpu.a
</span><span style="color:#e6db74">packagefile runtime/internal/atomic=/usr/local/go/pkg/linux_amd64/runtime/internal/atomic.a
</span><span style="color:#e6db74">packagefile runtime/internal/math=/usr/local/go/pkg/linux_amd64/runtime/internal/math.a
</span><span style="color:#e6db74">packagefile runtime/internal/sys=/usr/local/go/pkg/linux_amd64/runtime/internal/sys.a
</span><span style="color:#e6db74">EOF</span>
mkdir -p $WORK/b001/exe/
cd .
<span style="display:block;width:100%;background-color:#3c3d38">/usr/local/go/pkg/tool/linux_amd64/link -o $WORK/b001/exe/a.out -importcfg $WORK/b001/importcfg.link -buildmode<span style="color:#f92672">=</span>exe -buildid<span style="color:#f92672">=</span>Nk0qisr5lCLaTQS25eF-/dR1ZsbI6brd59SPrnOhX/NtfWFt1P1m_70TCcgRz3/Nk0qisr5lCLaTQS25eF- -extld<span style="color:#f92672">=</span>gcc $WORK/b001/_pkg_.a
</span>/usr/local/go/pkg/tool/linux_amd64/buildid -w $WORK/b001/exe/a.out <span style="color:#75715e"># internal</span>
cp $WORK/b001/exe/a.out main
rm -r $WORK/b001/</code></pre></div></p>

<p>它也有自己的编译器和链接器，只是它的目标文件通过<code>-pack</code>参数进行了打包，打包为一个个<code>.a</code>格式再进行链接。</p>

<h2 id="源码结构">源码结构</h2>

<p>汇编语言都是对内存的处理，其本身没有函数的概念，为了便于维护和写跳转之类的语句，就有了标签代表相应的内存地址，放在不同的section中。</p>

<h3 id="标签">标签</h3>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">global</span> <span style="color:#66d9ef">_start</span> 

<span style="color:#66d9ef">section</span> <span style="color:#66d9ef">.text</span> 
    <span style="color:#66d9ef">main</span>:
        <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">60</span>
        <span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">rdi</span>, <span style="color:#66d9ef">rdi</span>
        <span style="color:#a6e22e">syscall</span>
    _start:
        <span style="color:#a6e22e">jmp</span> <span style="color:#66d9ef">main</span> </code></pre></div>

<p>上述源码中<code>main</code>与<code>_start</code>称为标签，可以使用<code>jmp</code>跳转至某个标签，或者<code>call</code>调用某个标签的内容。</p>

<p>标签会被编译器翻译为内存地址，我们通过符号表也能看到它。使用global可以把这个标签声明为全局的标签。</p>

<h3 id="本地标签">本地标签</h3>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">section</span> <span style="color:#66d9ef">.text</span> 
    <span style="color:#66d9ef">main</span>:
        <span style="color:#a6e22e">jmp</span> <span style="color:#66d9ef">.hello</span>
    .hello:
        <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">60</span>
        <span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">rdi</span>, <span style="color:#66d9ef">rdi</span>
        <span style="color:#a6e22e">syscall</span></code></pre></div>

<p>以<code>.</code>开头的称为本地标签，例如上面的<code>.hello</code>，编译器会把它翻译为其前一个标签+本地标签，即<code>main.hello</code>，这样就形成了一种类似于名字空间的效果。让大段的逻辑分成多个片段，不需要担心命名上的冲突，属于汇编这门语言提供的一个功能。它和本地符号无关，<code>main.hello</code>也可以是一个全局的符号，代表的一种身份，而<code>.hello</code>依然是一个本地标签，相当于一个称谓。</p>

<h3 id="入口标签">入口标签</h3>

<p>GNU的链接器默认使用一个特殊符号<code>_start</code>当做程序的入口，如果我们没定义这样的名字或者把它改为一个其他名字，那么链接器链接的时候就会用一个默认的地址，这个地址可能是程序<code>.text</code>段的第一行，同时链接器会提示:<code>ld: warning: cannot find entry symbol _start; defaulting to 00000000004000b0</code>。链接器允许使用<code>ld -e</code>自行指定一个入口标签，当然这个标签必须是全局的。</p>

<h3 id="段标签与内存地址">段标签与内存地址</h3>

<p>可以使用<code>$</code>表示当前这行指令的内存地址，<code>$$</code>表示当前section的起始地址，同时我们也可以通过反汇编观察到跳转时标签和内存地址一一对应的关系:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">global</span> <span style="color:#66d9ef">_start</span> 
<span style="color:#66d9ef">section</span> <span style="color:#66d9ef">.text</span> 
    <span style="color:#66d9ef">main</span>:
        <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rax</span>, <span style="color:#66d9ef">main</span> 
        <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">rbx</span>, <span style="color:#66d9ef">.exit</span>
        <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rcx</span>, <span style="color:#66d9ef">$</span>
        <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rdx</span>, <span style="color:#66d9ef">$$</span>
    .exit:    
        <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">60</span>
        <span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">rdi</span>, <span style="color:#66d9ef">rdi</span>
        <span style="color:#a6e22e">syscall</span>
    _start:
        <span style="color:#a6e22e">jmp</span> <span style="color:#66d9ef">main</span></code></pre></div></p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac/assem $ nasm -g -F dwarf -f elf64 -o hello.o hello.s
<span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac/assem $ ld -o hello hello.o
<span style="color:#f92672">[</span>ubuntu<span style="color:#f92672">]</span> ~/.mac/assem $ objdump -d -M intel hello
hello:     file format elf64-x86-64
Disassembly of section .text:
<span style="color:#ae81ff">0000000000400080</span> &lt;main&gt;:
  <span style="color:#ae81ff">400080</span>:	<span style="color:#ae81ff">48</span> b8 <span style="color:#ae81ff">80</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">40</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> 	movabs rax,0x400080
  <span style="color:#ae81ff">400087</span>:	<span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>
  40008a:	<span style="color:#ae81ff">48</span> bb a8 <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">40</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> 	movabs rbx,0x4000a8
  <span style="color:#ae81ff">400091</span>:	<span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>
  <span style="color:#ae81ff">400094</span>:	<span style="color:#ae81ff">48</span> b9 <span style="color:#ae81ff">94</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">40</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> 	movabs rcx,0x400094
  40009b:	<span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>
  40009e:	<span style="color:#ae81ff">48</span> ba <span style="color:#ae81ff">80</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">40</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> 	movabs rdx,0x400080
  4000a5:	<span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>
00000000004000a8 &lt;main.exit&gt;:
  4000a8:	b8 3c <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>       	mov    eax,0x3c
  4000ad:	<span style="color:#ae81ff">48</span> <span style="color:#ae81ff">31</span> ff             	xor    rdi,rdi
  4000b0:	0f <span style="color:#ae81ff">05</span>                	syscall
00000000004000b2 &lt;_start&gt;:
  4000b2:	eb cc                	jmp    <span style="color:#ae81ff">400080</span> &lt;main&gt;</code></pre></div>

<h2 id="语言规范">语言规范</h2>

<h3 id="寻址方式">寻址方式</h3>

<p>寻址方式就是通过什么方式确定目标所在的地址。我们把寄存器当成一个个的盒子，有以下几种寻址方式:</p>

<ul>
<li>立即寻址，<code>mov rax, 0x100</code>，直接把值0x100放在一个盒子中</li>
<li>寄存器寻址，<code>mov rax, rbx</code>，把一个盒子中的值放在另一个盒子中</li>
<li>直接寻址，<code>mov rax, [5]</code>，把5#盒子中的值放在另一个盒子中，5代表内存地址</li>
<li>寄存器间接寻址，<code>mov rax,[rbx]</code>，rbx中存着内存地址，把这个地址对应的值放在盒子中</li>
<li>寄存器相对寻址，<code>mov rax,[8+rbx]</code>，先算出rbx+8，得到一个内存地址而已</li>
<li>基址变址，<code>lea rax, [rbx+rcx]</code>，把地址拿出来放到盒子里</li>
</ul>

<p><code>mov rax, 0x100</code>表示给rax赋值为0x100，<code>mov rax, [0x100]</code>表示给rax赋值内存0x100位置的值，<code>lea rax, [0x100]</code>表示直接去找[0x100]的地址即0x100，赋值给rax。<code>mov</code>是对于内容的操作，<code>lea</code>是对于地址的操作。<code>mov</code>是不能直接在两块内存之间进行复制的。<code>[addr]</code>这种表达方式属于NASM编译器对内存操作必须这么做，即便是一个变量名称（代表一个内存地址），例如<code>x=100</code>，也得用<code>[x]</code>才取的到它的值100。</p>

<h3 id="变量">变量</h3>

<p>可以在<code>.data</code>和<code>.bss</code>段中定义变量，定义示例:
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">section</span> <span style="color:#66d9ef">.data</span>
    <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">dq</span> <span style="color:#ae81ff">0x8070605040302010</span>    
    <span style="color:#66d9ef">y</span> <span style="color:#66d9ef">db</span> <span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>
    <span style="color:#a6e22e">z</span> <span style="color:#66d9ef">times</span> <span style="color:#ae81ff">3</span> <span style="color:#66d9ef">dw</span> <span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>                  
    <span style="color:#66d9ef">leny</span> <span style="color:#66d9ef">equ</span> <span style="color:#66d9ef">$-y</span>                <span style="color:#75715e">;$为当前地址，所以减去y的地址，就是y的长度
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">s</span> <span style="color:#66d9ef">db</span> <span style="color:#960050;background-color:#1e0010">&#34;</span><span style="color:#66d9ef">abcd</span><span style="color:#960050;background-color:#1e0010">&#34;</span>, <span style="color:#960050;background-color:#1e0010">&#34;</span><span style="color:#66d9ef">e</span><span style="color:#960050;background-color:#1e0010">&#34;</span>, <span style="color:#960050;background-color:#1e0010">&#34;</span><span style="color:#66d9ef">f</span><span style="color:#960050;background-color:#1e0010">&#34;</span>       <span style="color:#75715e">; db*6
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">lens</span> <span style="color:#66d9ef">equ</span> <span style="color:#66d9ef">$-s</span>                <span style="color:#75715e">; equ定义的是常量，不会存储在.data中
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">section</span> <span style="color:#66d9ef">.bss</span>
    <span style="color:#a6e22e">xx</span> <span style="color:#66d9ef">resq</span> <span style="color:#ae81ff">2</span> 
    <span style="color:#66d9ef">yy</span> <span style="color:#66d9ef">times</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">resb</span> <span style="color:#ae81ff">8</span></code></pre></div>
<code>x</code>是变量名称，代表符号的地址，变量的起始地址；<code>dq</code>代表它的长度；<code>0x8070605040302010</code>代表它的初始化值。</p>

<p>字符和它代表的长度如下表所示:</p>

<table>
<thead>
<tr>
<th>.data中</th>
<th>长度(bytes)</th>
<th>.bss中</th>
</tr>
</thead>

<tbody>
<tr>
<td>db</td>
<td>1</td>
<td>resb</td>
</tr>

<tr>
<td>dw</td>
<td>2</td>
<td>resw</td>
</tr>

<tr>
<td>dd</td>
<td>4</td>
<td>resd</td>
</tr>

<tr>
<td>dq</td>
<td>8</td>
<td>resq</td>
</tr>

<tr>
<td>dt</td>
<td>10</td>
<td>rest</td>
</tr>

<tr>
<td>do</td>
<td>16</td>
<td>reso</td>
</tr>

<tr>
<td>dy</td>
<td>32</td>
<td>resy</td>
</tr>

<tr>
<td>dz</td>
<td>64</td>
<td>resz</td>
</tr>
</tbody>
</table>

<p><code>y db 1,2,3</code>就表示从y这个内存地址开始，后面逗号分隔的有三块内存，每块内存都是db大小且值为对应的1、2、3。汇编语言中是没有字符串的，像<code>&quot;abcd&quot;</code>就是拿它的ASCII值把它当做字节序列。<code>s db &quot;abcd&quot;, &quot;e&quot;, &quot;f&quot;</code>中db放不下整个<code>&quot;abcd&quot;</code>，就用了4个db来放。<code>equ</code>是定义常量的方式，见后文描述。另外，数字有大小端和进制的问题。</p>

<p>在<code>.data</code>中是定义，而在<code>.bss</code>中是预留。<code>xx resq 2</code>就表示从<code>xx</code>开始，预留<code>resq</code>大小的空间，预留<code>2</code>组。</p>

<p><code>times</code>类似于语法糖，用于重复定义数据或指令。<code>yy times 2 resb 8</code>就表示<code>yy resb 8</code>重复两次。</p>

<h3 id="常量">常量</h3>

<p>常量是不会存在<code>.data</code>段中的，尽管我们在那里定义，但它会被编译器展开，变为指令的一部分，保存在<code>.text</code>段中。</p>

<p>汇编语言中常量有四种，即整数、浮点数、字符、字符串。整数常量的值有不同的写法:</p>

<ul>
<li>十进制的，100, 0100, 100d, 0100d, 0d100</li>
<li>十六进制的，0h64, 0x64, $064, 64h</li>
<li>二进制的，0b101, 101b</li>
</ul>

<p>字符代表的是其ASCII的常量值，支持转义，支持单双和反引号。字符串会被解析为ASCII的序列，从左依次排列。</p>

<p>整型常量通过<code>equ</code>定义，例如<code>leny equ $-y</code>，它常用来和<code>$</code>、<code>$$</code>配合计算长度，但不支持用它来定义浮点数。</p>

<p>另一种常见的定义方式是使用<code>%assign name value</code>，它可以在任意位置定义，而且可以重复定义，使用时以最后一次的定义为准。这种定义方式属于使用宏，它是编译器在对代码预处理阶段就展开的。</p>
</article>

      <div class="book-footer justify-between">
  

  
  
  <div>
    
    <a class="flex align-center" href="https://github.com/hjlarry/hjlarry.github.io/commit/33a23412208c5f0ffc5d3a610a924f7b3fe461fe" title='Last modified by hjlarry | December 30, 2019' target="_blank">
      <img src="/svg/calendar.svg" alt="Calendar" />
      <span>December 30, 2019</span>
    </a>
  </div>
  
  

  
  <div>
    <a class="flex align-center" href="https://github.com/hjlarry/hjlarry.github.io/edit/master/content/docs/sicp/asm/_index.md" target="_blank">
      <img src="/svg/edit.svg" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>
  

</div>

      
    </div>

    
  

  <aside class="book-toc levels-3 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#汇编语言">汇编语言</a>
<ul>
<li><a href="#基础知识">基础知识</a></li>
<li><a href="#处理过程">处理过程</a>
<ul>
<li><a href="#编译">编译</a></li>
<li><a href="#链接">链接</a></li>
</ul></li>
<li><a href="#源码结构">源码结构</a>
<ul>
<li><a href="#标签">标签</a></li>
<li><a href="#本地标签">本地标签</a></li>
<li><a href="#入口标签">入口标签</a></li>
<li><a href="#段标签与内存地址">段标签与内存地址</a></li>
</ul></li>
<li><a href="#语言规范">语言规范</a>
<ul>
<li><a href="#寻址方式">寻址方式</a></li>
<li><a href="#变量">变量</a></li>
<li><a href="#常量">常量</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>

  
</body>

</html>
